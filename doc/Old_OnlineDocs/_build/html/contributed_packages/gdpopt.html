

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>GDPopt logic-based solver &mdash; Pyomo 6.5.1.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Infeasible Irreducible System (IIS) Tool" href="iis.html" />
    <link rel="prev" title="Pyomo.DoE" href="doe/doe.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Pyomo
          

          
          </a>

          
            
            
              <div class="version">
                6.5.1.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../citing_pyomo.html">Citing Pyomo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pyomo_overview/index.html">Pyomo Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pyomo_modeling_components/index.html">Pyomo Modeling Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../solving_pyomo_models.html">Solving Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_models.html">Working with Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_abstractmodels/index.html">Working with Abstract Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../model_transformations/index.html">Model Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modeling_extensions/index.html">Modeling Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial_examples.html">Pyomo Tutorial Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../model_debugging/index.html">Debugging Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced_topics/index.html">Advanced Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../errors.html">Common Warnings/Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer_reference/index.html">Developer Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../library_reference/index.html">Library Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribution_guide.html">Contributing to Pyomo</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Third-Party Contributions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="community.html">Community Detection for Pyomo models</a></li>
<li class="toctree-l2"><a class="reference internal" href="doe/doe.html">Pyomo.DoE</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">GDPopt logic-based solver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#logic-based-outer-approximation-loa">Logic-based Outer Approximation (LOA)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#global-logic-based-outer-approximation-gloa">Global Logic-based Outer Approximation (GLOA)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#relaxation-with-integer-cuts-ric">Relaxation with Integer Cuts (RIC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#logic-based-branch-and-bound-lbb">Logic-based Branch-and-Bound (LBB)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gdpopt-implementation-and-optional-arguments">GDPopt implementation and optional arguments</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="iis.html">Infeasible Irreducible System (IIS) Tool</a></li>
<li class="toctree-l2"><a class="reference internal" href="incidence/index.html">Incidence Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="mindtpy.html">MindtPy Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="mpc/index.html">MPC</a></li>
<li class="toctree-l2"><a class="reference internal" href="multistart.html">Multistart Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="preprocessing.html">Nonlinear Preprocessing Transformations</a></li>
<li class="toctree-l2"><a class="reference internal" href="parmest/index.html">Parameter Estimation with <code class="docutils literal notranslate"><span class="pre">parmest</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="pynumero/index.html">PyNumero</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyros.html">PyROS Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="sensitivity_toolbox.html">Sensitivity Toolbox</a></li>
<li class="toctree-l2"><a class="reference internal" href="trustregion.html">Trust Region Framework Method Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="mcpp.html">MC++ Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="satsolver.html">z3 SMT Sat Solver Interface</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../related_packages.html">Related Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Pyomo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Third-Party Contributions</a> &raquo;</li>
        
      <li>GDPopt logic-based solver</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/contributed_packages/gdpopt.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="gdpopt-logic-based-solver">
<span id="gdpopt-main-page"></span><h1>GDPopt logic-based solver<a class="headerlink" href="#gdpopt-logic-based-solver" title="Permalink to this headline">Â¶</a></h1>
<p>The GDPopt solver in Pyomo allows users to solve nonlinear Generalized
Disjunctive Programming (GDP) models using logic-based decomposition
approaches, as opposed to the conventional approach via reformulation to a
Mixed Integer Nonlinear Programming (MINLP) model.</p>
<p>The main advantage of these techniques is their ability to solve subproblems
in a reduced space, including nonlinear constraints only for <code class="docutils literal notranslate"><span class="pre">True</span></code> logical blocks.
As a result, GDPopt is most effective for nonlinear GDP models.</p>
<p>Three algorithms are available in GDPopt:</p>
<ol class="arabic simple">
<li>Logic-based outer approximation (LOA) [<a class="reference external" href="https://dx.doi.org/10.1016/0098-1354(95)00219-7">Turkay &amp; Grossmann, 1996</a>]</li>
<li>Global logic-based outer approximation (GLOA) [<a class="reference external" href="https://doi.org/10.1016/S0098-1354(01)00732-3">Lee &amp; Grossmann, 2001</a>]</li>
<li>Logic-based branch-and-bound (LBB) [<a class="reference external" href="https://doi.org/10.1016/S0098-1354(01)00732-3">Lee &amp; Grossmann, 2001</a>]</li>
</ol>
<p>Usage and implementation details for GDPopt can be found in the PSE 2018 paper
(<a class="reference external" href="https://doi.org/10.1016/B978-0-444-64241-7.50143-9">Chen et al., 2018</a>), or via its
<a class="reference external" href="http://egon.cheme.cmu.edu/Papers/Chen_Pyomo_GDP_PSE2018.pdf">preprint</a>.</p>
<p>Credit for prototyping and development can be found in the <code class="docutils literal notranslate"><span class="pre">GDPopt</span></code> class documentation, below.</p>
<p>GDPopt can be used to solve a Pyomo.GDP concrete model in two ways.
The simplest is to instantiate the generic GDPopt solver and specify the desired algorithm as an argument to the <code class="docutils literal notranslate"><span class="pre">solve</span></code> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SolverFactory</span><span class="p">(</span><span class="s1">&#39;gdpopt&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;LOA&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The alternative is to instantiate an algorithm-specific GDPopt solver:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SolverFactory</span><span class="p">(</span><span class="s1">&#39;gdpopt.loa&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above examples, GDPopt uses the GDPopt-LOA algorithm.
Other algorithms may be used by specifying them in the <code class="docutils literal notranslate"><span class="pre">algorithm</span></code> argument when using the generic solver or by instantiating the algorithm-specific GDPopt solvers. All GDPopt options are listed below.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The generic GDPopt solver allows minimal configuration outside of the arguments to the <code class="docutils literal notranslate"><span class="pre">solve</span></code> method. To avoid repeatedly specifying the same configuration options to the <code class="docutils literal notranslate"><span class="pre">solve</span></code> method, use the algorithm-specific solvers.</p>
</div>
<div class="section" id="logic-based-outer-approximation-loa">
<h2>Logic-based Outer Approximation (LOA)<a class="headerlink" href="#logic-based-outer-approximation-loa" title="Permalink to this headline">Â¶</a></h2>
<p><a class="reference external" href="https://doi.org/10.1016/B978-0-444-64241-7.50143-9">Chen et al., 2018</a> contains the following flowchart, taken from the preprint version:</p>
<a class="reference internal image-reference" href="../_images/gdpopt_flowchart.png"><img alt="../_images/gdpopt_flowchart.png" src="../_images/gdpopt_flowchart.png" style="width: 649.5999999999999px; height: 172.2px;" /></a>
<p>An example that includes the modeling approach may be found below.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="go">Required imports</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyomo.environ</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyomo.gdp</span> <span class="kn">import</span> <span class="o">*</span>

<span class="go">Create a simple model</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">ConcreteModel</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;LOA example&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">fix_x</span> <span class="o">=</span> <span class="n">Disjunct</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">fix_x</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">fix_y</span> <span class="o">=</span> <span class="n">Disjunct</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">fix_y</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">Disjunction</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">fix_x</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">fix_y</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">objective</span> <span class="o">=</span> <span class="n">Objective</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">model</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">sense</span><span class="o">=</span><span class="n">minimize</span><span class="p">)</span>

<span class="go">Solve the model using GDPopt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">SolverFactory</span><span class="p">(</span><span class="s1">&#39;gdpopt.loa&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">model</span><span class="p">,</span> <span class="n">mip_solver</span><span class="o">=</span><span class="s1">&#39;glpk&#39;</span><span class="p">)</span> 

<span class="go">Display the final solution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">display</span><span class="p">()</span>
<span class="go">Model LOA example</span>

<span class="go">  Variables:</span>
<span class="go">    x : Size=1, Index=None</span>
<span class="go">        Key  : Lower : Value : Upper : Fixed : Stale : Domain</span>
<span class="go">        None :  -1.2 :   0.0 :     2 : False : False :  Reals</span>
<span class="go">    y : Size=1, Index=None</span>
<span class="go">        Key  : Lower : Value : Upper : Fixed : Stale : Domain</span>
<span class="go">        None :   -10 :   1.0 :    10 : False : False :  Reals</span>

<span class="go">  Objectives:</span>
<span class="go">    objective : Size=1, Index=None, Active=True</span>
<span class="go">        Key  : Active : Value</span>
<span class="go">        None :   True :   0.1</span>

<span class="go">  Constraints:</span>
<span class="go">    c : Size=1</span>
<span class="go">        Key  : Lower : Body : Upper</span>
<span class="go">        None :   1.0 :  1.0 :   1.0</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When troubleshooting, it can often be helpful to turn on verbose
output using the <code class="docutils literal notranslate"><span class="pre">tee</span></code> flag.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SolverFactory</span><span class="p">(</span><span class="s1">&#39;gdpopt.loa&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">tee</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="global-logic-based-outer-approximation-gloa">
<h2>Global Logic-based Outer Approximation (GLOA)<a class="headerlink" href="#global-logic-based-outer-approximation-gloa" title="Permalink to this headline">Â¶</a></h2>
<p>The same algorithm can be used to solve GDPs involving nonconvex nonlinear constraints by solving the subproblems globally:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SolverFactory</span><span class="p">(</span><span class="s1">&#39;gdpopt.gloa&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">nlp_solver</span></code> option must be set to a global solver for the solution returned by GDPopt to also be globally optimal.</p>
</div>
</div>
<div class="section" id="relaxation-with-integer-cuts-ric">
<h2>Relaxation with Integer Cuts (RIC)<a class="headerlink" href="#relaxation-with-integer-cuts-ric" title="Permalink to this headline">Â¶</a></h2>
<p>Instead of outer approximation, GDPs can be solved using the same MILP relaxation as in the previous two algorithms, but instead of using the subproblems to generate outer-approximation cuts, the algorithm adds only no-good cuts for every discrete solution encountered:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SolverFactory</span><span class="p">(</span><span class="s1">&#39;gdpopt.ric&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
<p>Again, this is a global algorithm if the subproblems are solved globally, and is not otherwise.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The RIC algorithm will not necessarily enumerate all discrete solutions as it is possible for the bounds to converge first. However, full enumeration is not uncommon.</p>
</div>
</div>
<div class="section" id="logic-based-branch-and-bound-lbb">
<h2>Logic-based Branch-and-Bound (LBB)<a class="headerlink" href="#logic-based-branch-and-bound-lbb" title="Permalink to this headline">Â¶</a></h2>
<p>The GDPopt-LBB solver branches through relaxed subproblems with inactive disjunctions.
It explores the possibilities based on best lower bound,
eventually activating all disjunctions and presenting the globally optimal solution.</p>
<p>To use the GDPopt-LBB solver, define your Pyomo GDP model as usual:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="go">Required imports</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyomo.environ</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyomo.gdp</span> <span class="kn">import</span> <span class="n">Disjunct</span><span class="p">,</span> <span class="n">Disjunction</span>

<span class="go">Create a simple model</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">ConcreteModel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">x1</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">x2</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">Objective</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">x1</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="n">sense</span><span class="o">=</span><span class="n">minimize</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">y1</span> <span class="o">=</span> <span class="n">Disjunct</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">y2</span> <span class="o">=</span> <span class="n">Disjunct</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">y1</span><span class="o">.</span><span class="n">c1</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">x1</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">y1</span><span class="o">.</span><span class="n">c2</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">x2</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">y2</span><span class="o">.</span><span class="n">c1</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">x1</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">y2</span><span class="o">.</span><span class="n">c2</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">x2</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">djn</span> <span class="o">=</span> <span class="n">Disjunction</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">y1</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">y2</span><span class="p">])</span>

<span class="go">Invoke the GDPopt-LBB solver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">SolverFactory</span><span class="p">(</span><span class="s1">&#39;gdpopt.lbb&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
<span class="go">ok</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">termination_condition</span><span class="p">)</span>
<span class="go">optimal</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="n">value</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">y1</span><span class="o">.</span><span class="n">indicator_var</span><span class="p">),</span> <span class="n">value</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">y2</span><span class="o">.</span><span class="n">indicator_var</span><span class="p">)])</span>
<span class="go">[True, False]</span>
</pre></div>
</div>
</div>
<div class="section" id="gdpopt-implementation-and-optional-arguments">
<h2>GDPopt implementation and optional arguments<a class="headerlink" href="#gdpopt-implementation-and-optional-arguments" title="Permalink to this headline">Â¶</a></h2>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">GDPopt optional arguments should be considered beta code and are
subject to change.</p>
</div>
<dl class="py class">
<dt id="pyomo.contrib.gdpopt.GDPopt.GDPoptSolver">
<em class="property">class </em><code class="descclassname">pyomo.contrib.gdpopt.GDPopt.</code><code class="descname">GDPoptSolver</code><a class="reference internal" href="../_modules/pyomo/contrib/gdpopt/GDPopt.html#GDPoptSolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyomo.contrib.gdpopt.GDPopt.GDPoptSolver" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Decomposition solver for Generalized Disjunctive Programming (GDP)
problems.</p>
<p>The GDPopt (Generalized Disjunctive Programming optimizer) solver applies a
variety of decomposition-based approaches to solve Generalized Disjunctive
Programming (GDP) problems. GDP models can include nonlinear, continuous
variables and constraints, as well as logical conditions.</p>
<p>These approaches include:</p>
<ul class="simple">
<li>Logic-based outer approximation (LOA)</li>
<li>Logic-based branch-and-bound (LBB)</li>
<li>Partial surrogate cuts [pending]</li>
<li>Generalized Bender decomposition [pending]</li>
</ul>
<p>This solver implementation was developed by Carnegie Mellon University in
the research group of Ignacio Grossmann.</p>
<p>For nonconvex problems, LOA may not report rigorous lower/upper bounds.</p>
<p>Questions: Please make a post at StackOverflow and/or contact Qi Chen
&lt;<a class="reference external" href="https://github.com/qtothec">https://github.com/qtothec</a>&gt; or David Bernal &lt;<a class="reference external" href="https://github.com/bernalde">https://github.com/bernalde</a>&gt;.</p>
<p>Several key GDPopt components were prototyped by BS and MS students:</p>
<ul class="simple">
<li>Logic-based branch and bound: Sunjeev Kale</li>
<li>MC++ interface: Johnny Bates</li>
<li>LOA set-covering initialization: Eloy Fernandez</li>
<li>Logic-to-linear transformation: Romeo Valentin</li>
</ul>
<dl class="py method">
<dt id="pyomo.contrib.gdpopt.GDPopt.GDPoptSolver.available">
<code class="descname">available</code><span class="sig-paren">(</span><em><span class="n">exception_flag</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyomo/contrib/gdpopt/GDPopt.html#GDPoptSolver.available"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyomo.contrib.gdpopt.GDPopt.GDPoptSolver.available" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Solver is always available. Though subsolvers may not be, they will
raise an error when the time comes.</p>
</dd></dl>

<dl class="py method">
<dt id="pyomo.contrib.gdpopt.GDPopt.GDPoptSolver.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em><span class="n">model</span></em>, <em><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyomo/contrib/gdpopt/GDPopt.html#GDPoptSolver.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyomo.contrib.gdpopt.GDPopt.GDPoptSolver.solve" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Solve the model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> (<a class="reference internal" href="../library_reference/aml/index.html#pyomo.environ.Block" title="pyomo.environ.Block"><em>Block</em></a>) â a Pyomo model or block to be solved</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><ul class="first last simple">
<li><strong>iterlim</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.NonNegativeInt" title="pyomo.common.config.NonNegativeInt"><em>NonNegativeInt</em></a><em>, </em><em>optional</em>) â Iteration limit.</li>
<li><strong>time_limit</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.PositiveInt" title="pyomo.common.config.PositiveInt"><em>PositiveInt</em></a><em>, </em><em>optional</em>) â Seconds allowed until terminated. Note that the time limit can
currently only be enforced between subsolver invocations. You may need
to set subsolver time limits as well.</li>
<li><strong>tee</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=False</em>) â Stream output to terminal.</li>
<li><strong>logger</strong> (<em>a_logger</em><em>, </em><em>default='pyomo.contrib.gdpopt'</em>) â The logger object or name to use for reporting.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py method">
<dt id="pyomo.contrib.gdpopt.GDPopt.GDPoptSolver.version">
<code class="descname">version</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyomo/contrib/gdpopt/GDPopt.html#GDPoptSolver.version"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyomo.contrib.gdpopt.GDPopt.GDPoptSolver.version" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return a 3-tuple describing the solver version.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pyomo.contrib.gdpopt.loa.GDP_LOA_Solver">
<em class="property">class </em><code class="descclassname">pyomo.contrib.gdpopt.loa.</code><code class="descname">GDP_LOA_Solver</code><span class="sig-paren">(</span><em><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyomo/contrib/gdpopt/loa.html#GDP_LOA_Solver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyomo.contrib.gdpopt.loa.GDP_LOA_Solver" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The GDPopt (Generalized Disjunctive Programming optimizer) logic-based
outer approximation (LOA) solver.</p>
<p>Accepts models that can include nonlinear, continuous variables and
constraints, as well as logical conditions. For nonconvex problems, LOA
may not report rigorous dual bounds.</p>
<dl class="py method">
<dt id="pyomo.contrib.gdpopt.loa.GDP_LOA_Solver.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em><span class="n">model</span></em>, <em><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyomo/contrib/gdpopt/loa.html#GDP_LOA_Solver.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyomo.contrib.gdpopt.loa.GDP_LOA_Solver.solve" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Solve the model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> (<a class="reference internal" href="../library_reference/aml/index.html#pyomo.environ.Block" title="pyomo.environ.Block"><em>Block</em></a>) â the Pyomo model or block to be solved</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><ul class="first last simple">
<li><strong>iterlim</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.NonNegativeInt" title="pyomo.common.config.NonNegativeInt"><em>NonNegativeInt</em></a><em>, </em><em>optional</em>) â Iteration limit.</li>
<li><strong>time_limit</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.PositiveInt" title="pyomo.common.config.PositiveInt"><em>PositiveInt</em></a><em>, </em><em>optional</em>) â Seconds allowed until terminated. Note that the time limit can
currently only be enforced between subsolver invocations. You may need
to set subsolver time limits as well.</li>
<li><strong>tee</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=False</em>) â Stream output to terminal.</li>
<li><strong>logger</strong> (<em>a_logger</em><em>, </em><em>default=&lt;Logger pyomo.contrib.gdpopt</em><em> (</em><em>WARNING</em><em>)</em><em>&gt;</em>) â The logger object or name to use for reporting.</li>
<li><strong>integer_tolerance</strong> (<em>default=1e-05</em>) â Tolerance on integral values.</li>
<li><strong>constraint_tolerance</strong> (<em>default=1e-06</em>) â <p>Tolerance on constraint satisfaction.</p>
<p>Increasing this tolerance corresponds to being more conservative in
declaring the model or an NLP subproblem to be infeasible.</p>
</li>
<li><strong>variable_tolerance</strong> (<em>default=1e-08</em>) â Tolerance on variable bounds.</li>
<li><strong>subproblem_initialization_method</strong> (<em>default=&lt;function restore_vars_to_original_values at 0x7fc11ab4a7a0&gt;</em>) â <p>Callback to specify custom routines for initializing the (MI)NLP
subproblems. This method is called after the discrete problem solution
is fixed in the subproblem and before the subproblem is solved (or
pre-solved).</p>
<p>For algorithms with a discrete problem relaxation: This method accepts
three arguments: the solver object, the subproblem GDPopt utility
block and the discrete problem GDPopt utility block. The discrete
problem contains the most recent discrete problem solution.</p>
<p>For algorithms without a discrete problem relaxation: This method
accepts four arguments: the list of Disjuncts that are currently fixed
as being active, a list of values for the non-indicator BooleanVars
(empty if force_nlp_subproblem=False), and a list of values for the
integer vars (also empty if force_nlp_subproblem=False), and last the
subproblem GDPopt utility block.</p>
<p>The return of this method will be unused: The method should directly
set the value of the variables on the subproblem</p>
</li>
<li><strong>call_before_subproblem_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â <p>Callback called right before the (MI)NLP subproblem is solved. Takes
three arguments: The solver object, the subproblem and the GDPopt
utility block on the subproblem.</p>
<p>Note that unless you are <em>very</em> confident in what you are doing, the
subproblem should not be modified in this callback: it should be used
to interrogate the problem only.</p>
<p>To initialize the problem before it is solved, please specify a method
in the âsubproblem_initialization_methodâ argument.</p>
</li>
<li><strong>call_after_subproblem_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â <p>Callback called right after the (MI)NLP subproblem is solved. Takes
three arguments: The solver object, the subproblem, and the GDPopt
utility block on the subproblem.</p>
<p>Note that unless you are <em>very</em> confident in what you are doing, the
subproblem should not be modified in this callback: it should be used
to interrogate the problem only.</p>
</li>
<li><strong>call_after_subproblem_feasible</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â <p>Callback called right after the (MI)NLP subproblem is solved, if it
was feasible. Takes three arguments: The solver object, the subproblem
and the GDPopt utility block on the subproblem.</p>
<p>Note that unless you are <em>very</em> confident in what you are doing, the
subproblem should not be modified in this callback: it should be used
to interrogate the problem only.</p>
</li>
<li><strong>force_subproblem_nlp</strong> (<em>default=False</em>) â Force subproblems to be NLP, even if discrete variables exist.</li>
<li><strong>subproblem_presolve</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=True</em>) â Flag to enable or disable subproblem presolve. Default=True.</li>
<li><strong>tighten_nlp_var_bounds</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=False</em>) â Whether or not to do feasibility-based bounds tightening on the
variables in the NLP subproblem before solving it.</li>
<li><strong>round_discrete_vars</strong> (<em>default=True</em>) â Flag to round subproblem discrete variable values to the nearest
integer. Rounding is done before fixing disjuncts.</li>
<li><strong>max_fbbt_iterations</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.PositiveInt" title="pyomo.common.config.PositiveInt"><em>PositiveInt</em></a><em>, </em><em>default=3</em>) â Maximum number of feasibility-based bounds tightening iterations to do
during NLP subproblem preprocessing.</li>
<li><strong>init_strategy</strong> (<em>_init_strategy_deprecation</em><em>, </em><em>optional</em>) â DEPRECATED: Please use âinit_algorithmâ instead.</li>
<li><strong>init_algorithm</strong> (<em>In{'no_init': &lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em><em>, </em><em>'set_covering': &lt;function init_set_covering at 0x7fc11ab4a710&gt;</em><em>, </em><em>'max_binary': &lt;function init_max_binaries at 0x7fc11ab4a4d0&gt;</em><em>, </em><em>'fix_disjuncts': &lt;function init_fixed_disjuncts at 0x7fc11ab3a560&gt;</em><em>, </em><em>'custom_disjuncts': &lt;function init_custom_disjuncts at 0x7fc11ab3ab90&gt;}</em><em>, </em><em>default='set_covering'</em>) â Selects the initialization algorithm to use when generating the
initial cuts to construct the discrete problem.</li>
<li><strong>custom_init_disjuncts</strong> (<em>optional</em>) â List of disjunct sets to use for initialization.</li>
<li><strong>max_slack</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.NonNegativeFloat" title="pyomo.common.config.NonNegativeFloat"><em>NonNegativeFloat</em></a><em>, </em><em>default=1000</em>) â Upper bound on slack variables for OA</li>
<li><strong>OA_penalty_factor</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.NonNegativeFloat" title="pyomo.common.config.NonNegativeFloat"><em>NonNegativeFloat</em></a><em>, </em><em>default=1000</em>) â Penalty multiplication term for slack variables on the objective
value.</li>
<li><strong>set_cover_iterlim</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.NonNegativeInt" title="pyomo.common.config.NonNegativeInt"><em>NonNegativeInt</em></a><em>, </em><em>default=8</em>) â Limit on the number of set covering iterations.</li>
<li><strong>discrete_problem_transformation</strong> (<em>default='gdp.bigm'</em>) â Name of the transformation to use to transform the discrete problem
from a GDP to an algebraic model.</li>
<li><strong>call_before_discrete_problem_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â <p>Callback called right before the MILP discrete problem is solved.
Takes three arguments: The solver object, the discrete problem, and
the GDPopt utility block on the discrete problem.</p>
<p>Note that unless you are <em>very</em> confident in what you are doing, the
problem should not be modified in this callback: it should be used to
interrogate the problem only.</p>
</li>
<li><strong>call_after_discrete_problem_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â <p>Callback called right after the MILP discrete problem is solved. Takes
three arguments: The solver object, the discrete problem, and the
GDPopt utility block on the discrete problem.</p>
<p>Note that unless you are <em>very</em> confident in what you are doing, the
problem should not be modified in this callback: it should be used to
interrogate the problem only.</p>
</li>
<li><strong>call_before_master_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â DEPRECATED: Please use âcall_before_discrete_problem_solveâ</li>
<li><strong>call_after_master_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â DEPRECATED: Please use âcall_after_discrete_problem_solveâ</li>
<li><strong>mip_presolve</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=True</em>) â Flag to enable or disable GDPopt MIP presolve. Default=True.</li>
<li><strong>calc_disjunctive_bounds</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=False</em>) â Calculate special disjunctive variable bounds for GLOA. False by
default.</li>
<li><strong>obbt_disjunctive_bounds</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=False</em>) â Use optimality-based bounds tightening rather than feasibility-based
bounds tightening to compute disjunctive variable bounds. False by
default.</li>
<li><strong>mip_solver</strong> (<em>default='gurobi'</em>) â Mixed-integer linear solver to use. Note that no persisent solvers
other than the auto-persistent solvers in the APPSI package are
supported.</li>
<li><strong>mip_solver_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>, </em><em>optional</em>) â Keyword arguments to send to the MILP subsolver solve() invocation</li>
<li><strong>nlp_solver</strong> (<em>default='ipopt'</em>) â Nonlinear solver to use. Note that no persisent solvers other than the
auto-persistent solvers in the APPSI package are supported.</li>
<li><strong>nlp_solver_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>, </em><em>optional</em>) â Keyword arguments to send to the NLP subsolver solve() invocation</li>
<li><strong>minlp_solver</strong> (<em>default='baron'</em>) â Mixed-integer nonlinear solver to use. Note that no persisent solvers
other than the auto-persistent solvers in the APPSI package are
supported.</li>
<li><strong>minlp_solver_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>, </em><em>optional</em>) â Keyword arguments to send to the MINLP subsolver solve() invocation</li>
<li><strong>local_minlp_solver</strong> (<em>default='bonmin'</em>) â Mixed-integer nonlinear solver to use. Note that no persisent solvers
other than the auto-persistent solvers in the APPSI package are
supported.</li>
<li><strong>local_minlp_solver_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>, </em><em>optional</em>) â Keyword arguments to send to the local MINLP subsolver solve()
invocation</li>
<li><strong>small_dual_tolerance</strong> (<em>default=1e-08</em>) â When generating cuts, small duals multiplied by expressions can cause
problems. Exclude all duals smaller in absolute value than the
following.</li>
<li><strong>bound_tolerance</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.NonNegativeFloat" title="pyomo.common.config.NonNegativeFloat"><em>NonNegativeFloat</em></a><em>, </em><em>default=1e-06</em>) â Tolerance for bound convergence.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pyomo.contrib.gdpopt.gloa.GDP_GLOA_Solver">
<em class="property">class </em><code class="descclassname">pyomo.contrib.gdpopt.gloa.</code><code class="descname">GDP_GLOA_Solver</code><span class="sig-paren">(</span><em><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyomo/contrib/gdpopt/gloa.html#GDP_GLOA_Solver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyomo.contrib.gdpopt.gloa.GDP_GLOA_Solver" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The GDPopt (Generalized Disjunctive Programming optimizer) global
logic-based outer approximation (GLOA) solver.</p>
<p>Accepts models that can include nonlinear, continuous variables and
constraints, as well as logical conditions.</p>
<dl class="py method">
<dt id="pyomo.contrib.gdpopt.gloa.GDP_GLOA_Solver.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em><span class="n">model</span></em>, <em><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyomo/contrib/gdpopt/gloa.html#GDP_GLOA_Solver.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyomo.contrib.gdpopt.gloa.GDP_GLOA_Solver.solve" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Solve the model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> (<a class="reference internal" href="../library_reference/aml/index.html#pyomo.environ.Block" title="pyomo.environ.Block"><em>Block</em></a>) â the Pyomo model or block to be solved</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><ul class="first last simple">
<li><strong>iterlim</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.NonNegativeInt" title="pyomo.common.config.NonNegativeInt"><em>NonNegativeInt</em></a><em>, </em><em>optional</em>) â Iteration limit.</li>
<li><strong>time_limit</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.PositiveInt" title="pyomo.common.config.PositiveInt"><em>PositiveInt</em></a><em>, </em><em>optional</em>) â Seconds allowed until terminated. Note that the time limit can
currently only be enforced between subsolver invocations. You may need
to set subsolver time limits as well.</li>
<li><strong>tee</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=False</em>) â Stream output to terminal.</li>
<li><strong>logger</strong> (<em>a_logger</em><em>, </em><em>default=&lt;Logger pyomo.contrib.gdpopt</em><em> (</em><em>WARNING</em><em>)</em><em>&gt;</em>) â The logger object or name to use for reporting.</li>
<li><strong>integer_tolerance</strong> (<em>default=1e-05</em>) â Tolerance on integral values.</li>
<li><strong>constraint_tolerance</strong> (<em>default=1e-06</em>) â <p>Tolerance on constraint satisfaction.</p>
<p>Increasing this tolerance corresponds to being more conservative in
declaring the model or an NLP subproblem to be infeasible.</p>
</li>
<li><strong>variable_tolerance</strong> (<em>default=1e-08</em>) â Tolerance on variable bounds.</li>
<li><strong>subproblem_initialization_method</strong> (<em>default=&lt;function restore_vars_to_original_values at 0x7fc11ab4a7a0&gt;</em>) â <p>Callback to specify custom routines for initializing the (MI)NLP
subproblems. This method is called after the discrete problem solution
is fixed in the subproblem and before the subproblem is solved (or
pre-solved).</p>
<p>For algorithms with a discrete problem relaxation: This method accepts
three arguments: the solver object, the subproblem GDPopt utility
block and the discrete problem GDPopt utility block. The discrete
problem contains the most recent discrete problem solution.</p>
<p>For algorithms without a discrete problem relaxation: This method
accepts four arguments: the list of Disjuncts that are currently fixed
as being active, a list of values for the non-indicator BooleanVars
(empty if force_nlp_subproblem=False), and a list of values for the
integer vars (also empty if force_nlp_subproblem=False), and last the
subproblem GDPopt utility block.</p>
<p>The return of this method will be unused: The method should directly
set the value of the variables on the subproblem</p>
</li>
<li><strong>call_before_subproblem_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â <p>Callback called right before the (MI)NLP subproblem is solved. Takes
three arguments: The solver object, the subproblem and the GDPopt
utility block on the subproblem.</p>
<p>Note that unless you are <em>very</em> confident in what you are doing, the
subproblem should not be modified in this callback: it should be used
to interrogate the problem only.</p>
<p>To initialize the problem before it is solved, please specify a method
in the âsubproblem_initialization_methodâ argument.</p>
</li>
<li><strong>call_after_subproblem_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â <p>Callback called right after the (MI)NLP subproblem is solved. Takes
three arguments: The solver object, the subproblem, and the GDPopt
utility block on the subproblem.</p>
<p>Note that unless you are <em>very</em> confident in what you are doing, the
subproblem should not be modified in this callback: it should be used
to interrogate the problem only.</p>
</li>
<li><strong>call_after_subproblem_feasible</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â <p>Callback called right after the (MI)NLP subproblem is solved, if it
was feasible. Takes three arguments: The solver object, the subproblem
and the GDPopt utility block on the subproblem.</p>
<p>Note that unless you are <em>very</em> confident in what you are doing, the
subproblem should not be modified in this callback: it should be used
to interrogate the problem only.</p>
</li>
<li><strong>force_subproblem_nlp</strong> (<em>default=False</em>) â Force subproblems to be NLP, even if discrete variables exist.</li>
<li><strong>subproblem_presolve</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=True</em>) â Flag to enable or disable subproblem presolve. Default=True.</li>
<li><strong>tighten_nlp_var_bounds</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=False</em>) â Whether or not to do feasibility-based bounds tightening on the
variables in the NLP subproblem before solving it.</li>
<li><strong>round_discrete_vars</strong> (<em>default=True</em>) â Flag to round subproblem discrete variable values to the nearest
integer. Rounding is done before fixing disjuncts.</li>
<li><strong>max_fbbt_iterations</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.PositiveInt" title="pyomo.common.config.PositiveInt"><em>PositiveInt</em></a><em>, </em><em>default=3</em>) â Maximum number of feasibility-based bounds tightening iterations to do
during NLP subproblem preprocessing.</li>
<li><strong>init_strategy</strong> (<em>_init_strategy_deprecation</em><em>, </em><em>optional</em>) â DEPRECATED: Please use âinit_algorithmâ instead.</li>
<li><strong>init_algorithm</strong> (<em>In{'no_init': &lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em><em>, </em><em>'set_covering': &lt;function init_set_covering at 0x7fc11ab4a710&gt;</em><em>, </em><em>'max_binary': &lt;function init_max_binaries at 0x7fc11ab4a4d0&gt;</em><em>, </em><em>'fix_disjuncts': &lt;function init_fixed_disjuncts at 0x7fc11ab3a560&gt;</em><em>, </em><em>'custom_disjuncts': &lt;function init_custom_disjuncts at 0x7fc11ab3ab90&gt;}</em><em>, </em><em>default='set_covering'</em>) â Selects the initialization algorithm to use when generating the
initial cuts to construct the discrete problem.</li>
<li><strong>custom_init_disjuncts</strong> (<em>optional</em>) â List of disjunct sets to use for initialization.</li>
<li><strong>max_slack</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.NonNegativeFloat" title="pyomo.common.config.NonNegativeFloat"><em>NonNegativeFloat</em></a><em>, </em><em>default=1000</em>) â Upper bound on slack variables for OA</li>
<li><strong>OA_penalty_factor</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.NonNegativeFloat" title="pyomo.common.config.NonNegativeFloat"><em>NonNegativeFloat</em></a><em>, </em><em>default=1000</em>) â Penalty multiplication term for slack variables on the objective
value.</li>
<li><strong>set_cover_iterlim</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.NonNegativeInt" title="pyomo.common.config.NonNegativeInt"><em>NonNegativeInt</em></a><em>, </em><em>default=8</em>) â Limit on the number of set covering iterations.</li>
<li><strong>discrete_problem_transformation</strong> (<em>default='gdp.bigm'</em>) â Name of the transformation to use to transform the discrete problem
from a GDP to an algebraic model.</li>
<li><strong>call_before_discrete_problem_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â <p>Callback called right before the MILP discrete problem is solved.
Takes three arguments: The solver object, the discrete problem, and
the GDPopt utility block on the discrete problem.</p>
<p>Note that unless you are <em>very</em> confident in what you are doing, the
problem should not be modified in this callback: it should be used to
interrogate the problem only.</p>
</li>
<li><strong>call_after_discrete_problem_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â <p>Callback called right after the MILP discrete problem is solved. Takes
three arguments: The solver object, the discrete problem, and the
GDPopt utility block on the discrete problem.</p>
<p>Note that unless you are <em>very</em> confident in what you are doing, the
problem should not be modified in this callback: it should be used to
interrogate the problem only.</p>
</li>
<li><strong>call_before_master_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â DEPRECATED: Please use âcall_before_discrete_problem_solveâ</li>
<li><strong>call_after_master_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â DEPRECATED: Please use âcall_after_discrete_problem_solveâ</li>
<li><strong>mip_presolve</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=True</em>) â Flag to enable or disable GDPopt MIP presolve. Default=True.</li>
<li><strong>calc_disjunctive_bounds</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=False</em>) â Calculate special disjunctive variable bounds for GLOA. False by
default.</li>
<li><strong>obbt_disjunctive_bounds</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=False</em>) â Use optimality-based bounds tightening rather than feasibility-based
bounds tightening to compute disjunctive variable bounds. False by
default.</li>
<li><strong>mip_solver</strong> (<em>default='gurobi'</em>) â Mixed-integer linear solver to use. Note that no persisent solvers
other than the auto-persistent solvers in the APPSI package are
supported.</li>
<li><strong>mip_solver_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>, </em><em>optional</em>) â Keyword arguments to send to the MILP subsolver solve() invocation</li>
<li><strong>nlp_solver</strong> (<em>default='couenne'</em>) â Nonlinear solver to use. Note that no persisent solvers other than the
auto-persistent solvers in the APPSI package are supported.</li>
<li><strong>nlp_solver_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>, </em><em>optional</em>) â Keyword arguments to send to the NLP subsolver solve() invocation</li>
<li><strong>minlp_solver</strong> (<em>default='baron'</em>) â Mixed-integer nonlinear solver to use. Note that no persisent solvers
other than the auto-persistent solvers in the APPSI package are
supported.</li>
<li><strong>minlp_solver_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>, </em><em>optional</em>) â Keyword arguments to send to the MINLP subsolver solve() invocation</li>
<li><strong>local_minlp_solver</strong> (<em>default='bonmin'</em>) â Mixed-integer nonlinear solver to use. Note that no persisent solvers
other than the auto-persistent solvers in the APPSI package are
supported.</li>
<li><strong>local_minlp_solver_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>, </em><em>optional</em>) â Keyword arguments to send to the local MINLP subsolver solve()
invocation</li>
<li><strong>small_dual_tolerance</strong> (<em>default=1e-08</em>) â When generating cuts, small duals multiplied by expressions can cause
problems. Exclude all duals smaller in absolute value than the
following.</li>
<li><strong>bound_tolerance</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.NonNegativeFloat" title="pyomo.common.config.NonNegativeFloat"><em>NonNegativeFloat</em></a><em>, </em><em>default=1e-06</em>) â Tolerance for bound convergence.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pyomo.contrib.gdpopt.ric.GDP_RIC_Solver">
<em class="property">class </em><code class="descclassname">pyomo.contrib.gdpopt.ric.</code><code class="descname">GDP_RIC_Solver</code><span class="sig-paren">(</span><em><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyomo/contrib/gdpopt/ric.html#GDP_RIC_Solver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyomo.contrib.gdpopt.ric.GDP_RIC_Solver" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The GDPopt (Generalized Disjunctive Programming optimizer) relaxation
with integer cuts (RIC) solver.</p>
<p>Accepts models that can include nonlinear, continuous variables and
constraints, as well as logical conditions. For non-convex problems, RIC
will not be exact unless the NLP subproblems are solved globally.</p>
<dl class="py method">
<dt id="pyomo.contrib.gdpopt.ric.GDP_RIC_Solver.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em><span class="n">model</span></em>, <em><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyomo/contrib/gdpopt/ric.html#GDP_RIC_Solver.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyomo.contrib.gdpopt.ric.GDP_RIC_Solver.solve" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Solve the model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> (<a class="reference internal" href="../library_reference/aml/index.html#pyomo.environ.Block" title="pyomo.environ.Block"><em>Block</em></a>) â the Pyomo model or block to be solved</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><ul class="first last simple">
<li><strong>iterlim</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.NonNegativeInt" title="pyomo.common.config.NonNegativeInt"><em>NonNegativeInt</em></a><em>, </em><em>optional</em>) â Iteration limit.</li>
<li><strong>time_limit</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.PositiveInt" title="pyomo.common.config.PositiveInt"><em>PositiveInt</em></a><em>, </em><em>optional</em>) â Seconds allowed until terminated. Note that the time limit can
currently only be enforced between subsolver invocations. You may need
to set subsolver time limits as well.</li>
<li><strong>tee</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=False</em>) â Stream output to terminal.</li>
<li><strong>logger</strong> (<em>a_logger</em><em>, </em><em>default=&lt;Logger pyomo.contrib.gdpopt</em><em> (</em><em>WARNING</em><em>)</em><em>&gt;</em>) â The logger object or name to use for reporting.</li>
<li><strong>mip_solver</strong> (<em>default='gurobi'</em>) â Mixed-integer linear solver to use. Note that no persisent solvers
other than the auto-persistent solvers in the APPSI package are
supported.</li>
<li><strong>mip_solver_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>, </em><em>optional</em>) â Keyword arguments to send to the MILP subsolver solve() invocation</li>
<li><strong>nlp_solver</strong> (<em>default='ipopt'</em>) â Nonlinear solver to use. Note that no persisent solvers other than the
auto-persistent solvers in the APPSI package are supported.</li>
<li><strong>nlp_solver_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>, </em><em>optional</em>) â Keyword arguments to send to the NLP subsolver solve() invocation</li>
<li><strong>minlp_solver</strong> (<em>default='baron'</em>) â Mixed-integer nonlinear solver to use. Note that no persisent solvers
other than the auto-persistent solvers in the APPSI package are
supported.</li>
<li><strong>minlp_solver_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>, </em><em>optional</em>) â Keyword arguments to send to the MINLP subsolver solve() invocation</li>
<li><strong>local_minlp_solver</strong> (<em>default='bonmin'</em>) â Mixed-integer nonlinear solver to use. Note that no persisent solvers
other than the auto-persistent solvers in the APPSI package are
supported.</li>
<li><strong>local_minlp_solver_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>, </em><em>optional</em>) â Keyword arguments to send to the local MINLP subsolver solve()
invocation</li>
<li><strong>small_dual_tolerance</strong> (<em>default=1e-08</em>) â When generating cuts, small duals multiplied by expressions can cause
problems. Exclude all duals smaller in absolute value than the
following.</li>
<li><strong>bound_tolerance</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.NonNegativeFloat" title="pyomo.common.config.NonNegativeFloat"><em>NonNegativeFloat</em></a><em>, </em><em>default=1e-06</em>) â Tolerance for bound convergence.</li>
<li><strong>integer_tolerance</strong> (<em>default=1e-05</em>) â Tolerance on integral values.</li>
<li><strong>constraint_tolerance</strong> (<em>default=1e-06</em>) â <p>Tolerance on constraint satisfaction.</p>
<p>Increasing this tolerance corresponds to being more conservative in
declaring the model or an NLP subproblem to be infeasible.</p>
</li>
<li><strong>variable_tolerance</strong> (<em>default=1e-08</em>) â Tolerance on variable bounds.</li>
<li><strong>subproblem_initialization_method</strong> (<em>default=&lt;function restore_vars_to_original_values at 0x7fc11ab4a7a0&gt;</em>) â <p>Callback to specify custom routines for initializing the (MI)NLP
subproblems. This method is called after the discrete problem solution
is fixed in the subproblem and before the subproblem is solved (or
pre-solved).</p>
<p>For algorithms with a discrete problem relaxation: This method accepts
three arguments: the solver object, the subproblem GDPopt utility
block and the discrete problem GDPopt utility block. The discrete
problem contains the most recent discrete problem solution.</p>
<p>For algorithms without a discrete problem relaxation: This method
accepts four arguments: the list of Disjuncts that are currently fixed
as being active, a list of values for the non-indicator BooleanVars
(empty if force_nlp_subproblem=False), and a list of values for the
integer vars (also empty if force_nlp_subproblem=False), and last the
subproblem GDPopt utility block.</p>
<p>The return of this method will be unused: The method should directly
set the value of the variables on the subproblem</p>
</li>
<li><strong>call_before_subproblem_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â <p>Callback called right before the (MI)NLP subproblem is solved. Takes
three arguments: The solver object, the subproblem and the GDPopt
utility block on the subproblem.</p>
<p>Note that unless you are <em>very</em> confident in what you are doing, the
subproblem should not be modified in this callback: it should be used
to interrogate the problem only.</p>
<p>To initialize the problem before it is solved, please specify a method
in the âsubproblem_initialization_methodâ argument.</p>
</li>
<li><strong>call_after_subproblem_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â <p>Callback called right after the (MI)NLP subproblem is solved. Takes
three arguments: The solver object, the subproblem, and the GDPopt
utility block on the subproblem.</p>
<p>Note that unless you are <em>very</em> confident in what you are doing, the
subproblem should not be modified in this callback: it should be used
to interrogate the problem only.</p>
</li>
<li><strong>call_after_subproblem_feasible</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â <p>Callback called right after the (MI)NLP subproblem is solved, if it
was feasible. Takes three arguments: The solver object, the subproblem
and the GDPopt utility block on the subproblem.</p>
<p>Note that unless you are <em>very</em> confident in what you are doing, the
subproblem should not be modified in this callback: it should be used
to interrogate the problem only.</p>
</li>
<li><strong>force_subproblem_nlp</strong> (<em>default=False</em>) â Force subproblems to be NLP, even if discrete variables exist.</li>
<li><strong>subproblem_presolve</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=True</em>) â Flag to enable or disable subproblem presolve. Default=True.</li>
<li><strong>tighten_nlp_var_bounds</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=False</em>) â Whether or not to do feasibility-based bounds tightening on the
variables in the NLP subproblem before solving it.</li>
<li><strong>round_discrete_vars</strong> (<em>default=True</em>) â Flag to round subproblem discrete variable values to the nearest
integer. Rounding is done before fixing disjuncts.</li>
<li><strong>max_fbbt_iterations</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.PositiveInt" title="pyomo.common.config.PositiveInt"><em>PositiveInt</em></a><em>, </em><em>default=3</em>) â Maximum number of feasibility-based bounds tightening iterations to do
during NLP subproblem preprocessing.</li>
<li><strong>init_strategy</strong> (<em>_init_strategy_deprecation</em><em>, </em><em>optional</em>) â DEPRECATED: Please use âinit_algorithmâ instead.</li>
<li><strong>init_algorithm</strong> (<em>In{'no_init': &lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em><em>, </em><em>'set_covering': &lt;function init_set_covering at 0x7fc11ab4a710&gt;</em><em>, </em><em>'max_binary': &lt;function init_max_binaries at 0x7fc11ab4a4d0&gt;</em><em>, </em><em>'fix_disjuncts': &lt;function init_fixed_disjuncts at 0x7fc11ab3a560&gt;</em><em>, </em><em>'custom_disjuncts': &lt;function init_custom_disjuncts at 0x7fc11ab3ab90&gt;}</em><em>, </em><em>default='set_covering'</em>) â Selects the initialization algorithm to use when generating the
initial cuts to construct the discrete problem.</li>
<li><strong>custom_init_disjuncts</strong> (<em>optional</em>) â List of disjunct sets to use for initialization.</li>
<li><strong>max_slack</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.NonNegativeFloat" title="pyomo.common.config.NonNegativeFloat"><em>NonNegativeFloat</em></a><em>, </em><em>default=1000</em>) â Upper bound on slack variables for OA</li>
<li><strong>OA_penalty_factor</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.NonNegativeFloat" title="pyomo.common.config.NonNegativeFloat"><em>NonNegativeFloat</em></a><em>, </em><em>default=1000</em>) â Penalty multiplication term for slack variables on the objective
value.</li>
<li><strong>set_cover_iterlim</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.NonNegativeInt" title="pyomo.common.config.NonNegativeInt"><em>NonNegativeInt</em></a><em>, </em><em>default=8</em>) â Limit on the number of set covering iterations.</li>
<li><strong>discrete_problem_transformation</strong> (<em>default='gdp.bigm'</em>) â Name of the transformation to use to transform the discrete problem
from a GDP to an algebraic model.</li>
<li><strong>call_before_discrete_problem_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â <p>Callback called right before the MILP discrete problem is solved.
Takes three arguments: The solver object, the discrete problem, and
the GDPopt utility block on the discrete problem.</p>
<p>Note that unless you are <em>very</em> confident in what you are doing, the
problem should not be modified in this callback: it should be used to
interrogate the problem only.</p>
</li>
<li><strong>call_after_discrete_problem_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â <p>Callback called right after the MILP discrete problem is solved. Takes
three arguments: The solver object, the discrete problem, and the
GDPopt utility block on the discrete problem.</p>
<p>Note that unless you are <em>very</em> confident in what you are doing, the
problem should not be modified in this callback: it should be used to
interrogate the problem only.</p>
</li>
<li><strong>call_before_master_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â DEPRECATED: Please use âcall_before_discrete_problem_solveâ</li>
<li><strong>call_after_master_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â DEPRECATED: Please use âcall_after_discrete_problem_solveâ</li>
<li><strong>mip_presolve</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=True</em>) â Flag to enable or disable GDPopt MIP presolve. Default=True.</li>
<li><strong>calc_disjunctive_bounds</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=False</em>) â Calculate special disjunctive variable bounds for GLOA. False by
default.</li>
<li><strong>obbt_disjunctive_bounds</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=False</em>) â Use optimality-based bounds tightening rather than feasibility-based
bounds tightening to compute disjunctive variable bounds. False by
default.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pyomo.contrib.gdpopt.branch_and_bound.GDP_LBB_Solver">
<em class="property">class </em><code class="descclassname">pyomo.contrib.gdpopt.branch_and_bound.</code><code class="descname">GDP_LBB_Solver</code><span class="sig-paren">(</span><em><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyomo/contrib/gdpopt/branch_and_bound.html#GDP_LBB_Solver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyomo.contrib.gdpopt.branch_and_bound.GDP_LBB_Solver" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The GDPopt (Generalized Disjunctive Programming optimizer) logic-based
branch and bound (LBB) solver.</p>
<p>Accepts models that can include nonlinear, continuous variables and
constraints, as well as logical conditions.</p>
<dl class="py method">
<dt id="pyomo.contrib.gdpopt.branch_and_bound.GDP_LBB_Solver.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em><span class="n">model</span></em>, <em><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyomo/contrib/gdpopt/branch_and_bound.html#GDP_LBB_Solver.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyomo.contrib.gdpopt.branch_and_bound.GDP_LBB_Solver.solve" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Solve the model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> (<a class="reference internal" href="../library_reference/aml/index.html#pyomo.environ.Block" title="pyomo.environ.Block"><em>Block</em></a>) â the Pyomo model or block to be solved</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><ul class="first last simple">
<li><strong>iterlim</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.NonNegativeInt" title="pyomo.common.config.NonNegativeInt"><em>NonNegativeInt</em></a><em>, </em><em>optional</em>) â Iteration limit.</li>
<li><strong>time_limit</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.PositiveInt" title="pyomo.common.config.PositiveInt"><em>PositiveInt</em></a><em>, </em><em>optional</em>) â Seconds allowed until terminated. Note that the time limit can
currently only be enforced between subsolver invocations. You may need
to set subsolver time limits as well.</li>
<li><strong>tee</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=False</em>) â Stream output to terminal.</li>
<li><strong>logger</strong> (<em>a_logger</em><em>, </em><em>default=&lt;Logger pyomo.contrib.gdpopt</em><em> (</em><em>WARNING</em><em>)</em><em>&gt;</em>) â The logger object or name to use for reporting.</li>
<li><strong>mip_solver</strong> (<em>default='gurobi'</em>) â Mixed-integer linear solver to use. Note that no persisent solvers
other than the auto-persistent solvers in the APPSI package are
supported.</li>
<li><strong>mip_solver_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>, </em><em>optional</em>) â Keyword arguments to send to the MILP subsolver solve() invocation</li>
<li><strong>nlp_solver</strong> (<em>default='ipopt'</em>) â Nonlinear solver to use. Note that no persisent solvers other than the
auto-persistent solvers in the APPSI package are supported.</li>
<li><strong>nlp_solver_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>, </em><em>optional</em>) â Keyword arguments to send to the NLP subsolver solve() invocation</li>
<li><strong>minlp_solver</strong> (<em>default='baron'</em>) â Mixed-integer nonlinear solver to use. Note that no persisent solvers
other than the auto-persistent solvers in the APPSI package are
supported.</li>
<li><strong>minlp_solver_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>, </em><em>optional</em>) â Keyword arguments to send to the MINLP subsolver solve() invocation</li>
<li><strong>local_minlp_solver</strong> (<em>default='bonmin'</em>) â Mixed-integer nonlinear solver to use. Note that no persisent solvers
other than the auto-persistent solvers in the APPSI package are
supported.</li>
<li><strong>local_minlp_solver_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>, </em><em>optional</em>) â Keyword arguments to send to the local MINLP subsolver solve()
invocation</li>
<li><strong>small_dual_tolerance</strong> (<em>default=1e-08</em>) â When generating cuts, small duals multiplied by expressions can cause
problems. Exclude all duals smaller in absolute value than the
following.</li>
<li><strong>integer_tolerance</strong> (<em>default=1e-05</em>) â Tolerance on integral values.</li>
<li><strong>constraint_tolerance</strong> (<em>default=1e-06</em>) â <p>Tolerance on constraint satisfaction.</p>
<p>Increasing this tolerance corresponds to being more conservative in
declaring the model or an NLP subproblem to be infeasible.</p>
</li>
<li><strong>variable_tolerance</strong> (<em>default=1e-08</em>) â Tolerance on variable bounds.</li>
<li><strong>subproblem_initialization_method</strong> (<em>default=&lt;function restore_vars_to_original_values at 0x7fc11ab4a7a0&gt;</em>) â <p>Callback to specify custom routines for initializing the (MI)NLP
subproblems. This method is called after the discrete problem solution
is fixed in the subproblem and before the subproblem is solved (or
pre-solved).</p>
<p>For algorithms with a discrete problem relaxation: This method accepts
three arguments: the solver object, the subproblem GDPopt utility
block and the discrete problem GDPopt utility block. The discrete
problem contains the most recent discrete problem solution.</p>
<p>For algorithms without a discrete problem relaxation: This method
accepts four arguments: the list of Disjuncts that are currently fixed
as being active, a list of values for the non-indicator BooleanVars
(empty if force_nlp_subproblem=False), and a list of values for the
integer vars (also empty if force_nlp_subproblem=False), and last the
subproblem GDPopt utility block.</p>
<p>The return of this method will be unused: The method should directly
set the value of the variables on the subproblem</p>
</li>
<li><strong>call_before_subproblem_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â <p>Callback called right before the (MI)NLP subproblem is solved. Takes
three arguments: The solver object, the subproblem and the GDPopt
utility block on the subproblem.</p>
<p>Note that unless you are <em>very</em> confident in what you are doing, the
subproblem should not be modified in this callback: it should be used
to interrogate the problem only.</p>
<p>To initialize the problem before it is solved, please specify a method
in the âsubproblem_initialization_methodâ argument.</p>
</li>
<li><strong>call_after_subproblem_solve</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â <p>Callback called right after the (MI)NLP subproblem is solved. Takes
three arguments: The solver object, the subproblem, and the GDPopt
utility block on the subproblem.</p>
<p>Note that unless you are <em>very</em> confident in what you are doing, the
subproblem should not be modified in this callback: it should be used
to interrogate the problem only.</p>
</li>
<li><strong>call_after_subproblem_feasible</strong> (<em>default=&lt;class 'pyomo.contrib.gdpopt.util._DoNothing'&gt;</em>) â <p>Callback called right after the (MI)NLP subproblem is solved, if it
was feasible. Takes three arguments: The solver object, the subproblem
and the GDPopt utility block on the subproblem.</p>
<p>Note that unless you are <em>very</em> confident in what you are doing, the
subproblem should not be modified in this callback: it should be used
to interrogate the problem only.</p>
</li>
<li><strong>force_subproblem_nlp</strong> (<em>default=False</em>) â Force subproblems to be NLP, even if discrete variables exist.</li>
<li><strong>subproblem_presolve</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=True</em>) â Flag to enable or disable subproblem presolve. Default=True.</li>
<li><strong>tighten_nlp_var_bounds</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=False</em>) â Whether or not to do feasibility-based bounds tightening on the
variables in the NLP subproblem before solving it.</li>
<li><strong>round_discrete_vars</strong> (<em>default=True</em>) â Flag to round subproblem discrete variable values to the nearest
integer. Rounding is done before fixing disjuncts.</li>
<li><strong>max_fbbt_iterations</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.PositiveInt" title="pyomo.common.config.PositiveInt"><em>PositiveInt</em></a><em>, </em><em>default=3</em>) â Maximum number of feasibility-based bounds tightening iterations to do
during NLP subproblem preprocessing.</li>
<li><strong>bound_tolerance</strong> (<a class="reference internal" href="../library_reference/common/config.html#pyomo.common.config.NonNegativeFloat" title="pyomo.common.config.NonNegativeFloat"><em>NonNegativeFloat</em></a><em>, </em><em>default=1e-06</em>) â Tolerance for bound convergence.</li>
<li><strong>check_sat</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=False</em>) â When True, GDPopt-LBB will check satisfiability at each node via the
pyomo.contrib.satsolver interface</li>
<li><strong>solve_local_rnGDP</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>default=False</em>) â When True, GDPopt-LBB will solve a local MINLP at each node.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="iis.html" class="btn btn-neutral float-right" title="Infeasible Irreducible System (IIS) Tool" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="doe/doe.html" class="btn btn-neutral float-left" title="Pyomo.DoE" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2008-2023, Sandia National Laboratories.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>