

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>pyomo.core.base.indexed_component &mdash; Pyomo 6.5.1.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/theme_overrides.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/clipboard.min.js"></script>
        <script src="../../../../_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> Pyomo
          

          
          </a>

          
            
            
              <div class="version">
                6.5.1.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../citing_pyomo.html">Citing Pyomo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pyomo_overview/index.html">Pyomo Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pyomo_modeling_components/index.html">Pyomo Modeling Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../solving_pyomo_models.html">Solving Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_models.html">Working with Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_abstractmodels/index.html">Working with Abstract Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_transformations/index.html">Model Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modeling_extensions/index.html">Modeling Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial_examples.html">Pyomo Tutorial Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_debugging/index.html">Debugging Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../advanced_topics/index.html">Advanced Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../errors.html">Common Warnings/Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_reference/index.html">Developer Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../library_reference/index.html">Library Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contribution_guide.html">Contributing to Pyomo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributed_packages/index.html">Third-Party Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../related_packages.html">Related Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Pyomo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>pyomo.core.base.indexed_component</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyomo.core.base.indexed_component</h1><div class="highlight"><pre>
<span></span><span class="c1">#  ___________________________________________________________________________</span>
<span class="c1">#</span>
<span class="c1">#  Pyomo: Python Optimization Modeling Objects</span>
<span class="c1">#  Copyright (c) 2008-2022</span>
<span class="c1">#  National Technology and Engineering Solutions of Sandia, LLC</span>
<span class="c1">#  Under the terms of Contract DE-NA0003525 with National Technology and</span>
<span class="c1">#  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain</span>
<span class="c1">#  rights in this software.</span>
<span class="c1">#  This software is distributed under the 3-clause BSD License.</span>
<span class="c1">#  ___________________________________________________________________________</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;IndexedComponent&#39;</span><span class="p">,</span> <span class="s1">&#39;ActiveIndexedComponent&#39;</span><span class="p">]</span>

<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">textwrap</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="kn">from</span> <span class="nn">pyomo.core.expr</span> <span class="kn">import</span> <span class="n">current</span> <span class="k">as</span> <span class="n">EXPR</span>
<span class="kn">from</span> <span class="nn">pyomo.core.expr.expr_errors</span> <span class="kn">import</span> <span class="n">TemplateExpressionError</span>
<span class="kn">from</span> <span class="nn">pyomo.core.expr.numvalue</span> <span class="kn">import</span> <span class="n">native_types</span><span class="p">,</span> <span class="n">NumericNDArray</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.indexed_component_slice</span> <span class="kn">import</span> <span class="n">IndexedComponent_slice</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.initializer</span> <span class="kn">import</span> <span class="n">Initializer</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.component</span> <span class="kn">import</span> <span class="n">Component</span><span class="p">,</span> <span class="n">ActiveComponent</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.config</span> <span class="kn">import</span> <span class="n">PyomoOptions</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.global_set</span> <span class="kn">import</span> <span class="n">UnindexedComponent_set</span>
<span class="kn">from</span> <span class="nn">pyomo.common</span> <span class="kn">import</span> <span class="n">DeveloperError</span>
<span class="kn">from</span> <span class="nn">pyomo.common.autoslots</span> <span class="kn">import</span> <span class="n">fast_deepcopy</span>
<span class="kn">from</span> <span class="nn">pyomo.common.dependencies</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span><span class="p">,</span> <span class="n">numpy_available</span>
<span class="kn">from</span> <span class="nn">pyomo.common.deprecation</span> <span class="kn">import</span> <span class="n">deprecated</span>
<span class="kn">from</span> <span class="nn">pyomo.common.modeling</span> <span class="kn">import</span> <span class="n">NOTSET</span>
<span class="kn">from</span> <span class="nn">pyomo.common.sorting</span> <span class="kn">import</span> <span class="n">sorted_robust</span>

<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;pyomo.core&#39;</span><span class="p">)</span>

<span class="n">sequence_types</span> <span class="o">=</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">normalize_index</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normalize a component index.</span>

<span class="sd">    This flattens nested sequences into a single tuple.  There is a</span>
<span class="sd">    &quot;global&quot; flag (normalize_index.flatten) that will turn off index</span>
<span class="sd">    flattening across Pyomo.</span>

<span class="sd">    Scalar values will be returned unchanged.  Tuples with a single</span>
<span class="sd">    value will be unpacked and returned as a single value.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scalar or tuple</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">in</span> <span class="n">native_types</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">in</span> <span class="n">sequence_types</span><span class="p">:</span>
        <span class="c1"># Note that casting a tuple to a tuple is cheap (no copy, no</span>
        <span class="c1"># new object)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span>

    <span class="n">x_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x_len</span><span class="p">:</span>
        <span class="n">_xi_class</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="k">if</span> <span class="n">_xi_class</span> <span class="ow">in</span> <span class="n">native_types</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">_xi_class</span> <span class="ow">in</span> <span class="n">sequence_types</span><span class="p">:</span>
            <span class="n">x_len</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># Note that casting a tuple to a tuple is cheap (no copy, no</span>
            <span class="c1"># new object)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">_xi_class</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">_xi_class</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># This is very difficult to get to: it would require a</span>
                <span class="c1"># user creating a custom derived string type</span>
                <span class="n">native_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_xi_class</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sequence_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_xi_class</span><span class="p">)</span>
                <span class="n">x_len</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">x_len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="c1"># Pyomo will normalize indices by default</span>
<span class="n">normalize_index</span><span class="o">.</span><span class="n">flatten</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">_NotFound</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">_NotSpecified</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="c1">#</span>
<span class="c1"># Get the fully-qualified name for this index.  If there isn&#39;t anything</span>
<span class="c1"># in the _data dict (and there shouldn&#39;t be), then add something, get</span>
<span class="c1"># the name, and remove it.  This allows us to get the name of something</span>
<span class="c1"># that we haven&#39;t added yet without changing the state of the constraint</span>
<span class="c1"># object.</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">_get_indexed_component_data_name</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the fully-qualified component name for an unconstructed index.</span>

<span class="sd">    The ComponentData.name property assumes that the ComponentData has</span>
<span class="sd">    already been assigned to the owning Component.  This is a problem</span>
<span class="sd">    during the process of constructing a ComponentData instance, as we</span>
<span class="sd">    may need to throw an exception before the ComponentData is added to</span>
<span class="sd">    the owning component.  In those cases, we can use this function to</span>
<span class="sd">    generate the fully-qualified name without (permanently) adding the</span>
<span class="sd">    object to the Component.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">component</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">component</span><span class="o">.</span><span class="n">name</span>
    <span class="k">elif</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">component</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">component</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">component</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">component</span><span class="o">.</span><span class="n">_ComponentDataClass</span><span class="p">(</span>
                    <span class="o">*</span><span class="p">((</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="n">i</span><span class="p">),</span> <span class="n">component</span><span class="o">=</span><span class="n">component</span>
                <span class="p">)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">break</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># None of the generic positional arguments worked; raise an</span>
            <span class="c1"># exception</span>
            <span class="n">component</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">component</span><span class="o">.</span><span class="n">_ComponentDataClass</span><span class="p">(</span><span class="n">component</span><span class="o">=</span><span class="n">component</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">component</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">component</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;[{unknown index}]&#39;</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">component</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ans</span>


<span class="n">_rule_returned_none_error</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2"> &#39;</span><span class="si">%s</span><span class="s2">&#39;: rule returned None.</span>

<span class="si">%s</span><span class="s2"> rules must return either a valid expression, numeric value, or</span>
<span class="si">%s</span><span class="s2">.Skip.  The most common cause of this error is forgetting to</span>
<span class="s2">include the &quot;return&quot; statement at the end of your rule.</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">rule_result_substituter</span><span class="p">(</span><span class="n">result_map</span><span class="p">):</span>
    <span class="n">_map</span> <span class="o">=</span> <span class="n">result_map</span>
    <span class="n">_map_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result_map</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rule_result_substituter_impl</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">rule</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">in</span> <span class="n">_map_types</span><span class="p">:</span>
            <span class="c1">#</span>
            <span class="c1"># The argument is a trivial type and will be mapped</span>
            <span class="c1">#</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">rule</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#</span>
            <span class="c1"># Otherwise, the argument is a functor, so call it to</span>
            <span class="c1"># generate the rule result.</span>
            <span class="c1">#</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">rule</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># Map the returned value:</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">in</span> <span class="n">_map_types</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">_map</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_map</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">return</span> <span class="n">rule_result_substituter_impl</span>


<span class="n">_map_rule_funcdef</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;def wrapper_function</span><span class="si">%s</span><span class="s2">:</span>
<span class="s2">    args, varargs, kwds, local_env = inspect.getargvalues(</span>
<span class="s2">        inspect.currentframe())</span>
<span class="s2">    args = tuple(local_env[_] for _ in args) + (varargs or ())</span>
<span class="s2">    return wrapping_fcn(rule, *args, **(kwds or </span><span class="si">{}</span><span class="s2">))</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">rule_wrapper</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">wrapping_fcn</span><span class="p">,</span> <span class="n">positional_arg_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrap a rule with another function</span>

<span class="sd">    This utility method provides a way to wrap a function (rule) with</span>
<span class="sd">    another function while preserving the original function signature.</span>
<span class="sd">    This is important for rules, as the :py:func:`Initializer`</span>
<span class="sd">    argument processor relies on knowing the number of positional</span>
<span class="sd">    arguments.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rule: function</span>
<span class="sd">        The original rule being wrapped</span>
<span class="sd">    wrapping_fcn: function or Dict</span>
<span class="sd">        The wrapping function.  The `wrapping_fcn` will be called with</span>
<span class="sd">        ``(rule, *args, **kwargs)``.  For convenience, if a `dict` is</span>
<span class="sd">        passed as the `wrapping_fcn`, then the result of</span>
<span class="sd">        :py:func:`rule_result_substituter(wrapping_fcn)` is used as the</span>
<span class="sd">        wrapping function.</span>
<span class="sd">    positional_arg_map: iterable[int]</span>
<span class="sd">        An iterable of indices of rule positional arguments to expose in</span>
<span class="sd">        the wrapped function signature.  For example,</span>
<span class="sd">        `positional_arg_map=(2, 0)` and `rule=fcn(a, b, c)` would produce a</span>
<span class="sd">        wrapped function with a signature `wrapper_function(c, a)`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wrapping_fcn</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">wrapping_fcn</span> <span class="o">=</span> <span class="n">rule_result_substituter</span><span class="p">(</span><span class="n">wrapping_fcn</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">rule</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">wrapping_fcn</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
    <span class="c1"># Because some of our processing of initializer functions relies on</span>
    <span class="c1"># knowing the number of positional arguments, we will go to extra</span>
    <span class="c1"># effort here to preserve the original function signature.</span>
    <span class="n">rule_sig</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">positional_arg_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">param</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rule_sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">rule_sig</span> <span class="o">=</span> <span class="n">rule_sig</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">positional_arg_map</span><span class="p">))</span>
    <span class="n">_funcdef</span> <span class="o">=</span> <span class="n">_map_rule_funcdef</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">rule_sig</span><span class="p">),)</span>
    <span class="c1"># Create the wrapper in a temporary environment that mimics this</span>
    <span class="c1"># function&#39;s environment.</span>
    <span class="n">_env</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">globals</span><span class="p">())</span>
    <span class="n">_env</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">locals</span><span class="p">())</span>
    <span class="n">exec</span><span class="p">(</span><span class="n">_funcdef</span><span class="p">,</span> <span class="n">_env</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_env</span><span class="p">[</span><span class="s1">&#39;wrapper_function&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">IndexedComponent</span><span class="p">(</span><span class="n">Component</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the base class for all indexed modeling components.</span>
<span class="sd">    This class stores a dictionary, self._data, that maps indices</span>
<span class="sd">    to component data objects.  The object self._index_set defines valid</span>
<span class="sd">    keys for this dictionary, and the dictionary keys may be a</span>
<span class="sd">    strict subset.</span>

<span class="sd">    The standard access and iteration methods iterate over the the</span>
<span class="sd">    keys of self._data.  This class supports a concept of a default</span>
<span class="sd">    component data value.  When enabled, the default does not</span>
<span class="sd">    change the access and iteration methods.</span>

<span class="sd">    IndexedComponent may be given a set over which indexing is restricted.</span>
<span class="sd">    Alternatively, IndexedComponent may be indexed over Any</span>
<span class="sd">    (pyomo.core.base.set_types.Any), in which case the IndexedComponent</span>
<span class="sd">    behaves like a dictionary - any hashable object can be used as a key</span>
<span class="sd">    and keys can be added on the fly.</span>

<span class="sd">    Constructor arguments:</span>
<span class="sd">        ctype       The class type for the derived subclass</span>
<span class="sd">        doc         A text string describing this component</span>

<span class="sd">    Private class attributes:</span>
<span class="sd">        _data               A dictionary from the index set to</span>
<span class="sd">                                component data objects</span>
<span class="sd">        _index_set              The set of valid indices</span>
<span class="sd">        _implicit_subsets   A temporary data element that stores</span>
<span class="sd">                                sets that are transferred to the model</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">Skip</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="c1">#</span>
    <span class="c1"># If an index is supplied for which there is not a _data entry</span>
    <span class="c1"># (specifically, in a get call), then this flag determines whether</span>
    <span class="c1"># a check is performed to see if the input index is in the</span>
    <span class="c1"># index set _index_set. This is extremely expensive, and so this flag</span>
    <span class="c1"># is provided to disable that feature globally.</span>
    <span class="c1">#</span>
    <span class="n">_DEFAULT_INDEX_CHECKING_ENABLED</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pyomo.core.base.set</span> <span class="kn">import</span> <span class="n">process_setarg</span>

        <span class="c1">#</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;noruleinit&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">Component</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">UnindexedComponent_set</span><span class="p">):</span>
            <span class="c1">#</span>
            <span class="c1"># If no indexing sets are provided, generate a dummy index</span>
            <span class="c1">#</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_subsets</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span> <span class="o">=</span> <span class="n">UnindexedComponent_set</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1">#</span>
            <span class="c1"># If a single indexing set is provided, just process it.</span>
            <span class="c1">#</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_subsets</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span> <span class="o">=</span> <span class="n">process_setarg</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#</span>
            <span class="c1"># If multiple indexing sets are provided, process them all,</span>
            <span class="c1"># and store the cross-product of these sets.  The individual</span>
            <span class="c1"># sets need to stored in the Pyomo model, so the</span>
            <span class="c1"># _implicit_subsets class data is used for this temporary</span>
            <span class="c1"># storage.</span>
            <span class="c1">#</span>
            <span class="c1"># Example:  Pyomo allows things like</span>
            <span class="c1"># &quot;Param([1,2,3], range(100), initialize=0)&quot;.  This</span>
            <span class="c1"># needs to create *3* sets: two SetOf components and then</span>
            <span class="c1"># the SetProduct.  That means that the component needs to</span>
            <span class="c1"># hold on to the implicit SetOf objects until the component</span>
            <span class="c1"># is assigned to a model (where the implicit subsets can be</span>
            <span class="c1"># &quot;transferred&quot; to the model).</span>
            <span class="c1">#</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">process_setarg</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_subsets</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="o">*</span><span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">_create_objects_for_deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">component_list</span><span class="p">):</span>
        <span class="n">_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">_ans</span> <span class="o">=</span> <span class="n">memo</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">_new</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_ans</span> <span class="ow">is</span> <span class="n">_new</span><span class="p">:</span>
            <span class="n">component_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="c1"># For indexed components, we will pre-emptively clone all</span>
            <span class="c1"># component data objects as well (as those are the objects</span>
            <span class="c1"># that will be referenced by things like expressions).  It</span>
            <span class="c1"># is important to only clone &quot;normal&quot; ComponentData obects:</span>
            <span class="c1"># so we will want to skip this for all scalar components</span>
            <span class="c1"># (where the _data points back to self) and references</span>
            <span class="c1"># (where the data may be stored outside this block tree and</span>
            <span class="c1"># therefore may not be cloned)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_reference</span><span class="p">():</span>
                <span class="c1"># Because we are already checking / updating the memo</span>
                <span class="c1"># for the _data dict, we can effectively &quot;deepcopy&quot; it</span>
                <span class="c1"># right now (almost for free!)</span>
                <span class="n">_src</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
                <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">_src</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_new</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">_data</span> <span class="o">=</span> <span class="n">_src</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">_src</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">_data</span><span class="p">[</span><span class="n">fast_deepcopy</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">memo</span><span class="p">)]</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_create_objects_for_deepcopy</span><span class="p">(</span>
                        <span class="n">memo</span><span class="p">,</span> <span class="n">component_list</span>
                    <span class="p">)</span>

        <span class="k">return</span> <span class="n">_ans</span>

    <span class="k">def</span> <span class="nf">to_dense_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;TODO&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_getitem_when_not_present</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># Rule could have returned Skip, which we will silently ignore</span>
                <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear the data in this component&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DeveloperError</span><span class="p">(</span>
                <span class="s2">&quot;Derived scalar component </span><span class="si">%s</span><span class="s2"> failed to define clear().&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">index_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the index set&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span>

    <span class="k">def</span> <span class="nf">is_indexed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if this component is indexed&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">UnindexedComponent_set</span>

    <span class="k">def</span> <span class="nf">is_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if this component is a reference, where</span>
<span class="sd">        &quot;reference&quot; is interpreted as any component that does not</span>
<span class="sd">        own its own data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span>

    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the dimension of the index&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span><span class="o">.</span><span class="n">dimen</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of component data objects stored by this</span>
<span class="sd">        component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if the index is in the dictionary&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

    <span class="c1"># The default implementation is for keys() and __iter__ to be</span>
    <span class="c1"># synonyms.  The logic is implemented in keys() so that</span>
    <span class="c1"># keys/values/items continue to work for components that implement</span>
    <span class="c1"># other definitions for __iter__ (e.g., Set)</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator of the component data keys&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator over the component data keys</span>

<span class="sd">        This method sets the ordering of component data objects within</span>
<span class="sd">        this IndexedComponent container.  For consistency,</span>
<span class="sd">        :py:meth:`__init__()`, :py:meth:`values`, and :py:meth:`items`</span>
<span class="sd">        all leverage this method to ensure consistent ordering.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ordered: bool</span>
<span class="sd">            If True, then the keys are returned in a deterministic</span>
<span class="sd">            order.  If the underlying indexing set is ordered then that</span>
<span class="sd">            ordering is used.  Otherwise, the keys are sorted using</span>
<span class="sd">            :py:func:`sorted_robust`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sort_needed</span> <span class="o">=</span> <span class="n">ordered</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span><span class="o">.</span><span class="n">isfinite</span><span class="p">():</span>
            <span class="c1">#</span>
            <span class="c1"># If the index set is virtual (e.g., Any) then return the</span>
            <span class="c1"># data iterator.  Note that since we cannot check the length</span>
            <span class="c1"># of the underlying Set, there should be no warning if the</span>
            <span class="c1"># user iterates over the set when the _data dict is empty.</span>
            <span class="c1">#</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_reference</span><span class="p">():</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span><span class="p">):</span>
            <span class="c1">#</span>
            <span class="c1"># If the data is dense then return the index iterator.</span>
            <span class="c1">#</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ordered</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span><span class="o">.</span><span class="n">isordered</span><span class="p">():</span>
                <span class="c1"># As this iterator is ordered, we do not need to sort it</span>
                <span class="n">sort_needed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span> <span class="ow">and</span> <span class="n">PyomoOptions</span><span class="o">.</span><span class="n">paranoia_level</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sd">&quot;&quot;&quot;Iterating over a Component (%s)</span>
<span class="sd">defined by a non-empty concrete set before any data objects have</span>
<span class="sd">actually been added to the Component.  The iterator will be empty.</span>
<span class="sd">This is usually caused by Concrete models where you declare the</span>
<span class="sd">component (e.g., a Var) and apply component-level operations (e.g.,</span>
<span class="sd">x.fix(0)) before you use the component members (in something like a</span>
<span class="sd">constraint).</span>

<span class="sd">You can silence this warning by one of three ways:</span>
<span class="sd">    1) Declare the component to be dense with the &#39;dense=True&#39; option.</span>
<span class="sd">       This will cause all data objects to be immediately created and</span>
<span class="sd">       added to the Component.</span>
<span class="sd">    2) Defer component-level iteration until after the component data</span>
<span class="sd">       members have been added (through explicit use).</span>
<span class="sd">    3) If you intend to iterate over a component that may be empty, test</span>
<span class="sd">       if the component is empty first and avoid iteration in the case</span>
<span class="sd">       where it is empty.</span>
<span class="sd">&quot;&quot;&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span><span class="o">.</span><span class="n">isordered</span><span class="p">():</span>
                <span class="c1">#</span>
                <span class="c1"># If the index set is not ordered, then return the</span>
                <span class="c1"># data iterator.  This is in an arbitrary order, which is</span>
                <span class="c1"># fine because the data is unordered.</span>
                <span class="c1">#</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#</span>
                <span class="c1"># Test each element of a sparse data with an ordered</span>
                <span class="c1"># index set in order.  This is potentially *slow*: if</span>
                <span class="c1"># the component is in fact very sparse, we could be</span>
                <span class="c1"># iterating over a huge (dense) index in order to sort a</span>
                <span class="c1"># small number of indices.  However, this provides a</span>
                <span class="c1"># consistent ordering that the user expects.</span>
                <span class="c1">#</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span><span class="p">)</span>
                <span class="c1"># As the iterator is ordered, we do not need to sort it</span>
                <span class="n">sort_needed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">sort_needed</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">sorted_robust</span><span class="p">(</span><span class="n">ans</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ans</span>

    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator of the component data objects</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ordered: bool</span>
<span class="sd">            If True, then the values are returned in a deterministic</span>
<span class="sd">            order.  If the underlying indexing set is ordered then that</span>
<span class="sd">            ordering is used.  Otherwise, the component keys are sorted</span>
<span class="sd">            using :py:func:`sorted_robust` and the values are returned</span>
<span class="sd">            in that order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="n">ordered</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator of (index,data) component data tuples</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ordered: bool</span>
<span class="sd">            If True, then the items are returned in a deterministic</span>
<span class="sd">            order.  If the underlying indexing set is ordered then that</span>
<span class="sd">            ordering is used.  Otherwise, the items are sorted using</span>
<span class="sd">            :py:func:`sorted_robust`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="n">ordered</span><span class="p">))</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s1">&#39;The iterkeys method is deprecated. Use dict.keys().&#39;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;6.0&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of keys in the dictionary&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s1">&#39;The itervalues method is deprecated. Use dict.values().&#39;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;6.0&#39;</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of the component data objects in the dictionary&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s1">&#39;The iteritems method is deprecated. Use dict.items().&#39;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;6.0&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list (index,data) tuples from the dictionary&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the data corresponding to the given index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructed</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_not_constructed_error</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">_NotFound</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processUnhashableIndex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># This index is really unhashable.  Set a flag so that</span>
                <span class="c1"># we can re-raise the original exception (not this one)</span>
                <span class="n">index</span> <span class="o">=</span> <span class="ne">TypeError</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">IndexedComponent_slice</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">index</span>
            <span class="c1"># The index could have contained constant but nonhashable</span>
            <span class="c1"># objects (e.g., scalar immutable Params).</span>
            <span class="c1"># _processUnhashableIndex will evaluate those constants, so</span>
            <span class="c1"># if it made any changes to the index, we need to re-check</span>
            <span class="c1"># the _data dict for membership.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">_NotFound</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">_NotFound</span>

        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="n">_NotFound</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">EXPR</span><span class="o">.</span><span class="n">GetItemExpression</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">index</span>
            <span class="n">validated_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">validated_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">index</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">validated_index</span>
                <span class="c1"># _processUnhashableIndex could have found a slice, or</span>
                <span class="c1"># _validate could have found an Ellipsis and returned a</span>
                <span class="c1"># slicer</span>
                <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">IndexedComponent_slice</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">index</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">_NotFound</span><span class="p">)</span>
            <span class="c1">#</span>
            <span class="c1"># Call the _getitem_when_not_present helper to retrieve/return</span>
            <span class="c1"># the default value</span>
            <span class="c1">#</span>
            <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="n">_NotFound</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem_when_not_present</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="c1">#</span>
        <span class="c1"># Set the value: This relies on _setitem_when_not_present() to</span>
        <span class="c1"># insert the correct ComponentData into the _data dictionary</span>
        <span class="c1"># when it is not present and _setitem_impl to update an existing</span>
        <span class="c1"># entry.</span>
        <span class="c1">#</span>
        <span class="c1"># Note: it is important that we check _constructed is False and not</span>
        <span class="c1"># just evaluates to false: when constructing immutable Params,</span>
        <span class="c1"># _constructed will be None during the construction process when</span>
        <span class="c1"># setting the value is valid.</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructed</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_not_constructed_error</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">_NotFound</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">_NotFound</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processUnhashableIndex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="n">_NotFound</span><span class="p">:</span>
            <span class="c1"># If we didn&#39;t find the index in the data, then we need to</span>
            <span class="c1"># validate it against the underlying set (as long as</span>
            <span class="c1"># _processUnhashableIndex didn&#39;t return a slicer)</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">IndexedComponent_slice</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setitem_impl</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># Call the _setitem_impl helper to populate the _data</span>
        <span class="c1"># dictionary and set the value</span>
        <span class="c1">#</span>
        <span class="c1"># Note that we need to RECHECK the class against</span>
        <span class="c1"># IndexedComponent_slice, as _validate_index could have found</span>
        <span class="c1"># an Ellipsis (which is hashable) and returned a slicer</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">IndexedComponent_slice</span><span class="p">:</span>
            <span class="c1"># support &quot;m.x[:,1] = 5&quot; through a simple recursive call.</span>
            <span class="c1">#</span>
            <span class="c1"># Assert that this slice was just generated</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">_call_stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="c1">#</span>
            <span class="c1"># Note that the slicer will only slice over *existing*</span>
            <span class="c1"># entries, but they may not be in the data dictionary.  Make</span>
            <span class="c1"># a copy of the slicer items *before* we start iterating</span>
            <span class="c1"># over it in case the setter changes the _data dictionary.</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">expanded_items</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_setitem_impl</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">_NotFound</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="n">_NotFound</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setitem_when_not_present</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setitem_impl</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructed</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_not_constructed_error</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">_NotFound</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">_NotFound</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processUnhashableIndex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="n">_NotFound</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">IndexedComponent_slice</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># this supports &quot;del m.x[:,1]&quot; through a simple recursive call</span>
        <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">IndexedComponent_slice</span><span class="p">:</span>
            <span class="c1"># Assert that this slice ws just generated</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">_call_stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="c1"># Make a copy of the slicer items *before* we start</span>
            <span class="c1"># iterating over it (since we will be removing items!).</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">expanded_keys</span><span class="p">()):</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Handle the normal deletion operation</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
                <span class="c1"># Remove reference to this object</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">_component</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_pop_from_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">namelist</span><span class="p">,</span> <span class="n">notset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">arg</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">notset</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">namelist</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">notset</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">notset</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">argnames</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2"> &#39;</span><span class="si">%s</span><span class="s2">=&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">=&#39;&quot;</span> <span class="o">%</span> <span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">namelist</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                <span class="s1">&#39;,&#39;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">namelist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                <span class="n">namelist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Duplicate initialization: </span><span class="si">%s</span><span class="s2">() only accepts one of </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">argnames</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_construct_from_rule_using_setitem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rule</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">rule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rule</span>
        <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rule</span><span class="o">.</span><span class="n">constant</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
                <span class="c1"># A constant rule could return a dict-like thing or</span>
                <span class="c1"># matrix that we would then want to process with</span>
                <span class="c1"># Initializer().  If the rule actually returned a</span>
                <span class="c1"># constant, then this is just a little overhead.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rule</span> <span class="o">=</span> <span class="n">rule</span> <span class="o">=</span> <span class="n">Initializer</span><span class="p">(</span>
                    <span class="n">rule</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="n">treat_sequences_as_mappings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">arg_not_specified</span><span class="o">=</span><span class="n">NOTSET</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">rule</span><span class="o">.</span><span class="n">contains_indices</span><span class="p">():</span>
                <span class="c1"># The index is coming in externally; we need to validate it</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">rule</span><span class="o">.</span><span class="n">indices</span><span class="p">():</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">rule</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_set</span><span class="p">()</span><span class="o">.</span><span class="n">isfinite</span><span class="p">():</span>
                <span class="c1"># If the index is not finite, then we cannot iterate</span>
                <span class="c1"># over it.  Since the rule doesn&#39;t provide explicit</span>
                <span class="c1"># indices, then there is nothing we can do (the</span>
                <span class="c1"># assumption is that the user will trigger specific</span>
                <span class="c1"># indices to be created at a later time).</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">rule</span><span class="o">.</span><span class="n">constant</span><span class="p">():</span>
                <span class="c1"># Slight optimization: if the initializer is known to be</span>
                <span class="c1"># constant, then only call the rule once.</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">rule</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_set</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_setitem_when_not_present</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_set</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_setitem_when_not_present</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">rule</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Rule failed for </span><span class="si">%s</span><span class="s2"> &#39;</span><span class="si">%s</span><span class="s2">&#39; with index </span><span class="si">%s</span><span class="s2">:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">_not_constructed_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="c1"># Generate an error because the component is not constructed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
            <span class="n">idx_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">elif</span> <span class="n">idx</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">idx_str</span> <span class="o">=</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx_str</span> <span class="o">=</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Error retrieving component </span><span class="si">%s%s</span><span class="s2">: The component has &quot;</span>
            <span class="s2">&quot;not been constructed.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">idx_str</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">IndexedComponent</span><span class="o">.</span><span class="n">_DEFAULT_INDEX_CHECKING_ENABLED</span><span class="p">:</span>
            <span class="c1"># Return whatever index was provided if the global flag dictates</span>
            <span class="c1"># that we should bypass all index checking and domain validation</span>
            <span class="k">return</span> <span class="n">idx</span>

        <span class="c1"># This is only called through __{get,set,del}item__, which has</span>
        <span class="c1"># already trapped unhashable objects.</span>
        <span class="n">validated_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">_NotFound</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">validated_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_NotFound</span><span class="p">:</span>
            <span class="c1"># If the index is in the underlying index set, then return it</span>
            <span class="c1">#  Note: This check is potentially expensive (e.g., when the</span>
            <span class="c1"># indexing set is a complex set operation)!</span>
            <span class="k">return</span> <span class="n">validated_idx</span>

        <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">IndexedComponent_slice</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">idx</span>

        <span class="k">if</span> <span class="n">normalize_index</span><span class="o">.</span><span class="n">flatten</span><span class="p">:</span>
            <span class="c1"># Now we normalize the index and check again.  Usually,</span>
            <span class="c1"># indices will be already be normalized, so we defer the</span>
            <span class="c1"># &quot;automatic&quot; call to normalize_index until now for the</span>
            <span class="c1"># sake of efficiency.</span>
            <span class="n">normalized_idx</span> <span class="o">=</span> <span class="n">normalize_index</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">normalized_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">idx</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">normalized_idx</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">idx</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">idx</span>
        <span class="c1"># There is the chance that the index contains an Ellipsis,</span>
        <span class="c1"># so we should generate a slicer</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="bp">Ellipsis</span> <span class="ow">or</span> <span class="n">idx</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="nb">tuple</span> <span class="ow">and</span> <span class="bp">Ellipsis</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processUnhashableIndex</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># Generate different errors, depending on the state of the index.</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot treat the scalar component &#39;</span><span class="si">%s</span><span class="s2">&#39; &quot;</span>
                <span class="s2">&quot;as an indexed component&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
            <span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># Raise an exception</span>
        <span class="c1">#</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
            <span class="s2">&quot;Index &#39;</span><span class="si">%s</span><span class="s2">&#39; is not valid for indexed component &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_processUnhashableIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process a call to __getitem__ with unhashable elements</span>

<span class="sd">        There are three basic ways to get here:</span>
<span class="sd">          1) the index contains one or more slices or ellipsis</span>
<span class="sd">          2) the index contains an unhashable type (e.g., a Pyomo</span>
<span class="sd">             (Scalar)Component</span>
<span class="sd">          3) the index contains an IndexTemplate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#</span>
        <span class="c1"># Iterate through the index and look for slices and constant</span>
        <span class="c1"># components</span>
        <span class="c1">#</span>
        <span class="n">orig_idx</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="n">fixed</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">sliced</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ellipsis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">#</span>
        <span class="c1"># Setup the slice template (in fixed)</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">normalize_index</span><span class="o">.</span><span class="n">flatten</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">normalize_index</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="p">,)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">slice</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">val</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="ow">or</span> <span class="n">val</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="ow">or</span> <span class="n">val</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                        <span class="s2">&quot;Indexed components can only be indexed with simple &quot;</span>
                        <span class="s2">&quot;slices: start and stop values are not allowed.&quot;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ellipsis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">sliced</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sliced</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">val</span>
                    <span class="k">continue</span>

            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ellipsis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                        <span class="s2">&quot;Indexed components can only be indexed with simple &quot;</span>
                        <span class="s2">&quot;slices: the Pyomo wildcard slice (Ellipsis; &quot;</span>
                        <span class="s2">&quot;e.g., &#39;...&#39;) can only appear once&quot;</span>
                    <span class="p">)</span>
                <span class="n">ellipsis</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s1">&#39;is_expression_type&#39;</span><span class="p">):</span>
                <span class="n">_num_val</span> <span class="o">=</span> <span class="n">val</span>
                <span class="c1"># Attempt to retrieve the numeric value .. if this</span>
                <span class="c1"># is a template expression generation, then it</span>
                <span class="c1"># should raise a TemplateExpressionError</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">EXPR</span><span class="o">.</span><span class="n">evaluate_expression</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">TemplateExpressionError</span><span class="p">:</span>
                    <span class="c1">#</span>
                    <span class="c1"># The index is a template expression, so return the</span>
                    <span class="c1"># templatized expression.</span>
                    <span class="c1">#</span>
                    <span class="k">return</span> <span class="n">EXPR</span><span class="o">.</span><span class="n">GetItemExpression</span><span class="p">((</span><span class="bp">self</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

                <span class="k">except</span> <span class="n">EXPR</span><span class="o">.</span><span class="n">NonConstantExpressionError</span><span class="p">:</span>
                    <span class="c1">#</span>
                    <span class="c1"># The expression contains an unfixed variable</span>
                    <span class="c1">#</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="sd">&quot;&quot;&quot;Error retrieving the value of an indexed item %s:</span>
<span class="sd">index %s is not a constant value.  This is likely not what you meant to</span>
<span class="sd">do, as if you later change the fixed value of the object this lookup</span>
<span class="sd">will not change.  If you understand the implications of using</span>
<span class="sd">non-constant values, you can get the current value of the object using</span>
<span class="sd">the value() function.&quot;&quot;&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="k">except</span> <span class="n">EXPR</span><span class="o">.</span><span class="n">FixedExpressionError</span><span class="p">:</span>
                    <span class="c1">#</span>
                    <span class="c1"># The expression contains a fixed variable</span>
                    <span class="c1">#</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="sd">&quot;&quot;&quot;Error retrieving the value of an indexed item %s:</span>
<span class="sd">index %s is a fixed but not constant value.  This is likely not what you</span>
<span class="sd">meant to do, as if you later change the fixed value of the object this</span>
<span class="sd">lookup will not change.  If you understand the implications of using</span>
<span class="sd">fixed but not constant values, you can get the current value using the</span>
<span class="sd">value() function.&quot;&quot;&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="c1">#</span>
                <span class="c1"># There are other ways we could get an exception such as</span>
                <span class="c1"># evaluating a Param / Var that is not initialized.</span>
                <span class="c1"># These exceptions will continue up the call stack.</span>
                <span class="c1">#</span>

            <span class="c1"># verify that the value is hashable</span>
            <span class="nb">hash</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ellipsis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fixed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fixed</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="k">if</span> <span class="n">sliced</span> <span class="ow">or</span> <span class="n">ellipsis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">slice_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ellipsis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">slice_dim</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">normalize_index</span><span class="o">.</span><span class="n">flatten</span><span class="p">:</span>
                <span class="n">set_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_subsets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Scalar component.</span>
                <span class="n">set_dim</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">set_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_implicit_subsets</span><span class="p">)</span>

            <span class="n">structurally_valid</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">slice_dim</span> <span class="o">==</span> <span class="n">set_dim</span> <span class="ow">or</span> <span class="n">set_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">structurally_valid</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">set_dim</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># UnknownSetDimen</span>
            <span class="k">elif</span> <span class="n">ellipsis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">slice_dim</span> <span class="o">&lt;</span> <span class="n">set_dim</span><span class="p">:</span>
                <span class="n">structurally_valid</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">set_dim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">==</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),):</span>
                <span class="c1"># If dim == 0 and idx is slice(None), the component was</span>
                <span class="c1"># a scalar passed a single slice. Since scalar components</span>
                <span class="c1"># can be accessed with a &quot;1-dimensional&quot; index of None,</span>
                <span class="c1"># this behavior is allowed.</span>
                <span class="c1">#</span>
                <span class="c1"># Note that x[...] is caught above, as slice_dim will be</span>
                <span class="c1"># 0 in that case</span>
                <span class="n">structurally_valid</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">structurally_valid</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Index </span><span class="si">%s</span><span class="s2"> contains an invalid number of entries for &quot;</span>
                    <span class="s2">&quot;component &#39;</span><span class="si">%s</span><span class="s2">&#39;. Expected </span><span class="si">%s</span><span class="s2">, got </span><span class="si">%s</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">set_dim</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">:</span>
                    <span class="n">set_dim</span> <span class="o">=</span> <span class="n">set_dim</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">    &#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">    &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="n">textwrap</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span>
                            <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span>
                                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                                Slicing components relies on knowing the</span>
<span class="sd">                                underlying set dimensionality (even if the</span>
<span class="sd">                                dimensionality is None).  The underlying</span>
<span class="sd">                                component set (&#39;%s&#39;) dimensionality has not been</span>
<span class="sd">                                determined (likely because it is an empty Set).</span>
<span class="sd">                                You can avoid this error by specifying the Set</span>
<span class="sd">                                dimensionality (with the &#39;dimen=&#39; keyword).&quot;&quot;&quot;</span>
                                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_set</span><span class="p">(),)</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                    <span class="n">msg</span>
                    <span class="o">%</span> <span class="p">(</span>
                        <span class="n">IndexedComponent_slice</span><span class="o">.</span><span class="n">_getitem_args_to_str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">idx</span><span class="p">)),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                        <span class="n">set_dim</span><span class="p">,</span>
                        <span class="n">slice_dim</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">IndexedComponent_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fixed</span><span class="p">,</span> <span class="n">sliced</span><span class="p">,</span> <span class="n">ellipsis</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixed</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fixed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">fixed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DeveloperError</span><span class="p">(</span>
                <span class="s2">&quot;Unknown problem encountered when trying to retrieve &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;index &#39;</span><span class="si">{</span><span class="n">orig_idx</span><span class="si">}</span><span class="s2">&#39; for component &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getitem_when_not_present</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns/initializes a value when the index is not in the _data dict.</span>

<span class="sd">        Override this method if the component allows implicit member</span>
<span class="sd">        construction.  For classes that do not support a &#39;default&#39; (at</span>
<span class="sd">        this point, everything except Param and Var), requesting</span>
<span class="sd">        _getitem_when_not_present will generate a KeyError (just like a</span>
<span class="sd">        normal dict).</span>

<span class="sd">        Implementations may assume that the index has already been validated</span>
<span class="sd">        and is a legitimate entry in the _data dict.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setitem_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform the fundamental object value storage</span>

<span class="sd">        Components that want to implement a nonstandard storage mechanism</span>
<span class="sd">        should override this method.</span>

<span class="sd">        Implementations may assume that the index has already been</span>
<span class="sd">        validated and is a legitimate pre-existing entry in the _data</span>
<span class="sd">        dict.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">IndexedComponent</span><span class="o">.</span><span class="n">Skip</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_setitem_when_not_present</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">_NotSpecified</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform the fundamental component item creation and storage.</span>

<span class="sd">        Components that want to implement a nonstandard storage mechanism</span>
<span class="sd">        should override this method.</span>

<span class="sd">        Implementations may assume that the index has already been</span>
<span class="sd">        validated and is a legitimate entry to add to the _data dict.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the value is &quot;Skip&quot; do not add anything</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">IndexedComponent</span><span class="o">.</span><span class="n">Skip</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1">#</span>
        <span class="c1"># If we are a scalar, then idx will be None (_validate_index ensures</span>
        <span class="c1"># this)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ComponentDataClass</span><span class="p">(</span><span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_NotSpecified</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the value of a scalar component.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot set the value for the indexed component &#39;</span><span class="si">%s</span><span class="s2">&#39; &quot;</span>
                <span class="s2">&quot;without specifying an index value.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">For example, model.</span><span class="si">%s</span><span class="s2">[i] = value&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DeveloperError</span><span class="p">(</span>
                <span class="s2">&quot;Derived component </span><span class="si">%s</span><span class="s2"> failed to define set_value() &quot;</span>
                <span class="s2">&quot;for scalar instances.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print component information.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;Size&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span>
                <span class="p">(</span><span class="s2">&quot;Index&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">()</span> <span class="k">else</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span>
            <span class="p">(</span><span class="s2">&quot;Object&quot;</span><span class="p">,),</span>
            <span class="k">lambda</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)],</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">id_index_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an dictionary id-&gt;index for</span>
<span class="sd">        all ComponentData instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">component_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">result</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">component_data</span><span class="p">)]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">return</span> <span class="n">result</span>


<span class="k">class</span> <span class="nc">ActiveIndexedComponent</span><span class="p">(</span><span class="n">IndexedComponent</span><span class="p">,</span> <span class="n">ActiveComponent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the base class for all indexed modeling components</span>
<span class="sd">    whose data members are subclasses of ActiveComponentData, e.g.,</span>
<span class="sd">    can be activated or deactivated.</span>

<span class="sd">    The activate and deactivate methods activate both the</span>
<span class="sd">    component as well as all component data values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">IndexedComponent</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="c1"># Replicate the ActiveComponent.__init__() here.  We don&#39;t want</span>
        <span class="c1"># to use super, because that will run afoul of certain</span>
        <span class="c1"># assumptions for derived SimpleComponents&#39; __init__()</span>
        <span class="c1">#</span>
        <span class="c1"># FIXME: eliminate multiple inheritance of SimpleComponents</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">activate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the active attribute to True&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ActiveIndexedComponent</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">activate</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">component_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">component_data</span><span class="o">.</span><span class="n">activate</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">deactivate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the active attribute to False&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ActiveIndexedComponent</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">deactivate</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">component_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">component_data</span><span class="o">.</span><span class="n">deactivate</span><span class="p">()</span>


<span class="c1"># Ideally, this would inherit from np.lib.mixins.NDArrayOperatorsMixin,</span>
<span class="c1"># but doing so overrides things like __contains__ in addition to the</span>
<span class="c1"># operators that we are interested in.</span>
<span class="k">class</span> <span class="nc">IndexedComponent_NDArrayMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Support using IndexedComponent with numpy.ndarray</span>

<span class="sd">    This IndexedComponent mixin class adds support for implicitly using</span>
<span class="sd">    the IndexedComponent as a term in an expression with numpy ndarray</span>
<span class="sd">    objects.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">NumericNDArray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">return</span> <span class="n">ans</span>

        <span class="n">_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot convert a non-dimensioned Pyomo IndexedComponent &quot;</span>
                <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">) into a numpy array&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span>
            <span class="p">)</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_set</span><span class="p">()</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">((</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span> <span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],))</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot convert a Pyomo IndexedComponent &quot;</span>
                <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">) with bounds [</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">] into a numpy array&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">NumericNDArray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ans</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">ans</span>

    <span class="k">def</span> <span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">NumericNDArray</span><span class="o">.</span><span class="n">__array_ufunc__</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2008-2023, Sandia National Laboratories.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>