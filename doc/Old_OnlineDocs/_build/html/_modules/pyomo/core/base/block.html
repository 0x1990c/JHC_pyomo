

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>pyomo.core.base.block &mdash; Pyomo 6.5.1.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/theme_overrides.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/clipboard.min.js"></script>
        <script src="../../../../_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> Pyomo
          

          
          </a>

          
            
            
              <div class="version">
                6.5.1.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../citing_pyomo.html">Citing Pyomo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pyomo_overview/index.html">Pyomo Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pyomo_modeling_components/index.html">Pyomo Modeling Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../solving_pyomo_models.html">Solving Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_models.html">Working with Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_abstractmodels/index.html">Working with Abstract Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_transformations/index.html">Model Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modeling_extensions/index.html">Modeling Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial_examples.html">Pyomo Tutorial Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_debugging/index.html">Debugging Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../advanced_topics/index.html">Advanced Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../errors.html">Common Warnings/Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_reference/index.html">Developer Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../library_reference/index.html">Library Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contribution_guide.html">Contributing to Pyomo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributed_packages/index.html">Third-Party Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../related_packages.html">Related Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Pyomo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>pyomo.core.base.block</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyomo.core.base.block</h1><div class="highlight"><pre>
<span></span><span class="c1">#  ___________________________________________________________________________</span>
<span class="c1">#</span>
<span class="c1">#  Pyomo: Python Optimization Modeling Objects</span>
<span class="c1">#  Copyright (c) 2008-2022</span>
<span class="c1">#  National Technology and Engineering Solutions of Sandia, LLC</span>
<span class="c1">#  Under the terms of Contract DE-NA0003525 with National Technology and</span>
<span class="c1">#  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain</span>
<span class="c1">#  rights in this software.</span>
<span class="c1">#  This software is distributed under the 3-clause BSD License.</span>
<span class="c1">#  ___________________________________________________________________________</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;Block&#39;</span><span class="p">,</span>
    <span class="s1">&#39;TraversalStrategy&#39;</span><span class="p">,</span>
    <span class="s1">&#39;SortComponents&#39;</span><span class="p">,</span>
    <span class="s1">&#39;active_components&#39;</span><span class="p">,</span>
    <span class="s1">&#39;components&#39;</span><span class="p">,</span>
    <span class="s1">&#39;active_components_data&#39;</span><span class="p">,</span>
    <span class="s1">&#39;components_data&#39;</span><span class="p">,</span>
    <span class="s1">&#39;SimpleBlock&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ScalarBlock&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>

<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">isclass</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">filterfalse</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span><span class="p">,</span> <span class="n">attrgetter</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="kn">from</span> <span class="nn">pyomo.common.pyomo_typing</span> <span class="kn">import</span> <span class="n">overload</span>

<span class="kn">from</span> <span class="nn">pyomo.common.autoslots</span> <span class="kn">import</span> <span class="n">AutoSlots</span>
<span class="kn">from</span> <span class="nn">pyomo.common.collections</span> <span class="kn">import</span> <span class="n">Mapping</span>
<span class="kn">from</span> <span class="nn">pyomo.common.deprecation</span> <span class="kn">import</span> <span class="n">deprecated</span><span class="p">,</span> <span class="n">deprecation_warning</span><span class="p">,</span> <span class="n">RenamedClass</span>
<span class="kn">from</span> <span class="nn">pyomo.common.formatting</span> <span class="kn">import</span> <span class="n">StreamIndenter</span>
<span class="kn">from</span> <span class="nn">pyomo.common.gc_manager</span> <span class="kn">import</span> <span class="n">PauseGC</span>
<span class="kn">from</span> <span class="nn">pyomo.common.log</span> <span class="kn">import</span> <span class="n">is_debug_set</span>
<span class="kn">from</span> <span class="nn">pyomo.common.sorting</span> <span class="kn">import</span> <span class="n">sorted_robust</span>
<span class="kn">from</span> <span class="nn">pyomo.common.timing</span> <span class="kn">import</span> <span class="n">ConstructionTimer</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.component</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Component</span><span class="p">,</span>
    <span class="n">ActiveComponentData</span><span class="p">,</span>
    <span class="n">ModelComponentFactory</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.global_set</span> <span class="kn">import</span> <span class="n">UnindexedComponent_index</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.componentuid</span> <span class="kn">import</span> <span class="n">ComponentUID</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.set</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">GlobalSetBase</span><span class="p">,</span> <span class="n">_SetDataBase</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.var</span> <span class="kn">import</span> <span class="n">Var</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.initializer</span> <span class="kn">import</span> <span class="n">Initializer</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.indexed_component</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ActiveIndexedComponent</span><span class="p">,</span>
    <span class="n">UnindexedComponent_set</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">pyomo.opt.base</span> <span class="kn">import</span> <span class="n">ProblemFormat</span><span class="p">,</span> <span class="n">guess_format</span>
<span class="kn">from</span> <span class="nn">pyomo.opt</span> <span class="kn">import</span> <span class="n">WriterFactory</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;pyomo.core&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_generic_component_decorator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A generic decorator that wraps Block.__setattr__()</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">        component: the Pyomo Component class to construct</span>
<span class="sd">        block: the block onto which to add the new component</span>
<span class="sd">        *args: positional arguments to the Component constructor</span>
<span class="sd">               (*excluding* the block argument)</span>
<span class="sd">        **kwds: keyword arguments to the Component constructor</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_component</span> <span class="o">=</span> <span class="n">component</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_block</span> <span class="o">=</span> <span class="n">block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kwds</span> <span class="o">=</span> <span class="n">kwds</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">):</span>
        <span class="nb">setattr</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="p">,</span>
            <span class="n">rule</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_component</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">,</span> <span class="n">rule</span><span class="o">=</span><span class="n">rule</span><span class="p">,</span> <span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwds</span><span class="p">)),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">rule</span>


<span class="k">class</span> <span class="nc">_component_decorator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that wraps the _generic_component_decorator, which remembers</span>
<span class="sd">    and provides the Block and component type to the decorator.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">        component: the Pyomo Component class to construct</span>
<span class="sd">        block: the block onto which to add the new component</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_block</span> <span class="o">=</span> <span class="n">block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_component</span> <span class="o">=</span> <span class="n">component</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_generic_component_decorator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_component</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SubclassOf</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This mocks up a tuple-like interface based on subclass relationship.</span>

<span class="sd">    Instances of this class present a somewhat tuple-like interface for</span>
<span class="sd">    use in PseudoMap ctype / descend_into.  The constructor takes a</span>
<span class="sd">    single ctype argument.  When used with PseudoMap (through Block APIs</span>
<span class="sd">    like component_objects()), it will match any ctype that is a</span>
<span class="sd">    subclass of the reference ctype.</span>

<span class="sd">    This allows, for example:</span>

<span class="sd">        model.component_data_objects(Var, descend_into=SubclassOf(Block))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">ctype</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span> <span class="o">=</span> <span class="n">ctype</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s1">&#39;SubclassOf(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ctype</span><span class="p">),)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctype</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">((</span><span class="bp">self</span><span class="p">,))</span>


<span class="k">class</span> <span class="nc">_DeduplicateInfo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class implementing a unique component data object filter</span>

<span class="sd">    This class implements :py:meth:`unique()`, which is an efficient</span>
<span class="sd">    Reference-aware filter that wraps a generator and returns only</span>
<span class="sd">    unique component data objects.  This is nominally the same as:</span>

<span class="sd">        seen = set()</span>
<span class="sd">        for data in iterator:</span>
<span class="sd">            if id(data) not in seen:</span>
<span class="sd">                seen.add(id(data))</span>
<span class="sd">                yield data</span>

<span class="sd">    However, it is aware of the existence of Reference components (and</span>
<span class="sd">    that the only way you should ever encounter a duplicate is through a</span>
<span class="sd">    Reference).  This allows it to avoid generating and storing the id()</span>
<span class="sd">    of every data object.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;seen_components&#39;</span><span class="p">,</span> <span class="s1">&#39;seen_comp_thru_reference&#39;</span><span class="p">,</span> <span class="s1">&#39;seen_data&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seen_components</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seen_comp_thru_reference</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seen_data</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">are_values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generator that filters duplicate _ComponentData objects from items</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        comp: ComponentBase</span>
<span class="sd">           The Component (indexed or scalar) that contains all</span>
<span class="sd">           _ComponentData returned by the `items` generator.</span>

<span class="sd">        items: generator</span>
<span class="sd">            Generator yielding either the values or the items from the</span>
<span class="sd">            `comp` Component.</span>

<span class="sd">        are_values: bool</span>
<span class="sd">            If `True`, `items` yields _ComponentData objects, otherwise,</span>
<span class="sd">            `items` yields `(index, _ComponentData)` tuples.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">is_reference</span><span class="p">():</span>
            <span class="n">seen_components_contains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seen_components</span><span class="o">.</span><span class="fm">__contains__</span>
            <span class="n">seen_comp_thru_reference_contains</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">seen_comp_thru_reference</span><span class="o">.</span><span class="fm">__contains__</span>
            <span class="p">)</span>
            <span class="n">seen_comp_thru_reference_add</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seen_comp_thru_reference</span><span class="o">.</span><span class="n">add</span>
            <span class="n">seen_data_contains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seen_data</span><span class="o">.</span><span class="fm">__contains__</span>
            <span class="n">seen_data_add</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seen_data</span><span class="o">.</span><span class="n">add</span>

            <span class="k">for</span> <span class="n">_item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                <span class="n">_data</span> <span class="o">=</span> <span class="n">_item</span> <span class="k">if</span> <span class="n">are_values</span> <span class="k">else</span> <span class="n">_item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># If the data is contained in a component we have</span>
                <span class="c1"># already processed, then it is a duplicate and we can</span>
                <span class="c1"># bypass further checks.</span>
                <span class="n">_id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">parent_component</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">seen_components_contains</span><span class="p">(</span><span class="n">_id</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="c1"># Remember that this component has already been</span>
                <span class="c1"># partially visited (important for the case that we hit</span>
                <span class="c1"># the &quot;natural&quot; component later in the generator)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">seen_comp_thru_reference_contains</span><span class="p">(</span><span class="n">_id</span><span class="p">):</span>
                    <span class="n">seen_comp_thru_reference_add</span><span class="p">(</span><span class="n">_id</span><span class="p">)</span>
                <span class="c1"># Yield any data objects we haven&#39;t seen yet (and</span>
                <span class="c1"># remember them)</span>
                <span class="n">_id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">_data</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">seen_data_contains</span><span class="p">(</span><span class="n">_id</span><span class="p">):</span>
                    <span class="n">seen_data_add</span><span class="p">(</span><span class="n">_id</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">_item</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># this is a &quot;natural&quot; component</span>
            <span class="c1"># Remember that we have completely processed this component</span>
            <span class="n">_id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seen_components</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seen_comp_thru_reference</span><span class="p">:</span>
                <span class="c1"># No data in this component has yet been emitted</span>
                <span class="c1"># (through a Reference), so we can just yield all the</span>
                <span class="c1"># values.</span>
                <span class="k">yield from</span> <span class="n">items</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This component has had some data yielded (through</span>
                <span class="c1"># References).  We need to check for conflicts before</span>
                <span class="c1"># yielding each data.  Note that since we have already</span>
                <span class="c1"># marked the entire component as processed and data can</span>
                <span class="c1"># not reappear in natural components, we only need to</span>
                <span class="c1"># check for duplicates and not remember them.</span>
                <span class="n">seen_data_contains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seen_data</span><span class="o">.</span><span class="fm">__contains__</span>
                <span class="k">for</span> <span class="n">_item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">seen_data_contains</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">_item</span> <span class="k">if</span> <span class="n">are_values</span> <span class="k">else</span> <span class="n">_item</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                        <span class="k">yield</span> <span class="n">_item</span>


<span class="k">class</span> <span class="nc">SortComponents</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is a convenient wrapper for specifying various sort</span>
<span class="sd">    ordering.  We pass these objects to the &quot;sort&quot; argument to various</span>
<span class="sd">    accessors / iterators to control how much work we perform sorting</span>
<span class="sd">    the resultant list.  The idea is that</span>
<span class="sd">    &quot;sort=SortComponents.deterministic&quot; is more descriptive than</span>
<span class="sd">    &quot;sort=True&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">unsorted</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">declOrder</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">declarationOrder</span> <span class="o">=</span> <span class="n">declOrder</span>
    <span class="n">alphaOrder</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">alphabeticalOrder</span> <span class="o">=</span> <span class="n">alphaOrder</span>
    <span class="n">alphabetical</span> <span class="o">=</span> <span class="n">alphaOrder</span>
    <span class="c1"># both alpha and decl orders are deterministic, so only must sort indices</span>
    <span class="n">deterministic</span> <span class="o">=</span> <span class="n">indices</span>
    <span class="n">sortBoth</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">|</span> <span class="n">alphabeticalOrder</span>  <span class="c1"># Same as True</span>
    <span class="n">alphabetizeComponentAndIndex</span> <span class="o">=</span> <span class="n">sortBoth</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">default</span><span class="p">():</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">sorter</span><span class="p">(</span><span class="n">sort_by_names</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort_by_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">sort</span> <span class="o">=</span> <span class="n">SortComponents</span><span class="o">.</span><span class="n">default</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sort_by_names</span><span class="p">:</span>
            <span class="n">sort</span> <span class="o">|=</span> <span class="n">SortComponents</span><span class="o">.</span><span class="n">alphabeticalOrder</span>
        <span class="k">if</span> <span class="n">sort_by_keys</span><span class="p">:</span>
            <span class="n">sort</span> <span class="o">|=</span> <span class="n">SortComponents</span><span class="o">.</span><span class="n">indices</span>
        <span class="k">return</span> <span class="n">sort</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">sort_names</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">flag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">SortComponents</span><span class="o">.</span><span class="n">alphaOrder</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">sort_indices</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">flag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">SortComponents</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">TraversalStrategy</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">BreadthFirstSearch</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
    <span class="n">PrefixDepthFirstSearch</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)</span>
    <span class="n">PostfixDepthFirstSearch</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)</span>
    <span class="c1"># aliases</span>
    <span class="n">BFS</span> <span class="o">=</span> <span class="n">BreadthFirstSearch</span>
    <span class="n">ParentLastDepthFirstSearch</span> <span class="o">=</span> <span class="n">PostfixDepthFirstSearch</span>
    <span class="n">PostfixDFS</span> <span class="o">=</span> <span class="n">PostfixDepthFirstSearch</span>
    <span class="n">ParentFirstDepthFirstSearch</span> <span class="o">=</span> <span class="n">PrefixDepthFirstSearch</span>
    <span class="n">PrefixDFS</span> <span class="o">=</span> <span class="n">PrefixDepthFirstSearch</span>
    <span class="n">DepthFirstSearch</span> <span class="o">=</span> <span class="n">PrefixDepthFirstSearch</span>
    <span class="n">DFS</span> <span class="o">=</span> <span class="n">DepthFirstSearch</span>


<span class="k">def</span> <span class="nf">_sortingLevelWalker</span><span class="p">(</span><span class="n">list_of_generators</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Utility function for iterating over all members of a list of</span>
<span class="sd">    generators that prefixes each item with the index of the original</span>
<span class="sd">    generator that produced it.  This is useful for creating lists where</span>
<span class="sd">    we want to preserve the original generator order but want to sort</span>
<span class="sd">    the sub-lists.</span>

<span class="sd">    Note that the generators must produce tuples.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lastName</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">nameCounter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">list_of_generators</span><span class="p">:</span>
        <span class="n">nameCounter</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Each generator starts a new component name</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">lastName</span><span class="p">:</span>
                <span class="n">nameCounter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">lastName</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">nameCounter</span><span class="p">,)</span> <span class="o">+</span> <span class="n">item</span>


<span class="k">def</span> <span class="nf">_levelWalker</span><span class="p">(</span><span class="n">list_of_generators</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simple utility function for iterating over all members of a list of</span>
<span class="sd">    generators.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">list_of_generators</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">gen</span>


<span class="k">def</span> <span class="nf">_isNotNone</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">_BlockConstruction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class holds a &quot;global&quot; dict used when constructing</span>
<span class="sd">    (hierarchical) models.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>


<span class="k">class</span> <span class="nc">PseudoMap</span><span class="p">(</span><span class="n">AutoSlots</span><span class="o">.</span><span class="n">Mixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class presents a &quot;mock&quot; dict interface to the internal</span>
<span class="sd">    _BlockData data structures.  We return this object to the</span>
<span class="sd">    user to preserve the historical &quot;{ctype : {name : obj}}&quot;</span>
<span class="sd">    interface without actually regenerating that dict-of-dicts data</span>
<span class="sd">    structure.</span>

<span class="sd">    We now support {ctype : PseudoMap()}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_block&#39;</span><span class="p">,</span> <span class="s1">&#39;_ctypes&#39;</span><span class="p">,</span> <span class="s1">&#39;_active&#39;</span><span class="p">,</span> <span class="s1">&#39;_sorted&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_block</span> <span class="o">=</span> <span class="n">block</span>
        <span class="k">if</span> <span class="n">isclass</span><span class="p">(</span><span class="n">ctype</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span> <span class="o">=</span> <span class="p">{</span><span class="n">ctype</span><span class="p">}</span>
        <span class="k">elif</span> <span class="n">ctype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span> <span class="o">=</span> <span class="n">Any</span>
        <span class="k">elif</span> <span class="n">ctype</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">SubclassOf</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span> <span class="o">=</span> <span class="n">ctype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ctype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="o">=</span> <span class="n">active</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sorted</span> <span class="o">=</span> <span class="n">SortComponents</span><span class="o">.</span><span class="n">sort_names</span><span class="p">(</span><span class="n">sort</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">_decl</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">_decl</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ctype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">active</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="ow">and</span> <span class="s2">&quot;active &quot;</span> <span class="ow">or</span> <span class="s2">&quot;inactive &quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Any</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">))</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">types</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> or </span><span class="si">%s</span><span class="s1"> &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">types</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">types</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">component &#39;</span><span class="si">%s</span><span class="s2">&#39; not found in block </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Shortcut: this will bail after finding the first</span>
        <span class="c1"># (non-None) item.  Note that we temporarily disable sorting</span>
        <span class="c1"># -- otherwise, if this is a sorted PseudoMap the entire</span>
        <span class="c1"># list will be walked and sorted before returning the first</span>
        <span class="c1"># element.</span>
        <span class="n">sort_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sorted</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sorted</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sorted</span> <span class="o">=</span> <span class="n">sort_order</span>

    <span class="fm">__bool__</span> <span class="o">=</span> <span class="n">__nonzero__</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#</span>
        <span class="c1"># If _active is None, then the number of components is</span>
        <span class="c1"># simply the total of the counts of the ctypes that have</span>
        <span class="c1"># been added.</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span> <span class="ow">is</span> <span class="n">Any</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">_ctypes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Note that because of SubclassOf, we cannot iterate</span>
                <span class="c1"># over self._ctypes.</span>
                <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">_ctypes</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span>
                <span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># If _active is True or False, then we have to count by brute force.</span>
        <span class="c1">#</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">ans</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Return True is the underlying Block contains the component</span>
        <span class="c1"># name.  Note, if this Pseudomap soecifies a ctype or the</span>
        <span class="c1"># active flag, we need to check that the underlying</span>
        <span class="c1"># component matches those flags</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">_decl</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">_decl</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ctype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">active</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_ctypewalker</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: since push/pop from the end of lists is slightly more</span>
        <span class="c1"># efficient, we will reverse-sort so the next ctype index is</span>
        <span class="c1"># at the end of the list.</span>
        <span class="n">_decl_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">_decl_order</span>
        <span class="c1"># Note that because of SubclassOf, we cannot iterate over</span>
        <span class="c1"># self._ctypes. But this gets called a lot with a single type as</span>
        <span class="c1"># the ctypes set, so we will special case the set intersection.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="nb">set</span><span class="p">:</span>
            <span class="n">_idx_list</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">_ctypes</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_idx_list</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">_ctypes</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span>
            <span class="p">]</span>
        <span class="n">_idx_list</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">_idx_list</span><span class="p">:</span>
            <span class="n">_idx</span> <span class="o">=</span> <span class="n">_idx_list</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">_next_ctype</span> <span class="o">=</span> <span class="n">_idx_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">_idx_list</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">_obj</span><span class="p">,</span> <span class="n">_idx</span> <span class="o">=</span> <span class="n">_decl_order</span><span class="p">[</span><span class="n">_idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">_obj</span>
                <span class="k">if</span> <span class="n">_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">_next_ctype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">_idx</span> <span class="o">&gt;</span> <span class="n">_next_ctype</span><span class="p">:</span>
                    <span class="n">_idx_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_idx</span><span class="p">)</span>
                    <span class="n">_idx_list</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">break</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generator returning the component names defined on the Block</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Iterate over the PseudoMap keys (the component names) in</span>
        <span class="c1"># declaration order</span>
        <span class="c1">#</span>
        <span class="c1"># Ironically, the values are the fundamental thing that we</span>
        <span class="c1"># can (efficiently) iterate over in decl_order.  keys()</span>
        <span class="c1"># just wraps values().</span>
        <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generator returning the components defined on the Block</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Iterate over the PseudoMap values (the component objects) in</span>
        <span class="c1"># declaration order</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span> <span class="ow">is</span> <span class="n">Any</span><span class="p">:</span>
            <span class="c1"># If there is no ctype, then we will just iterate over</span>
            <span class="c1"># all components and return them all</span>
            <span class="n">walker</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="n">_isNotNone</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The user specified a desired ctype; we will leverage</span>
            <span class="c1"># the _ctypewalker generator to walk the underlying linked</span>
            <span class="c1"># list and just return the desired objects (again, in</span>
            <span class="c1"># decl order)</span>
            <span class="n">walker</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypewalker</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span><span class="p">:</span>
            <span class="n">walker</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;active&#39;</span><span class="p">),</span> <span class="n">walker</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_active</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">walker</span> <span class="o">=</span> <span class="n">filterfalse</span><span class="p">(</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;active&#39;</span><span class="p">),</span> <span class="n">walker</span><span class="p">)</span>

        <span class="c1"># If the user wants this sorted by name, then there is</span>
        <span class="c1"># nothing we can do to save memory: we must create the whole</span>
        <span class="c1"># list (so we can sort it) and then iterate over the sorted</span>
        <span class="c1"># temporary list</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sorted</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">walker</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">walker</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generator returning (name, component) tuples for components</span>
<span class="sd">        defined on the Block</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ironically, the values are the fundamental thing that we</span>
        <span class="c1"># can (efficiently) iterate over in decl_order.  items()</span>
        <span class="c1"># just wraps values().</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s1">&#39;The iterkeys method is deprecated. Use dict.keys().&#39;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;6.0&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generator returning the component names defined on the Block</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s1">&#39;The itervalues method is deprecated. Use dict.values().&#39;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;6.0&#39;</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generator returning the components defined on the Block</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s1">&#39;The iteritems method is deprecated. Use dict.items().&#39;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;6.0&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generator returning (name, component) tuples for components</span>
<span class="sd">        defined on the Block</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">_BlockData</span><span class="p">(</span><span class="n">ActiveComponentData</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class holds the fundamental block data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_Block_reserved_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="c1"># If a writer cached a repn on this block, remove it when cloning</span>
    <span class="c1">#  TODO: remove repn caching from the model</span>
    <span class="n">__autoslot_mappers</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;_repn&#39;</span><span class="p">:</span> <span class="n">AutoSlots</span><span class="o">.</span><span class="n">encode_as_none</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
        <span class="c1">#</span>
        <span class="c1"># BLOCK DATA ELEMENTS</span>
        <span class="c1">#</span>
        <span class="c1">#   _decl_order:  [ (component, id_of_next_ctype_in_decl_order), ...]</span>
        <span class="c1">#   _decl:        { name : index_in_decl_order }</span>
        <span class="c1">#   _ctypes:      { ctype : [ id_first_ctype, id_last_ctype, count ] }</span>
        <span class="c1">#</span>
        <span class="c1">#</span>
        <span class="c1"># We used to define an internal structure that looked like:</span>
        <span class="c1">#</span>
        <span class="c1">#    _component    = { ctype : OrderedDict( name : obj ) }</span>
        <span class="c1">#    _declarations = OrderedDict( name : obj )</span>
        <span class="c1">#</span>
        <span class="c1"># This structure is convenient, but the overhead of carrying</span>
        <span class="c1"># around roughly 20 dictionaries for every block consumed a</span>
        <span class="c1"># nontrivial amount of memory.  Plus, the generation and</span>
        <span class="c1"># maintenance of OrderedDicts appeared to be disturbingly slow.</span>
        <span class="c1">#</span>
        <span class="c1"># We now &quot;mock up&quot; this data structure using 2 dicts and a list:</span>
        <span class="c1">#</span>
        <span class="c1">#    _ctypes     = { ctype : [ first idx, last idx, count ] }</span>
        <span class="c1">#    _decl       = { name  : idx }</span>
        <span class="c1">#    _decl_order = [ (obj, next_ctype_idx) ]</span>
        <span class="c1">#</span>
        <span class="c1"># Some notes: As Pyomo models rarely *delete* objects, we</span>
        <span class="c1"># currently never remove items from the _decl_order list.  If</span>
        <span class="c1"># the component is ever removed / cleared, we simply mark the</span>
        <span class="c1"># object as None.  If models crop up where we start seeing a</span>
        <span class="c1"># significant amount of adding / removing components, then we</span>
        <span class="c1"># can revisit this decision (although we will probably continue</span>
        <span class="c1"># marking entries as None and just periodically rebuild the list</span>
        <span class="c1"># as opposed to maintaining the list without any holes).</span>
        <span class="c1">#</span>
        <span class="n">ActiveComponentData</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span>
        <span class="c1"># Note: call super() here to bypass the Block __setattr__</span>
        <span class="c1">#   _ctypes:      { ctype -&gt; [1st idx, last idx, count] }</span>
        <span class="c1">#   _decl:        { name -&gt; idx }</span>
        <span class="c1">#   _decl_order:  list( tuples( obj, next_type_idx ) )</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_BlockData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;_ctypes&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_BlockData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;_decl&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_BlockData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;_decl_order&#39;</span><span class="p">,</span> <span class="p">[])</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">ModelComponentFactory</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_component_decorator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ModelComponentFactory</span><span class="o">.</span><span class="n">get_class</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
        <span class="c1"># Since the base classes don&#39;t support getattr, we can just</span>
        <span class="c1"># throw the &quot;normal&quot; AttributeError</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; object has no attribute &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set an attribute of a block data object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#</span>
        <span class="c1"># In general, the most common case for this is setting a *new*</span>
        <span class="c1"># attribute.  After that, there is updating an existing</span>
        <span class="c1"># Component value, with the least common case being resetting an</span>
        <span class="c1"># existing general attribute.</span>
        <span class="c1">#</span>
        <span class="c1"># Case 1.  Add an attribute that is not currently in the class.</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Component</span><span class="p">):</span>
                <span class="c1">#</span>
                <span class="c1"># Pyomo components are added with the add_component method.</span>
                <span class="c1">#</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#</span>
                <span class="c1"># Other Python objects are added with the standard __setattr__</span>
                <span class="c1"># method.</span>
                <span class="c1">#</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">_BlockData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># Case 2.  The attribute exists and it is a component in the</span>
        <span class="c1">#          list of declarations in this block.  We will use the</span>
        <span class="c1">#          val to update the value of that [scalar] component</span>
        <span class="c1">#          through its set_value() method.</span>
        <span class="c1">#</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Component</span><span class="p">):</span>
                <span class="c1">#</span>
                <span class="c1"># The value is a component, so we replace the component in the</span>
                <span class="c1"># block.</span>
                <span class="c1">#</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_decl</span><span class="p">[</span><span class="n">name</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">val</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Implicitly replacing the Component attribute &quot;</span>
                    <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> (type=</span><span class="si">%s</span><span class="s2">) on block </span><span class="si">%s</span><span class="s2"> with a new Component (type=</span><span class="si">%s</span><span class="s2">).&quot;</span>
                    <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">This is usually indicative of a modelling error.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;To avoid this warning, use block.del_component() and &quot;</span>
                    <span class="s2">&quot;block.add_component().&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">name</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">del_component</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#</span>
                <span class="c1"># The incoming value is not a component, so we set the</span>
                <span class="c1"># value in the existing component.</span>
                <span class="c1">#</span>
                <span class="c1"># Because we want to log a special error only if the</span>
                <span class="c1"># set_value attribute is missing, we will fetch the</span>
                <span class="c1"># attribute first and then call the method outside of</span>
                <span class="c1"># the try-except so as to not suppress any exceptions</span>
                <span class="c1"># generated while setting the value.</span>
                <span class="c1">#</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">_set_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_decl</span><span class="p">[</span><span class="n">name</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_value</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="s2">&quot;Expected component </span><span class="si">%s</span><span class="s2"> (type=</span><span class="si">%s</span><span class="s2">) on block </span><span class="si">%s</span><span class="s2"> to have a &quot;</span>
                        <span class="s2">&quot;&#39;set_value&#39; method, but none was found.&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">name</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">raise</span>
                <span class="c1">#</span>
                <span class="c1"># Call the set_value method.</span>
                <span class="c1">#</span>
                <span class="n">_set_value</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># Case 3. Handle setting non-Component attributes</span>
        <span class="c1">#</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#</span>
            <span class="c1"># NB: This is important: the _BlockData is either a scalar</span>
            <span class="c1"># Block (where _parent and _component are defined) or a</span>
            <span class="c1"># single block within an Indexed Block (where only</span>
            <span class="c1"># _component is defined).  Regardless, the</span>
            <span class="c1"># _BlockData.__init__() method declares these methods and</span>
            <span class="c1"># sets them either to None or a weakref.  Thus, we will</span>
            <span class="c1"># never have a problem converting these objects from</span>
            <span class="c1"># weakrefs into Blocks and back (when pickling); the</span>
            <span class="c1"># attribute is already in __dict__, we will not hit the</span>
            <span class="c1"># add_component / del_component branches above.  It also</span>
            <span class="c1"># means that any error checking we want to do when assigning</span>
            <span class="c1"># these attributes should be done here.</span>
            <span class="c1">#</span>
            <span class="c1"># NB: isintance() can be slow and we generally avoid it in</span>
            <span class="c1"># core methods.  However, it is only slow when it returns</span>
            <span class="c1"># False.  Since the common paths on this branch should</span>
            <span class="c1"># return True, this shouldn&#39;t be too inefficient.</span>
            <span class="c1">#</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;_parent&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">(),</span> <span class="n">_BlockData</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot set the &#39;_parent&#39; attribute of Block &#39;</span><span class="si">%s</span><span class="s2">&#39; &quot;</span>
                        <span class="s2">&quot;to a non-Block object (with type=</span><span class="si">%s</span><span class="s2">); Did you &quot;</span>
                        <span class="s2">&quot;try to create a model component named &#39;_parent&#39;?&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
                    <span class="p">)</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">_BlockData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;_component&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">(),</span> <span class="n">_BlockData</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot set the &#39;_component&#39; attribute of Block &#39;</span><span class="si">%s</span><span class="s2">&#39; &quot;</span>
                        <span class="s2">&quot;to a non-Block object (with type=</span><span class="si">%s</span><span class="s2">); Did you &quot;</span>
                        <span class="s2">&quot;try to create a model component named &#39;_component&#39;?&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
                    <span class="p">)</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">_BlockData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="c1">#</span>
            <span class="c1"># At this point, we should only be seeing non-component data</span>
            <span class="c1"># the user is hanging on the blocks (uncommon) or the</span>
            <span class="c1"># initial setup of the object data (in __init__).</span>
            <span class="c1">#</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Component</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Reassigning the non-component attribute </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;on block (model).</span><span class="si">%s</span><span class="s2"> with a new Component</span><span class="se">\n</span><span class="s2">with type </span><span class="si">%s</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;This is usually indicative of a modelling error.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;To avoid this warning, explicitly delete the attribute:</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;    del </span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">_BlockData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete an attribute on this Block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#</span>
        <span class="c1"># It is important that we call del_component() whenever a</span>
        <span class="c1"># component is removed from a block.  Defining __delattr__</span>
        <span class="c1"># catches the case when a user attempts to remove components</span>
        <span class="c1"># using, e.g. &quot;del model.myParam&quot;</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl</span><span class="p">:</span>
            <span class="c1">#</span>
            <span class="c1"># The attribute exists and it is a component in the</span>
            <span class="c1"># list of declarations in this block.</span>
            <span class="c1">#</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">del_component</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#</span>
            <span class="c1"># Other Python objects are removed with the standard __detattr__</span>
            <span class="c1"># method.</span>
            <span class="c1">#</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">_BlockData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__delattr__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compact_decl_storage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">idxMap</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">_new_decl_order</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Squeeze out the None entries</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">idxMap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">_new_decl_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
        <span class="c1"># Update the _decl map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decl</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">idxMap</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="c1"># Update the ctypes, _decl_order linked lists</span>
        <span class="k">for</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">last</span> <span class="o">=</span> <span class="n">idxMap</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">this</span> <span class="o">=</span> <span class="n">idxMap</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">_new_decl_order</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">_new_decl_order</span><span class="p">[</span><span class="n">last</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">this</span><span class="p">)</span>
                    <span class="n">last</span> <span class="o">=</span> <span class="n">this</span>
            <span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">last</span>
            <span class="n">_new_decl_order</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">_new_decl_order</span><span class="p">[</span><span class="n">last</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span> <span class="o">=</span> <span class="n">_new_decl_order</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Block components do not support assignment or set_value().</span>
<span class="sd">                Use the transfer_attributes_from() method to transfer the</span>
<span class="sd">                components and public attributes from one block to another:</span>
<span class="sd">                    model.b[1].transfer_attributes_from(other_block)</span>
<span class="sd">                &quot;&quot;&quot;</span>
            <span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_map</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Block_reserved_words</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">del_component</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Block_reserved_words</span><span class="p">:</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compact_decl_storage</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">transfer_attributes_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transfer user-defined attributes from src to this block</span>

<span class="sd">        This transfers all components and user-defined attributes from</span>
<span class="sd">        the block or dictionary `src` and places them on this Block.</span>
<span class="sd">        Components are transferred in declaration order.</span>

<span class="sd">        If a Component on `src` is also declared on this block as either</span>
<span class="sd">        a Component or attribute, the local Component or attribute is</span>
<span class="sd">        replaced by the incoming component.  If an attribute name on</span>
<span class="sd">        `src` matches a Component declared on this block, then the</span>
<span class="sd">        incoming attribute is passed to the local Component&#39;s</span>
<span class="sd">        `set_value()` method.  Attribute names appearing in this block&#39;s</span>
<span class="sd">        `_Block_reserved_words` set will not be transferred (although</span>
<span class="sd">        Components will be).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src: _BlockData or dict</span>
<span class="sd">            The Block or mapping that contains the new attributes to</span>
<span class="sd">            assign to this block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">_BlockData</span><span class="p">):</span>
            <span class="c1"># There is a special case where assigning a parent block to</span>
            <span class="c1"># this block creates a circular hierarchy</span>
            <span class="k">if</span> <span class="n">src</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">p_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span>
            <span class="k">while</span> <span class="n">p_block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p_block</span> <span class="ow">is</span> <span class="n">src</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;_BlockData.transfer_attributes_from(): Cannot set a &quot;</span>
                        <span class="s2">&quot;sub-block (</span><span class="si">%s</span><span class="s2">) to a parent block (</span><span class="si">%s</span><span class="s2">): creates a &quot;</span>
                        <span class="s2">&quot;circular hierarchy&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">p_block</span> <span class="o">=</span> <span class="n">p_block</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span>
            <span class="c1"># record the components and the non-component objects added</span>
            <span class="c1"># to the block</span>
            <span class="n">src_comp_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">component_map</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="n">src_raw_dict</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="vm">__dict__</span>
            <span class="n">del_src_comp</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">del_component</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="n">src_comp_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Component</span><span class="p">)}</span>
            <span class="n">src_raw_dict</span> <span class="o">=</span> <span class="n">src</span>
            <span class="n">del_src_comp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;_BlockData.transfer_attributes_from(): expected a &quot;</span>
                <span class="s2">&quot;Block or dict; received </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">src</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">src_comp_map</span><span class="p">:</span>
            <span class="c1"># Filter out any components from src</span>
            <span class="n">src_raw_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">src_raw_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">src_comp_map</span>
            <span class="p">}</span>

        <span class="c1"># Use component_map for the components to preserve decl_order</span>
        <span class="c1"># Note that we will move any reserved components over as well as</span>
        <span class="c1"># any user-defined components.  There is a bit of trust here</span>
        <span class="c1"># that the user knows what they are doing.</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_declare_reserved_components</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">src_comp_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">del_component</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">del_src_comp</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="c1"># Because Blocks are not slotized and we allow the</span>
        <span class="c1"># assignment of arbitrary data to Blocks, we will move over</span>
        <span class="c1"># any other unrecognized entries in the object&#39;s __dict__:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">src_raw_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Block_reserved_words</span>  <span class="c1"># user-defined</span>
                <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>  <span class="c1"># reserved, but not present</span>
                <span class="ow">or</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl</span>  <span class="c1"># reserved, but a component and the</span>
                <span class="c1"># incoming thing is data (attempt to</span>
                <span class="c1"># set the value)</span>
            <span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_implicit_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;TODO: This method has known issues (see tickets) and needs to be</span>
<span class="sd">        reviewed. [JDS 9/2014]&quot;&quot;&quot;</span>

        <span class="n">_component_sets</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s1">&#39;_implicit_subsets&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># FIXME: The name attribute should begin with &quot;_&quot;, and None</span>
        <span class="c1"># should replace &quot;_unknown_&quot;</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">_component_sets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ctr</span><span class="p">,</span> <span class="n">tset</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_component_sets</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">tset</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">tset</span><span class="o">.</span><span class="n">parent_component</span><span class="p">(),</span> <span class="n">GlobalSetBase</span>
                <span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_index_</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">local_name</span><span class="p">,</span> <span class="n">ctr</span><span class="p">),</span> <span class="n">tset</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s1">&#39;_index_set&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">_index_set</span><span class="p">,</span> <span class="n">_SetDataBase</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">val</span><span class="o">.</span><span class="n">_index_set</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">_index_set</span><span class="o">.</span><span class="n">parent_component</span><span class="p">(),</span> <span class="n">GlobalSetBase</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_index&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">local_name</span><span class="p">,),</span> <span class="n">val</span><span class="o">.</span><span class="n">_index_set</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s1">&#39;initialize&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">initialize</span><span class="p">,</span> <span class="n">_SetDataBase</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">val</span><span class="o">.</span><span class="n">initialize</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">initialize</span><span class="o">.</span><span class="n">parent_component</span><span class="p">(),</span> <span class="n">GlobalSetBase</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_index_init&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">local_name</span><span class="p">,),</span> <span class="n">val</span><span class="o">.</span><span class="n">initialize</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s1">&#39;domain&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">_SetDataBase</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">val</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">GlobalSetBase</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_domain&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">local_name</span><span class="p">,),</span> <span class="n">val</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">collect_ctypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">descend_into</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count all component types stored on or under this</span>
<span class="sd">        block.</span>

<span class="sd">        Args:</span>
<span class="sd">            active (True/None): Set to True to indicate that</span>
<span class="sd">                only active components should be</span>
<span class="sd">                counted. The default value of None indicates</span>
<span class="sd">                that all components (including those that</span>
<span class="sd">                have been deactivated) should be counted.</span>
<span class="sd">            descend_into (bool): Indicates whether or not</span>
<span class="sd">                component types should be counted on</span>
<span class="sd">                sub-blocks. Default is True.</span>

<span class="sd">        Returns: A set of component types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">active</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">ctypes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_data_objects</span><span class="p">(</span>
            <span class="n">active</span><span class="o">=</span><span class="n">active</span><span class="p">,</span> <span class="n">descend_into</span><span class="o">=</span><span class="n">descend_into</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">SortComponents</span><span class="o">.</span><span class="n">unsorted</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">active</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ctypes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">active</span> <span class="ow">is</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">ctype</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">component_data_objects</span><span class="p">(</span>
                        <span class="n">ctype</span><span class="o">=</span><span class="n">ctype</span><span class="p">,</span>
                        <span class="n">active</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">descend_into</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">sort</span><span class="o">=</span><span class="n">SortComponents</span><span class="o">.</span><span class="n">unsorted</span><span class="p">,</span>
                    <span class="p">):</span>
                        <span class="c1"># We only need to verify that there is at least</span>
                        <span class="c1"># one active data member</span>
                        <span class="n">ctypes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ctype</span><span class="p">)</span>
                        <span class="k">break</span>
        <span class="k">return</span> <span class="n">ctypes</span>

    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#</span>
        <span class="c1"># Special case: the &quot;Model&quot; is always the top-level _BlockData,</span>
        <span class="c1"># so if this is the top-level block, it must be the model</span>
        <span class="c1">#</span>
        <span class="c1"># Also note the interesting and intentional characteristic for</span>
        <span class="c1"># an IndexedBlock that is not attached to anything:</span>
        <span class="c1">#   b = Block([1,2,3])</span>
        <span class="c1">#   b.model() is None</span>
        <span class="c1">#   b[1].model() is b[1]</span>
        <span class="c1">#   b[2].model() is b[2]</span>
        <span class="c1">#</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="c1">#</span>
        <span class="c1"># NOTE: This loop is probably OK, since</span>
        <span class="c1">#   1) most models won&#39;t be nested very deep and</span>
        <span class="c1">#   2) it is better than forcing everyone to maintain references</span>
        <span class="c1">#      to the top-level block from both the standpoint of memory</span>
        <span class="c1">#      use and update time).</span>
        <span class="c1">#</span>
        <span class="nb">next</span> <span class="o">=</span> <span class="n">ans</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span>
        <span class="k">while</span> <span class="nb">next</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nb">next</span>
            <span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ans</span>

    <span class="k">def</span> <span class="nf">find_component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_or_component</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a component in the block given a name.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label_or_component : str, Component, or ComponentUID</span>
<span class="sd">            The name of the component to find in this block. String or</span>
<span class="sd">            Component arguments are first converted to ComponentUID.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Component</span>
<span class="sd">            Component on the block identified by the ComponentUID. If</span>
<span class="sd">            a matching component is not found, None is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">label_or_component</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ComponentUID</span><span class="p">:</span>
            <span class="n">cuid</span> <span class="o">=</span> <span class="n">label_or_component</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cuid</span> <span class="o">=</span> <span class="n">ComponentUID</span><span class="p">(</span><span class="n">label_or_component</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cuid</span><span class="o">.</span><span class="n">find_component_on</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">_declare_reserved_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Temporarily mask the class reserved words like with a local</span>
        <span class="c1"># instance attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Block_reserved_words</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">yield</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Block_reserved_words</span>

    <span class="k">def</span> <span class="nf">add_component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a component &#39;name&#39; to the block.</span>

<span class="sd">        This method assumes that the attribute is not in the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#</span>
        <span class="c1"># Error checks</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">val</span><span class="o">.</span><span class="n">valid_model_component</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot add &#39;</span><span class="si">%s</span><span class="s2">&#39; as a component to a block&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Block_reserved_words</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Attempting to declare a block component using &quot;</span>
                <span class="s2">&quot;the name of a reserved attribute:</span><span class="se">\n\t</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot add component &#39;</span><span class="si">%s</span><span class="s2">&#39; (type </span><span class="si">%s</span><span class="s2">) to block &#39;</span><span class="si">%s</span><span class="s2">&#39;: a &quot;</span>
                <span class="s2">&quot;component by that name (type </span><span class="si">%s</span><span class="s2">) is already defined.&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)))</span>
            <span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># Skip the add_component() logic if this is a</span>
        <span class="c1"># component type that is suppressed.</span>
        <span class="c1">#</span>
        <span class="n">_component</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span>
        <span class="n">_type</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">ctype</span>
        <span class="k">if</span> <span class="n">_type</span> <span class="ow">in</span> <span class="n">_component</span><span class="o">.</span><span class="n">_suppress_ctypes</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1">#</span>
        <span class="c1"># Raise an exception if the component already has a parent.</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">_parent</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">_parent</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Attempting to re-assign the component &#39;</span><span class="si">%s</span><span class="s2">&#39; to the same</span>
<span class="s2">block under a different name (</span><span class="si">%s</span><span class="s2">).&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">val</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">name</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Re-assigning the component &#39;</span><span class="si">%s</span><span class="s2">&#39; from block &#39;</span><span class="si">%s</span><span class="s2">&#39; to</span>
<span class="s2">block &#39;</span><span class="si">%s</span><span class="s2">&#39; as &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">val</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span>
                    <span class="n">val</span><span class="o">.</span><span class="n">_parent</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">name</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sd">&quot;&quot;&quot;%s</span>

<span class="sd">This behavior is not supported by Pyomo; components must have a</span>
<span class="sd">single owning block (or model), and a component may not appear</span>
<span class="sd">multiple times in a block.  If you want to re-name or move this</span>
<span class="sd">component, use the block del_component() and add_component() methods.</span>
<span class="sd">&quot;&quot;&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">strip</span><span class="p">(),)</span>
            <span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># If the new component is a Block, then there is the chance that</span>
        <span class="c1"># it is the model(), and assigning it would create a circular</span>
        <span class="c1"># hierarchy.  Note that we only have to check the model as the</span>
        <span class="c1"># check immediately above would catch any &quot;internal&quot; blocks in</span>
        <span class="c1"># the block hierarchy</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Block</span><span class="p">)</span> <span class="ow">and</span> <span class="n">val</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot assign the top-level block as a subblock of one of &quot;</span>
                <span class="s2">&quot;its children (</span><span class="si">%s</span><span class="s2">): creates a circular hierarchy&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span>
            <span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># Set the name and parent pointer of this component.</span>
        <span class="c1">#</span>
        <span class="n">val</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">val</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="c1">#</span>
        <span class="c1"># We want to add the temporary / implicit sets first so that</span>
        <span class="c1"># they get constructed before this component</span>
        <span class="c1">#</span>
        <span class="c1"># FIXME: This is sloppy and wasteful (most components trigger</span>
        <span class="c1"># this, even when there is no need for it).  We should</span>
        <span class="c1"># reconsider the whole _implicit_subsets logic to defer this</span>
        <span class="c1"># kind of thing to an &quot;update_parent()&quot; method on the</span>
        <span class="c1"># components.</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_implicit_sets</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># Add the component to the underlying Component store</span>
        <span class="c1">#</span>
        <span class="n">_new_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decl</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_new_idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">val</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="c1">#</span>
        <span class="c1"># Add the component as an attribute.  Note that</span>
        <span class="c1">#</span>
        <span class="c1">#     self.__dict__[name]=val</span>
        <span class="c1">#</span>
        <span class="c1"># is inappropriate here.  The correct way to add the attribute</span>
        <span class="c1"># is to delegate the work to the next class up the MRO.</span>
        <span class="c1">#</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_BlockData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># Update the ctype linked lists</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">:</span>
            <span class="n">idx_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">_type</span><span class="p">]</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">idx_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">tmp</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">_new_idx</span><span class="p">)</span>
            <span class="n">idx_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_new_idx</span>
            <span class="n">idx_info</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">_new_idx</span><span class="p">,</span> <span class="n">_new_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1">#</span>
        <span class="c1"># Propagate properties to sub-blocks:</span>
        <span class="c1">#   suppressed ctypes</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">_type</span> <span class="ow">is</span> <span class="n">Block</span><span class="p">:</span>
            <span class="n">val</span><span class="o">.</span><span class="n">_suppress_ctypes</span> <span class="o">|=</span> <span class="n">_component</span><span class="o">.</span><span class="n">_suppress_ctypes</span>
        <span class="c1">#</span>
        <span class="c1"># Error, for disabled support implicit rule names</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="s1">&#39;_rule&#39;</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="vm">__dict__</span> <span class="ow">and</span> <span class="n">val</span><span class="o">.</span><span class="n">_rule</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_test</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">local_name</span> <span class="o">+</span> <span class="s1">&#39;_rule&#39;</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">frame</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">_found</span> <span class="o">|=</span> <span class="n">_test</span> <span class="ow">in</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_locals</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">if</span> <span class="n">_found</span><span class="p">:</span>
                <span class="c1"># JDS: Do not blindly reformat this message.  The</span>
                <span class="c1"># formatter inserts arbitrarily-long names(), which can</span>
                <span class="c1"># cause the resulting logged message to be very poorly</span>
                <span class="c1"># formatted due to long lines.</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sd">&quot;&quot;&quot;As of Pyomo 4.0, Pyomo components no longer support implicit rules.</span>
<span class="sd">You defined a component (%s) that appears</span>
<span class="sd">to rely on an implicit rule (%s).</span>
<span class="sd">Components must now specify their rules explicitly using &#39;rule=&#39; keywords.&quot;&quot;&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">_test</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># Don&#39;t reconstruct if this component has already been constructed.</span>
        <span class="c1"># This allows a user to move a component from one block to</span>
        <span class="c1"># another.</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">_constructed</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1">#</span>
        <span class="c1"># If the block is Concrete, construct the component</span>
        <span class="c1"># Note: we are explicitly using getattr because (Scalar)</span>
        <span class="c1">#   classes that derive from Block may want to declare components</span>
        <span class="c1">#   within their __init__() [notably, pyomo.gdp&#39;s Disjunct).</span>
        <span class="c1">#   Those components are added *before* the _constructed flag is</span>
        <span class="c1">#   added to the class by Block.__init__()</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_component</span><span class="p">,</span> <span class="s1">&#39;_constructed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># NB: we don&#39;t have to construct the temporary / implicit</span>
            <span class="c1"># sets here: if necessary, that happens when</span>
            <span class="c1"># _add_implicit_sets() calls add_component().</span>
            <span class="k">if</span> <span class="n">_BlockConstruction</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">_BlockConstruction</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">generate_debug_messages</span> <span class="o">=</span> <span class="n">is_debug_set</span><span class="p">(</span><span class="n">logger</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">generate_debug_messages</span><span class="p">:</span>
                <span class="c1"># This is tricky: If we are in the middle of</span>
                <span class="c1"># constructing an indexed block, the block component</span>
                <span class="c1"># already has _constructed=True.  Now, if the</span>
                <span class="c1"># _BlockData.__init__() defines any local variables</span>
                <span class="c1"># (like pyomo.gdp.Disjunct&#39;s indicator_var), name(True)</span>
                <span class="c1"># will fail: this block data exists and has a parent(),</span>
                <span class="c1"># but it has not yet been added to the parent&#39;s _data</span>
                <span class="c1"># (so the idx lookup will fail in name).</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">_blockName</span> <span class="o">=</span> <span class="s2">&quot;[Model]&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">_blockName</span> <span class="o">=</span> <span class="s2">&quot;Block &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">_blockName</span> <span class="o">=</span> <span class="s2">&quot;Block &#39;</span><span class="si">%s</span><span class="s2">[...]&#39;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;Constructing </span><span class="si">%s</span><span class="s2"> &#39;</span><span class="si">%s</span><span class="s2">&#39; on </span><span class="si">%s</span><span class="s2"> from data=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">val</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="n">name</span><span class="p">,</span>
                    <span class="n">_blockName</span><span class="p">,</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">val</span><span class="o">.</span><span class="n">construct</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;Constructing component &#39;</span><span class="si">%s</span><span class="s2">&#39; from data=</span><span class="si">%s</span><span class="s2"> failed:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="n">err</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">raise</span>
            <span class="k">if</span> <span class="n">generate_debug_messages</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_blockName</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">:</span>
                    <span class="n">_blockName</span> <span class="o">=</span> <span class="n">_blockName</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_blockName</span> <span class="o">=</span> <span class="s2">&quot;&#39;&quot;</span> <span class="o">+</span> <span class="n">_blockName</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span>
                <span class="n">_out</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
                <span class="n">val</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">ostream</span><span class="o">=</span><span class="n">_out</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;Constructed component &#39;</span><span class="si">%s</span><span class="s2">&#39;:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">_blockName</span><span class="p">,</span> <span class="n">_out</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">del_component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete a component from this block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">name_or_object</span><span class="p">)</span>
        <span class="c1"># FIXME: Is this necessary?  Should this raise an exception?</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># FIXME: Is this necessary?  Should this raise an exception?</span>
        <span class="c1"># if name not in self._decl:</span>
        <span class="c1">#    return</span>

        <span class="n">name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">local_name</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Block_reserved_words</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Attempting to delete a reserved block component:</span><span class="se">\n\t</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
            <span class="p">)</span>

        <span class="c1"># Replace the component in the master list with a None placeholder</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Update the ctype linked lists</span>
        <span class="n">ctype_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">ctype</span><span class="p">]</span>
        <span class="n">ctype_info</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">ctype_info</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">ctype</span><span class="p">]</span>

        <span class="c1"># Clear the _parent attribute</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Now that this component is not in the _decl map, we can call</span>
        <span class="c1"># delattr as usual.</span>
        <span class="c1">#</span>
        <span class="c1"># del self.__dict__[name]</span>
        <span class="c1">#</span>
        <span class="c1"># Note: &#39;del self.__dict__[name]&#39; is inappropriate here.  The</span>
        <span class="c1"># correct way to add the attribute is to delegate the work to</span>
        <span class="c1"># the next class up the MRO.</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_BlockData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__delattr__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reclassify_component_type</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name_or_object</span><span class="p">,</span> <span class="n">new_ctype</span><span class="p">,</span> <span class="n">preserve_declaration_order</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">name_or_object</span><span class="p">)</span>
        <span class="c1"># FIXME: Is this necessary?  Should this raise an exception?</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">ctype</span> <span class="ow">is</span> <span class="n">new_ctype</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">local_name</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">preserve_declaration_order</span><span class="p">:</span>
            <span class="c1"># if we don&#39;t have to preserve the decl order, then the</span>
            <span class="c1"># easiest (and fastest) thing to do is just delete it and</span>
            <span class="c1"># re-add it.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">del_component</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_ctype</span> <span class="o">=</span> <span class="n">new_ctype</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="c1"># Update the ctype linked lists</span>
        <span class="n">ctype_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">ctype</span><span class="p">]</span>
        <span class="n">ctype_info</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">ctype_info</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">ctype</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">ctype_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">idx</span><span class="p">:</span>
            <span class="n">ctype_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">ctype</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">idx</span><span class="p">:</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">tmp</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">tmp</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">prev</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">prev</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">ctype_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">idx</span><span class="p">:</span>
                <span class="n">ctype_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev</span>

        <span class="n">obj</span><span class="o">.</span><span class="n">_ctype</span> <span class="o">=</span> <span class="n">new_ctype</span>

        <span class="c1"># Insert into the new ctype list</span>
        <span class="k">if</span> <span class="n">new_ctype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">new_ctype</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">new_ctype</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">new_ctype</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">new_ctype</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">new_ctype</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">new_ctype</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">new_ctype</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">prev</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">prev</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">new_ctype</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">new_ctype</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">new_ctype</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">new_ctype</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">idx</span><span class="p">:</span>
                <span class="c1"># this test should be unnecessary: and tmp is not None:</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">tmp</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">tmp</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">prev</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">prev</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># FYI: we used to remove all _parent() weakrefs before</span>
        <span class="c1"># deepcopying and then restore them on the original and cloned</span>
        <span class="c1"># model.  It turns out that this was completely unnecessary and</span>
        <span class="c1"># wasteful.</span>
        <span class="c1">#</span>
        <span class="c1"># Note: Setting __block_scope__ determines which components are</span>
        <span class="c1"># deepcopied (anything beneath this block) and which are simply</span>
        <span class="c1"># preserved as references (anything outside this block</span>
        <span class="c1"># hierarchy).  We must always go through this effort to prevent</span>
        <span class="c1"># copying certain &quot;reserved&quot; components (like Any,</span>
        <span class="c1"># NonNegativeReals, etc) that are not &quot;owned&quot; by any blocks and</span>
        <span class="c1"># should be preserved as singletons.</span>
        <span class="c1">#</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pc</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">pc</span>

        <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">memo</span><span class="p">[</span><span class="s1">&#39;__block_scope__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="kc">True</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span> <span class="kc">False</span><span class="p">}</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">parent</span><span class="p">)]</span> <span class="o">=</span> <span class="n">parent</span>

        <span class="k">with</span> <span class="n">PauseGC</span><span class="p">():</span>
            <span class="n">new_block</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>

        <span class="c1"># We need to &quot;detangle&quot; the new block from the original block</span>
        <span class="c1"># hierarchy</span>
        <span class="k">if</span> <span class="n">pc</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">new_block</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_block</span><span class="o">.</span><span class="n">_component</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">new_block</span>

    <span class="k">def</span> <span class="nf">contains_component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the component type is in _ctypes and ... TODO.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ctype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">[</span><span class="n">ctype</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a child component of this block.</span>

<span class="sd">        If passed a string, this will return the child component</span>
<span class="sd">        registered by that name.  If passed a component, this will</span>
<span class="sd">        return that component IFF the component is a child of this</span>
<span class="sd">        block. Returns None on lookup failure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_object</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name_or_object</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_decl</span><span class="p">[</span><span class="n">name_or_object</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">name_or_object</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">obj</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">component_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a PseudoMap of the components in this block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ctype:  None or type or iterable</span>
<span class="sd">            Specifies the component types (`ctypes`) to include in the</span>
<span class="sd">            resulting PseudoMap</span>

<span class="sd">                =============   ===================================</span>
<span class="sd">                None            All components</span>
<span class="sd">                type            A single component type</span>
<span class="sd">                iterable        All component types in the iterable</span>
<span class="sd">                =============   ===================================</span>

<span class="sd">        active: None or bool</span>
<span class="sd">            Filter components by the active flag</span>

<span class="sd">                =====  ===============================</span>
<span class="sd">                None   Return all components</span>
<span class="sd">                True   Return only active components</span>
<span class="sd">                False  Return only inactive components</span>
<span class="sd">                =====  ===============================</span>

<span class="sd">        sort: bool</span>
<span class="sd">            Iterate over the components in a sorted order</span>

<span class="sd">                =====  ================================================</span>
<span class="sd">                True   Iterate using Block.alphabetizeComponentAndIndex</span>
<span class="sd">                False  Iterate using Block.declarationOrder</span>
<span class="sd">                =====  ================================================</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">PseudoMap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_component_typemap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return information about the block components.</span>

<span class="sd">        If ctype is None, return a dictionary that maps</span>
<span class="sd">           {component type -&gt; {name -&gt; component instance}}</span>
<span class="sd">        Otherwise, return a dictionary that maps</span>
<span class="sd">           {name -&gt; component instance}</span>
<span class="sd">        for the specified component type.</span>

<span class="sd">        Note: The actual {name-&gt;instance} object is a PseudoMap that</span>
<span class="sd">        implements a lightweight interface to the underlying</span>
<span class="sd">        BlockComponents data structures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ctype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">:</span>
                <span class="n">ans</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">PseudoMap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ans</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PseudoMap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_component_data_iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">dedup</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the name, index, and component data for matching ctypes</span>

<span class="sd">        Generator that returns a nested 2-tuple of</span>

<span class="sd">            ((component name, index value), _ComponentData)</span>

<span class="sd">        for every component data in the block matching the specified</span>
<span class="sd">        ctype(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ctype:  None or type or iterable</span>
<span class="sd">            Specifies the component types (`ctypes`) to include</span>

<span class="sd">        active: None or bool</span>
<span class="sd">            Filter components by the active flag</span>

<span class="sd">        sort: None or bool or SortComponents</span>
<span class="sd">            Iterate over the components in a specified sorted order</span>

<span class="sd">        dedup: _DeduplicateInfo</span>
<span class="sd">            Deduplicator to prevent returning the same _ComponentData twice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_sort_indices</span> <span class="o">=</span> <span class="n">SortComponents</span><span class="o">.</span><span class="n">sort_indices</span><span class="p">(</span><span class="n">sort</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">PseudoMap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># NOTE: Suffix has a dict interface (something other derived</span>
            <span class="c1">#   non-indexed Components may do as well), so we don&#39;t want</span>
            <span class="c1">#   to test the existence of iteritems as a check for</span>
            <span class="c1">#   component datas. We will rely on is_indexed() to catch</span>
            <span class="c1">#   all the indexed components.  Then we will do special</span>
            <span class="c1">#   processing for the scalar components to catch the case</span>
            <span class="c1">#   where there are &quot;sparse scalar components&quot;</span>
            <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
                <span class="n">_items</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">_sort_indices</span><span class="p">:</span>
                    <span class="n">_items</span> <span class="o">=</span> <span class="n">sorted_robust</span><span class="p">(</span><span class="n">_items</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="s1">&#39;_data&#39;</span><span class="p">):</span>
                <span class="c1"># This is a Scalar component, which may be empty (e.g.,</span>
                <span class="c1"># from Constraint.Skip on a scalar Constraint).  Only</span>
                <span class="c1"># return a ComponentData if one officially exists.</span>
                <span class="c1"># Sorting is not a concern as this component has either</span>
                <span class="c1"># 0 or 1 datas</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span>
                <span class="n">_items</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This is a non-IndexedComponent Component.  Return it.</span>
                <span class="n">_items</span> <span class="o">=</span> <span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="n">comp</span><span class="p">),)</span>

            <span class="k">if</span> <span class="n">active</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">ActiveIndexedComponent</span><span class="p">):</span>
                <span class="n">_items</span> <span class="o">=</span> <span class="p">(((</span><span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="n">compData</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">compData</span> <span class="ow">in</span> <span class="n">_items</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_items</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="n">compData</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">compData</span> <span class="ow">in</span> <span class="n">_items</span>
                    <span class="k">if</span> <span class="n">compData</span><span class="o">.</span><span class="n">active</span> <span class="o">==</span> <span class="n">active</span>
                <span class="p">)</span>

            <span class="k">yield from</span> <span class="n">dedup</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">_items</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_component_data_itervalues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">dedup</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generator that returns the _ComponentData for every component data</span>
<span class="sd">        in the block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ctype:  None or type or iterable</span>
<span class="sd">            Specifies the component types (`ctypes`) to include</span>

<span class="sd">        active: None or bool</span>
<span class="sd">            Filter components by the active flag</span>

<span class="sd">        sort: None or bool or SortComponents</span>
<span class="sd">            Iterate over the components in a specified sorted order</span>

<span class="sd">        dedup: _DeduplicateInfo</span>
<span class="sd">            Deduplicator to prevent returning the same _ComponentData twice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">SortComponents</span><span class="o">.</span><span class="n">sort_indices</span><span class="p">(</span><span class="n">sort</span><span class="p">):</span>
            <span class="c1"># We need the indices so that we can correctly sort.  Fall</span>
            <span class="c1"># back on _component_data_iteritems.</span>
            <span class="k">yield from</span> <span class="nb">map</span><span class="p">(</span>
                <span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_component_data_iteritems</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">dedup</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">PseudoMap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c1"># NOTE: Suffix has a dict interface (something other derived</span>
            <span class="c1">#   non-indexed Components may do as well), so we don&#39;t want</span>
            <span class="c1">#   to test the existence of iteritems as a check for</span>
            <span class="c1">#   component datas. We will rely on is_indexed() to catch</span>
            <span class="c1">#   all the indexed components.  Then we will do special</span>
            <span class="c1">#   processing for the scalar components to catch the case</span>
            <span class="c1">#   where there are &quot;sparse scalar components&quot;</span>
            <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
                <span class="n">_values</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="s1">&#39;_data&#39;</span><span class="p">):</span>
                <span class="c1"># This is a Scalar component, which may be empty (e.g.,</span>
                <span class="c1"># from Constraint.Skip on a scalar Constraint).  Only</span>
                <span class="c1"># return a ComponentData if one officially exists.</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span>
                <span class="n">_values</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This is a non-IndexedComponent Component.  Return it.</span>
                <span class="n">_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">comp</span><span class="p">,)</span>

            <span class="k">if</span> <span class="n">active</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">ActiveIndexedComponent</span><span class="p">):</span>
                <span class="n">_values</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">cDat</span><span class="p">:</span> <span class="n">cDat</span><span class="o">.</span><span class="n">active</span> <span class="o">==</span> <span class="n">active</span><span class="p">,</span> <span class="n">_values</span><span class="p">)</span>

            <span class="k">yield from</span> <span class="n">dedup</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">_values</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;The all_components method is deprecated.  &quot;</span>
        <span class="s2">&quot;Use the Block.component_objects() method.&quot;</span><span class="p">,</span>
        <span class="n">version</span><span class="o">=</span><span class="s2">&quot;4.1.10486&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">all_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_objects</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;The active_components method is deprecated.  &quot;</span>
        <span class="s2">&quot;Use the Block.component_objects() method.&quot;</span><span class="p">,</span>
        <span class="n">version</span><span class="o">=</span><span class="s2">&quot;4.1.10486&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">active_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;active&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_objects</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;The all_component_data method is deprecated.  &quot;</span>
        <span class="s2">&quot;Use the Block.component_data_objects() method.&quot;</span><span class="p">,</span>
        <span class="n">version</span><span class="o">=</span><span class="s2">&quot;4.1.10486&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">all_component_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_data_objects</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;The active_component_data method is deprecated.  &quot;</span>
        <span class="s2">&quot;Use the Block.component_data_objects() method.&quot;</span><span class="p">,</span>
        <span class="n">version</span><span class="o">=</span><span class="s2">&quot;4.1.10486&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">active_component_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;active&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_data_objects</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">component_objects</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ctype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">descend_into</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">descent_order</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a generator that iterates through the</span>
<span class="sd">        component objects in a block.  By default, the</span>
<span class="sd">        generator recursively descends into sub-blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">_block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_data_objects</span><span class="p">(</span>
            <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">descend_into</span><span class="p">,</span> <span class="n">descent_order</span>
        <span class="p">):</span>
            <span class="k">yield from</span> <span class="n">_block</span><span class="o">.</span><span class="n">component_map</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">component_data_objects</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ctype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">descend_into</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">descent_order</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a generator that iterates through the</span>
<span class="sd">        component data objects for all components in a</span>
<span class="sd">        block.  By default, this generator recursively</span>
<span class="sd">        descends into sub-blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dedup</span> <span class="o">=</span> <span class="n">_DeduplicateInfo</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_data_objects</span><span class="p">(</span>
            <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">descend_into</span><span class="p">,</span> <span class="n">descent_order</span>
        <span class="p">):</span>
            <span class="k">yield from</span> <span class="n">_block</span><span class="o">.</span><span class="n">_component_data_itervalues</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">dedup</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">component_data_iterindex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ctype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">descend_into</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">descent_order</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a generator that returns a tuple for each</span>
<span class="sd">        component data object in a block.  By default, this</span>
<span class="sd">        generator recursively descends into sub-blocks.  The</span>
<span class="sd">        tuple is</span>

<span class="sd">            ((component name, index value), _ComponentData)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dedup</span> <span class="o">=</span> <span class="n">_DeduplicateInfo</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_data_objects</span><span class="p">(</span>
            <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">descend_into</span><span class="p">,</span> <span class="n">descent_order</span>
        <span class="p">):</span>
            <span class="k">yield from</span> <span class="n">_block</span><span class="o">.</span><span class="n">_component_data_iteritems</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">dedup</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;The all_blocks method is deprecated.  &quot;</span>
        <span class="s2">&quot;Use the Block.block_data_objects() method.&quot;</span><span class="p">,</span>
        <span class="n">version</span><span class="o">=</span><span class="s2">&quot;4.1.10486&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">all_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_data_objects</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;The active_blocks method is deprecated.  &quot;</span>
        <span class="s2">&quot;Use the Block.block_data_objects() method.&quot;</span><span class="p">,</span>
        <span class="n">version</span><span class="o">=</span><span class="s2">&quot;4.1.10486&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">active_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;active&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_data_objects</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">block_data_objects</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">descend_into</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">descent_order</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generator returning this block and any matching sub-blocks.</span>

<span class="sd">        This is roughly equivalent to</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            iter(block for block in itertools.chain(</span>
<span class="sd">                 [self], self.component_data_objects(descend_into, ...))</span>
<span class="sd">                 if block.active == active)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The `self` block is *always* returned, regardless of the types</span>
<span class="sd">        indicated by `descend_into`.</span>

<span class="sd">        The active flag is enforced on *all* blocks, including `self`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        active: None or bool</span>
<span class="sd">            If not None, filter components by the active flag</span>

<span class="sd">        sort: None or bool or SortComponents</span>
<span class="sd">            Iterate over the components in a specified sorted order</span>

<span class="sd">        descend_into:  None or type or iterable</span>
<span class="sd">            Specifies the component types (`ctypes`) to return and to</span>
<span class="sd">            descend into.  If `True` or `None`, defaults to `(Block,)`.</span>
<span class="sd">            If `False`, only `self` is returned.</span>

<span class="sd">        descent_order: None or TraversalStrategy</span>
<span class="sd">            The strategy used to walk the block hierarchy.  Defaults to</span>
<span class="sd">            `TraversalStrategy.PrefixDepthFirstSearch`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: we should determine if that is desirable behavior(it is</span>
        <span class="c1"># historical, so there are backwards compatibility arguments to</span>
        <span class="c1"># not change it, but because of block_data_objects() use in</span>
        <span class="c1"># component_data_objects, it might be desirable to always return</span>
        <span class="c1"># self.</span>
        <span class="k">if</span> <span class="n">active</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span> <span class="o">!=</span> <span class="n">active</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">descend_into</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">descend_into</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">ctype</span> <span class="o">=</span> <span class="p">(</span><span class="n">Block</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="n">isclass</span><span class="p">(</span><span class="n">descend_into</span><span class="p">):</span>
            <span class="n">ctype</span> <span class="o">=</span> <span class="p">(</span><span class="n">descend_into</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ctype</span> <span class="o">=</span> <span class="n">descend_into</span>
        <span class="n">dedup</span> <span class="o">=</span> <span class="n">_DeduplicateInfo</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">descent_order</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="n">descent_order</span> <span class="o">==</span> <span class="n">TraversalStrategy</span><span class="o">.</span><span class="n">PrefixDepthFirstSearch</span>
        <span class="p">):</span>
            <span class="n">walker</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prefix_dfs_iterator</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">dedup</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">descent_order</span> <span class="o">==</span> <span class="n">TraversalStrategy</span><span class="o">.</span><span class="n">BreadthFirstSearch</span><span class="p">:</span>
            <span class="n">walker</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bfs_iterator</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">dedup</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">descent_order</span> <span class="o">==</span> <span class="n">TraversalStrategy</span><span class="o">.</span><span class="n">PostfixDepthFirstSearch</span><span class="p">:</span>
            <span class="n">walker</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_postfix_dfs_iterator</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">dedup</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;unrecognized traversal strategy: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">descent_order</span><span class="p">,))</span>
        <span class="k">yield from</span> <span class="n">walker</span>

    <span class="k">def</span> <span class="nf">_prefix_dfs_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">dedup</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function implementing a non-recursive prefix order</span>
<span class="sd">        depth-first search.  That is, the parent is returned before its</span>
<span class="sd">        children.</span>

<span class="sd">        Note: this method assumes it is called ONLY by the _tree_iterator</span>
<span class="sd">        method, which centralizes certain error checking and</span>
<span class="sd">        preliminaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We will unconditionally return self, so preemptively add it to</span>
        <span class="c1"># the list of &quot;seen&quot; IDs</span>
        <span class="n">dedup</span><span class="o">.</span><span class="n">seen_data</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="n">PM</span> <span class="o">=</span> <span class="n">PseudoMap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span>
        <span class="n">_stack</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,)</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()]</span>
        <span class="k">while</span> <span class="n">_stack</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">PM</span><span class="o">.</span><span class="n">_block</span> <span class="o">=</span> <span class="n">_block</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">yield</span> <span class="n">_block</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">PM</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">_block</span><span class="o">.</span><span class="n">_component_data_itervalues</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">dedup</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="n">_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_postfix_dfs_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">dedup</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function implementing a non-recursive postfix</span>
<span class="sd">        order depth-first search.  That is, the parent is</span>
<span class="sd">        returned after its children.</span>

<span class="sd">        Note: this method assumes it is called ONLY by the</span>
<span class="sd">        _tree_iterator method, which centralizes certain</span>
<span class="sd">        error checking and preliminaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We will unconditionally return self, so preemptively add it to</span>
        <span class="c1"># the list of &quot;seen&quot; IDs</span>
        <span class="n">dedup</span><span class="o">.</span><span class="n">seen_data</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="n">_stack</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_component_data_itervalues</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">dedup</span><span class="p">))]</span>
        <span class="k">while</span> <span class="n">_stack</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_sub</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">_sub</span><span class="p">,</span> <span class="n">_sub</span><span class="o">.</span><span class="n">_component_data_itervalues</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">dedup</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_bfs_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">dedup</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function implementing a non-recursive breadth-first search.</span>
<span class="sd">        That is, all children at one level in the tree are returned</span>
<span class="sd">        before any of the children at the next level.</span>

<span class="sd">        Note: this method assumes it is called ONLY by the _tree_iterator</span>
<span class="sd">        method, which centralizes certain error checking and</span>
<span class="sd">        preliminaries.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We will unconditionally return self, so preemptively add it to</span>
        <span class="c1"># the list of &quot;seen&quot; IDs</span>
        <span class="n">dedup</span><span class="o">.</span><span class="n">seen_data</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">SortComponents</span><span class="o">.</span><span class="n">sort_indices</span><span class="p">(</span><span class="n">sort</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">SortComponents</span><span class="o">.</span><span class="n">sort_names</span><span class="p">(</span><span class="n">sort</span><span class="p">):</span>
                <span class="n">sorter</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sorter</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">SortComponents</span><span class="o">.</span><span class="n">sort_names</span><span class="p">(</span><span class="n">sort</span><span class="p">):</span>
            <span class="n">sorter</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sorter</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">_levelQueue</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">(((</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">),),)}</span>
        <span class="k">while</span> <span class="n">_levelQueue</span><span class="p">:</span>
            <span class="n">_level</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">_levelQueue</span><span class="p">)</span>
            <span class="n">_queue</span> <span class="o">=</span> <span class="n">_levelQueue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">_level</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_queue</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">sorter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_queue</span> <span class="o">=</span> <span class="n">_levelWalker</span><span class="p">(</span><span class="n">_queue</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_queue</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">_sortingLevelWalker</span><span class="p">(</span><span class="n">_queue</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">sorter</span><span class="p">)</span>

            <span class="n">_level</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">_levelQueue</span><span class="p">[</span><span class="n">_level</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># JDS: rework the _levelQueue logic so we don&#39;t need to</span>
            <span class="c1"># merge the key/value returned by the new</span>
            <span class="c1"># component_data_iterindex() method.</span>
            <span class="k">for</span> <span class="n">_items</span> <span class="ow">in</span> <span class="n">_queue</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">_items</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># _block</span>
                <span class="n">_levelQueue</span><span class="p">[</span><span class="n">_level</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">],)</span>
                    <span class="k">for</span> <span class="n">tmp</span> <span class="ow">in</span> <span class="n">_items</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">_component_data_iteritems</span><span class="p">(</span>
                        <span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">dedup</span>
                    <span class="p">)</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">fix_all_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: Simplify based on recursive logic</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_map</span><span class="p">(</span><span class="n">Var</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">var</span><span class="o">.</span><span class="n">fix</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_map</span><span class="p">(</span><span class="n">Block</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">block</span><span class="o">.</span><span class="n">fix_all_vars</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">unfix_all_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: Simplify based on recursive logic</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_map</span><span class="p">(</span><span class="n">Var</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">var</span><span class="o">.</span><span class="n">unfix</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_map</span><span class="p">(</span><span class="n">Block</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">block</span><span class="o">.</span><span class="n">unfix_all_vars</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_constructed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A boolean indicating whether or not all *active* components of the</span>
<span class="sd">        input model have been properly constructed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span><span class="o">.</span><span class="n">_constructed</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decl_order</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">active</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_constructed</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_pprint_blockdata_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ostream</span><span class="p">):</span>
        <span class="c1">#</span>
        <span class="c1"># We hard-code the order of the core Pyomo modeling</span>
        <span class="c1"># components, to ensure that the output follows the logical order</span>
        <span class="c1"># that expected by a user.</span>
        <span class="c1">#</span>
        <span class="kn">import</span> <span class="nn">pyomo.core.base.component_order</span>

        <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pyomo</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">component_order</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>
        <span class="n">items_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
        <span class="n">items_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Block</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># Collect other model components that are registered</span>
        <span class="c1"># with the IModelComponent extension point.  These are appended</span>
        <span class="c1"># to the end of the list of the list.</span>
        <span class="c1">#</span>
        <span class="n">dynamic_items</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctypes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items_set</span><span class="p">:</span>
                <span class="n">dynamic_items</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="c1"># extra items get added alphabetically (so output is consistent)</span>
        <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Block</span><span class="p">)</span>
        <span class="n">items</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">dynamic_items</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

        <span class="n">indented_ostream</span> <span class="o">=</span> <span class="n">StreamIndenter</span><span class="p">(</span><span class="n">ostream</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_PPRINT_INDENT</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">component_map</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">keys</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1">#</span>
            <span class="c1"># NOTE: these conditional checks should not be hard-coded.</span>
            <span class="c1">#</span>
            <span class="n">ostream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> Declarations</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">),</span> <span class="n">item</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">ostream</span><span class="o">=</span><span class="n">indented_ostream</span><span class="p">)</span>
            <span class="n">ostream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># Model Order</span>
        <span class="c1">#</span>
        <span class="n">decl_order_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">component_map</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">ostream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> Declarations: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">decl_order_keys</span><span class="p">),</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">decl_order_keys</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ostream</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print the Pyomo model in a verbose format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">OUTPUT</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">(</span><span class="n">ostream</span><span class="o">=</span><span class="n">OUTPUT</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">)</span>
            <span class="n">OUTPUT</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">ostream</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ostream</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ostream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;Block &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ostream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;Model &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># FIXME: We should change the display order (to Obj, Var, Con,</span>
        <span class="c1"># Block) and change the printer to only display sections with</span>
        <span class="c1"># active components.  That will fix the need for the special</span>
        <span class="c1"># case for blocks below.  I am not implementing this now as it</span>
        <span class="c1"># would break tests just before a release.  [JDS 1/7/15]</span>
        <span class="kn">import</span> <span class="nn">pyomo.core.base.component_order</span>

        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">pyomo</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">component_order</span><span class="o">.</span><span class="n">display_items</span><span class="p">:</span>
            <span class="c1">#</span>
            <span class="n">ostream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">ostream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;  </span><span class="si">%s</span><span class="s2">:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">pyomo</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">component_order</span><span class="o">.</span><span class="n">display_name</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">ACTIVE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_map</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ACTIVE</span><span class="p">:</span>
                <span class="n">ostream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;    None</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">ACTIVE</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">display</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;    &quot;</span><span class="p">,</span> <span class="n">ostream</span><span class="o">=</span><span class="n">ostream</span><span class="p">)</span>

        <span class="n">item</span> <span class="o">=</span> <span class="n">Block</span>
        <span class="n">ACTIVE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_map</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ACTIVE</span><span class="p">:</span>
            <span class="n">ostream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">ostream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;  </span><span class="si">%s</span><span class="s2">:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">pyomo</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">component_order</span><span class="o">.</span><span class="n">display_name</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">ACTIVE</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">display</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;    &quot;</span><span class="p">,</span> <span class="n">ostream</span><span class="o">=</span><span class="n">ostream</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># The following methods are needed to support passing blocks as</span>
    <span class="c1"># models to a solver.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">valid_problem_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method allows the pyomo.opt convert function to work with a</span>
<span class="sd">        Model object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ProblemFormat</span><span class="o">.</span><span class="n">pyomo</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">solver_capability</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">io_options</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the model to a file, with a given format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#</span>
        <span class="c1"># Guess the format if none is specified</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># Preserving backwards compatibility here.</span>
            <span class="c1"># The function used to be defined with format=&#39;lp&#39; by</span>
            <span class="c1"># default, but this led to confusing behavior when a</span>
            <span class="c1"># user did something like &#39;model.write(&quot;f.nl&quot;)&#39; and</span>
            <span class="c1"># expected guess_format to create an NL file.</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="n">ProblemFormat</span><span class="o">.</span><span class="n">cpxlp</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_format</span> <span class="o">=</span> <span class="n">guess_format</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># End up here if an ostream is passed to the filename argument</span>
                <span class="n">_format</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Could not infer file format from file name &#39;</span><span class="si">%s</span><span class="s2">&#39;.</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;Either provide a name with a recognized extension &quot;</span>
                        <span class="s2">&quot;or specify the format using the &#39;format&#39; argument.&quot;</span> <span class="o">%</span> <span class="n">filename</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">format</span> <span class="o">=</span> <span class="n">_format</span>
            <span class="k">elif</span> <span class="nb">format</span> <span class="o">!=</span> <span class="n">_format</span> <span class="ow">and</span> <span class="n">_format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Filename &#39;</span><span class="si">%s</span><span class="s2">&#39; likely does not match specified &quot;</span>
                    <span class="s2">&quot;file format (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="n">problem_writer</span> <span class="o">=</span> <span class="n">WriterFactory</span><span class="p">(</span><span class="nb">format</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">problem_writer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot write model in format &#39;</span><span class="si">%s</span><span class="s2">&#39;: no model &quot;</span>
                <span class="s2">&quot;writer registered for that format&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">format</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">solver_capability</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">solver_capability</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">smap</span><span class="p">)</span> <span class="o">=</span> <span class="n">problem_writer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">solver_capability</span><span class="p">,</span> <span class="n">io_options</span><span class="p">)</span>
        <span class="n">smap_id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">smap</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;solutions&#39;</span><span class="p">):</span>
            <span class="c1"># This is a bit of a hack.  The write() method was moved</span>
            <span class="c1"># here from PyomoModel to support the solution of arbitrary</span>
            <span class="c1"># blocks in a hierarchical model.  However, we cannot import</span>
            <span class="c1"># PyomoModel at the beginning of the file due to a circular</span>
            <span class="c1"># import.  When we rearchitect the solution writers/solver</span>
            <span class="c1"># API, we should revisit this and remove the circular</span>
            <span class="c1"># dependency (we only need it here because we store the</span>
            <span class="c1"># SymbolMap returned by the writer in the solutions).</span>
            <span class="kn">from</span> <span class="nn">pyomo.core.base.PyomoModel</span> <span class="kn">import</span> <span class="n">ModelSolutions</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">solutions</span> <span class="o">=</span> <span class="n">ModelSolutions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solutions</span><span class="o">.</span><span class="n">add_symbol_map</span><span class="p">(</span><span class="n">smap</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_debug_set</span><span class="p">(</span><span class="n">logger</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Writing model &#39;</span><span class="si">%s</span><span class="s2">&#39; to file &#39;</span><span class="si">%s</span><span class="s2">&#39; with format </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span>
                <span class="nb">str</span><span class="p">(</span><span class="nb">format</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">filename</span><span class="p">,</span> <span class="n">smap_id</span>

    <span class="k">def</span> <span class="nf">_create_objects_for_deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">component_list</span><span class="p">):</span>
        <span class="n">_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">_ans</span> <span class="o">=</span> <span class="n">memo</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">_new</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_ans</span> <span class="ow">is</span> <span class="n">_new</span><span class="p">:</span>
            <span class="n">component_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="c1"># Blocks (and block-like things) need to pre-populate all</span>
            <span class="c1"># Components / ComponentData objects to help prevent</span>
            <span class="c1"># deepcopy() from violating the Python recursion limit.</span>
            <span class="c1"># This step is recursive; however, we do not expect &quot;super</span>
            <span class="c1"># deep&quot; Pyomo block hierarchies, so should be okay.</span>
            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_map</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">comp</span><span class="o">.</span><span class="n">_create_objects_for_deepcopy</span><span class="p">(</span><span class="n">memo</span><span class="p">,</span> <span class="n">component_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_ans</span>


<div class="viewcode-block" id="Block"><a class="viewcode-back" href="../../../../library_reference/aml/index.html#pyomo.environ.Block">[docs]</a><span class="nd">@ModelComponentFactory</span><span class="o">.</span><span class="n">register</span><span class="p">(</span>
    <span class="s2">&quot;A component that contains one or more model components.&quot;</span>
<span class="p">)</span>
<span class="k">class</span> <span class="nc">Block</span><span class="p">(</span><span class="n">ActiveIndexedComponent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Blocks are indexed components that contain other components</span>
<span class="sd">    (including blocks).  Blocks have a global attribute that defines</span>
<span class="sd">    whether construction is deferred.  This applies to all components</span>
<span class="sd">    that they contain except blocks.  Blocks contained by other</span>
<span class="sd">    blocks use their local attribute to determine whether construction</span>
<span class="sd">    is deferred.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_ComponentDataClass</span> <span class="o">=</span> <span class="n">_BlockData</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="o">!=</span> <span class="n">Block</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Block</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span> <span class="ow">or</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">UnindexedComponent_set</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ScalarBlock</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">ScalarBlock</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IndexedBlock</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">IndexedBlock</span><span class="p">)</span>

    <span class="c1"># `options` is ignored since it is deprecated</span>
    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">indexes</span><span class="p">,</span> <span class="n">rule</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">concrete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dense</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_suppress_ctypes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">_rule</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;rule&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">_options</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;options&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># As concrete applies to the Block at declaration time, we will</span>
        <span class="c1"># not use an initializer.</span>
        <span class="n">_concrete</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;concrete&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="c1"># As dense applies to the whole container, we will not use an</span>
        <span class="c1"># initializer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dense</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dense&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ctype&#39;</span><span class="p">,</span> <span class="n">Block</span><span class="p">)</span>
        <span class="n">ActiveIndexedComponent</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">deprecation_warning</span><span class="p">(</span>
                <span class="s2">&quot;The Block &#39;options=&#39; keyword is deprecated.  &quot;</span>
                <span class="s2">&quot;Equivalent functionality can be obtained by wrapping &quot;</span>
                <span class="s2">&quot;the rule function to add the options dictionary to &quot;</span>
                <span class="s2">&quot;the function arguments&quot;</span><span class="p">,</span>
                <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.7.2&#39;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>

                <span class="k">def</span> <span class="nf">rule_wrapper</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="o">*</span><span class="n">_idx</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">_rule</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="o">*</span><span class="n">_idx</span><span class="p">,</span> <span class="o">**</span><span class="n">_options</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">def</span> <span class="nf">rule_wrapper</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">_rule</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="o">**</span><span class="n">_options</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_rule</span> <span class="o">=</span> <span class="n">Initializer</span><span class="p">(</span><span class="n">rule_wrapper</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rule</span> <span class="o">=</span> <span class="n">Initializer</span><span class="p">(</span><span class="n">_rule</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_concrete</span><span class="p">:</span>
            <span class="c1"># Call self.construct() as opposed to just setting the _constructed</span>
            <span class="c1"># flag so that the base class construction procedure fires (this</span>
            <span class="c1"># picks up any construction rule that the user may provide)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_getitem_when_not_present</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="n">_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setitem_when_not_present</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rule</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_block</span>

        <span class="k">if</span> <span class="n">_BlockConstruction</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">_BlockConstruction</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Note that for scalar Blocks, this will override the</span>
                <span class="c1"># entry for _BlockConstruction.data[id(self)], as _block</span>
                <span class="c1"># is self.</span>
                <span class="n">_BlockConstruction</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">_block</span><span class="p">)]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rule</span><span class="p">(</span><span class="n">_block</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
            <span class="c1"># If the user returns a block, transfer over everything</span>
            <span class="c1"># they defined into the empty one we created.  We do</span>
            <span class="c1"># this inside the try block so that any abstract</span>
            <span class="c1"># components declared by the rule have the opportunity</span>
            <span class="c1"># to be initialized with data from</span>
            <span class="c1"># _BlockConstruction.data as they are transferred over.</span>
            <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_block</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">_BlockData</span><span class="p">):</span>
                <span class="n">_block</span><span class="o">.</span><span class="n">transfer_attributes_from</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">_block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">_BlockConstruction</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">_block</span><span class="p">)]</span>

        <span class="c1"># TBD: Should we allow skipping Blocks???</span>
        <span class="c1"># if obj is Block.Skip and idx is not None:</span>
        <span class="c1">#   del self._data[idx]</span>
        <span class="k">return</span> <span class="n">_block</span>

<div class="viewcode-block" id="Block.construct"><a class="viewcode-back" href="../../../../library_reference/aml/index.html#pyomo.environ.Block.construct">[docs]</a>    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the block</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_debug_set</span><span class="p">(</span><span class="n">logger</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Constructing </span><span class="si">%s</span><span class="s2"> &#39;</span><span class="si">%s</span><span class="s2">&#39;, from data=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructed</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">timer</span> <span class="o">=</span> <span class="n">ConstructionTimer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constructed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Constructing blocks is tricky.  Scalar blocks are already</span>
        <span class="c1"># partially constructed (they have _data[None] == self) in order</span>
        <span class="c1"># to support Abstract blocks.  The block may therefore already</span>
        <span class="c1"># have components declared on it.  In order to preserve</span>
        <span class="c1"># decl_order, we must construct those components *first* before</span>
        <span class="c1"># firing any rule.  Indexed blocks should be empty, so we only</span>
        <span class="c1"># need to fire the rule in order.</span>
        <span class="c1">#</span>
        <span class="c1">#  Since the rule does not pass any &quot;data&quot; on, we build a scalar</span>
        <span class="c1">#  &quot;stack&quot; of pointers to block data (_BlockConstruction.data)</span>
        <span class="c1">#  that the individual blocks&#39; add_component() can refer back to</span>
        <span class="c1">#  to handle component construction.</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_BlockConstruction</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
                <span class="c1"># We can only populate Blocks with finite indexing sets</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_set</span><span class="p">()</span><span class="o">.</span><span class="n">isfinite</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_dense</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rule</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="p">):</span>
                    <span class="k">for</span> <span class="n">_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_set</span><span class="p">():</span>
                        <span class="c1"># Trigger population &amp; call the rule</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_getitem_when_not_present</span><span class="p">(</span><span class="n">_idx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We must check that any pre-existing components are</span>
                <span class="c1"># constructed.  This catches the case where someone is</span>
                <span class="c1"># building a Concrete model by building (potentially</span>
                <span class="c1"># pseudo-abstract) sub-blocks and then adding them to a</span>
                <span class="c1"># Concrete model block.</span>
                <span class="n">_idx</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">UnindexedComponent_set</span><span class="p">))</span>
                <span class="n">_predefined_components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_map</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">_predefined_components</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
                        <span class="c1"># Derived block classes may not follow the scalar</span>
                        <span class="c1"># Block convention of initializing _data to point to</span>
                        <span class="c1"># itself (i.e., they are not set up to support</span>
                        <span class="c1"># Abstract models)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
                    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">_idx</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">_predefined_components</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="o">.</span><span class="n">_constructed</span><span class="p">:</span>
                            <span class="n">obj</span><span class="o">.</span><span class="n">construct</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                <span class="c1"># Trigger the (normal) initialization of the block</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_getitem_when_not_present</span><span class="p">(</span><span class="n">_idx</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># We must allow that id(self) may no longer be in</span>
            <span class="c1"># _BlockConstruction.data, as _getitem_when_not_present will</span>
            <span class="c1"># have already removed the entry for scalar blocks (as the</span>
            <span class="c1"># BlockData and the Block component are the same object)</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_BlockConstruction</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">timer</span><span class="o">.</span><span class="n">report</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_pprint_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ostream</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
            <span class="n">data</span><span class="o">.</span><span class="n">_pprint_blockdata_components</span><span class="p">(</span><span class="n">ostream</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ostream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> : Active=</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">active</span><span class="p">))</span>
            <span class="n">ostream</span> <span class="o">=</span> <span class="n">StreamIndenter</span><span class="p">(</span><span class="n">ostream</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_PPRINT_INDENT</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">_pprint_blockdata_components</span><span class="p">(</span><span class="n">ostream</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_attrs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;Size&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;Index&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">()</span> <span class="k">else</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Active&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="c1"># HACK: suppress the top-level block header (for historical reasons)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pprint_callback</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_attrs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pprint_callback</span>

<div class="viewcode-block" id="Block.display"><a class="viewcode-back" href="../../../../library_reference/aml/index.html#pyomo.environ.Block.display">[docs]</a>    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ostream</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display values in the block</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">OUTPUT</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">(</span><span class="n">ostream</span><span class="o">=</span><span class="n">OUTPUT</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">)</span>
            <span class="n">OUTPUT</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">ostream</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ostream</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">_BlockData</span><span class="o">.</span><span class="n">display</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">filename</span><span class="p">,</span> <span class="n">ostream</span><span class="p">,</span> <span class="n">prefix</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">ScalarBlock</span><span class="p">(</span><span class="n">_BlockData</span><span class="p">,</span> <span class="n">Block</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">_BlockData</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">Block</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="c1"># Initialize the data dict so that (abstract) attribute</span>
        <span class="c1"># assignment will work.  Note that we do not trigger</span>
        <span class="c1"># get/setitem_when_not_present so that we do not (implicitly)</span>
        <span class="c1"># trigger the Block rule</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">UnindexedComponent_index</span>

    <span class="c1"># We want scalar Blocks to pick up the Block display method</span>
    <span class="n">display</span> <span class="o">=</span> <span class="n">Block</span><span class="o">.</span><span class="n">display</span>


<span class="k">class</span> <span class="nc">SimpleBlock</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">RenamedClass</span><span class="p">):</span>
    <span class="n">__renamed__new_class__</span> <span class="o">=</span> <span class="n">ScalarBlock</span>
    <span class="n">__renamed__version__</span> <span class="o">=</span> <span class="s1">&#39;6.0&#39;</span>


<span class="k">class</span> <span class="nc">IndexedBlock</span><span class="p">(</span><span class="n">Block</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">Block</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>


<span class="c1">#</span>
<span class="c1"># Deprecated functions.</span>
<span class="c1">#</span>
<span class="nd">@deprecated</span><span class="p">(</span>
    <span class="s2">&quot;generate_cuid_names() is deprecated. &quot;</span>
    <span class="s2">&quot;Use the ComponentUID.generate_cuid_string_map() static method&quot;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="s2">&quot;5.7.2&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">generate_cuid_names</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">ctype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">descend_into</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ComponentUID</span><span class="o">.</span><span class="n">generate_cuid_string_map</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">descend_into</span><span class="p">)</span>


<span class="nd">@deprecated</span><span class="p">(</span>
    <span class="s2">&quot;The active_components function is deprecated.  &quot;</span>
    <span class="s2">&quot;Use the Block.component_objects() method.&quot;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="s2">&quot;4.1.10486&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">active_components</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">sort_by_names</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort_by_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">block</span><span class="o">.</span><span class="n">component_objects</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort_by_names</span><span class="p">)</span>


<span class="nd">@deprecated</span><span class="p">(</span>
    <span class="s2">&quot;The components function is deprecated.  &quot;</span>
    <span class="s2">&quot;Use the Block.component_objects() method.&quot;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="s2">&quot;4.1.10486&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">components</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">sort_by_names</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort_by_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">block</span><span class="o">.</span><span class="n">component_objects</span><span class="p">(</span><span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort_by_names</span><span class="p">)</span>


<span class="nd">@deprecated</span><span class="p">(</span>
    <span class="s2">&quot;The active_components_data function is deprecated.  &quot;</span>
    <span class="s2">&quot;Use the Block.component_data_objects() method.&quot;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="s2">&quot;4.1.10486&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">active_components_data</span><span class="p">(</span>
    <span class="n">block</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort_by_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort_by_names</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">block</span><span class="o">.</span><span class="n">component_data_objects</span><span class="p">(</span><span class="n">ctype</span><span class="o">=</span><span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>


<span class="nd">@deprecated</span><span class="p">(</span>
    <span class="s2">&quot;The components_data function is deprecated.  &quot;</span>
    <span class="s2">&quot;Use the Block.component_data_objects() method.&quot;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="s2">&quot;4.1.10486&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">components_data</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort_by_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort_by_names</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">block</span><span class="o">.</span><span class="n">component_data_objects</span><span class="p">(</span><span class="n">ctype</span><span class="o">=</span><span class="n">ctype</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>


<span class="c1">#</span>
<span class="c1"># Create a Block and record all the default attributes, methods, etc.</span>
<span class="c1"># These will be assumed to be the set of illegal component names.</span>
<span class="c1">#</span>
<span class="n">_BlockData</span><span class="o">.</span><span class="n">_Block_reserved_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">Block</span><span class="p">()))</span>


<span class="k">class</span> <span class="nc">_IndexedCustomBlockMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Metaclass for creating an indexed custom block.&quot;&quot;&quot;</span>

    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">_ScalarCustomBlockMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Metaclass for creating a scalar custom block.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># bases[0] is the custom block data object</span>
            <span class="n">bases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
            <span class="c1"># bases[1] is the custom block object that</span>
            <span class="c1"># is used for declaration</span>
            <span class="n">bases</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">dct</span><span class="p">[</span><span class="s2">&quot;__init__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="fm">__init__</span>
        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">CustomBlock</span><span class="p">(</span><span class="n">Block</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The base class used by instances of custom block components&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_ctype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ctype&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_ctype</span><span class="p">)</span>
        <span class="n">Block</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_Indexed&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_Scalar&#39;</span><span class="p">):</span>
            <span class="c1"># we are entering here the second time (recursive)</span>
            <span class="c1"># therefore, we need to create what we have</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">CustomBlock</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span> <span class="ow">or</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">UnindexedComponent_set</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">_ScalarCustomBlockMeta</span><span class="p">(</span>
                <span class="s2">&quot;_Scalar</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,),</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_ComponentDataClass</span><span class="p">,</span> <span class="bp">cls</span><span class="p">),</span> <span class="p">{}</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">_IndexedCustomBlockMeta</span><span class="p">(</span><span class="s2">&quot;_Indexed</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,),</span> <span class="p">(</span><span class="bp">cls</span><span class="p">,),</span> <span class="p">{})</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">declare_custom_block</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">new_ctype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decorator to declare components for a custom block data class</span>

<span class="sd">    &gt;&gt;&gt; @declare_custom_block(name=FooBlock)</span>
<span class="sd">    ... class FooBlockData(_BlockData):</span>
<span class="sd">    ...    # custom block data class</span>
<span class="sd">    ...    pass</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">proc_dec</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="c1"># this is the decorator function that</span>
        <span class="c1"># creates the block component class</span>

        <span class="c1"># Default (derived) Block attributes</span>
        <span class="n">clsbody</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;__module__&quot;</span><span class="p">:</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>  <span class="c1"># magic to fix the module</span>
            <span class="c1"># Default IndexedComponent data object is the decorated class:</span>
            <span class="s2">&quot;_ComponentDataClass&quot;</span><span class="p">:</span> <span class="bp">cls</span><span class="p">,</span>
            <span class="c1"># By default this new block does not declare a new ctype</span>
            <span class="s2">&quot;_default_ctype&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">c</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>  <span class="c1"># name of new class</span>
            <span class="p">(</span><span class="n">CustomBlock</span><span class="p">,),</span>  <span class="c1"># base classes</span>
            <span class="n">clsbody</span><span class="p">,</span>  <span class="c1"># class body definitions (will populate __dict__)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">new_ctype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_ctype</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">_default_ctype</span> <span class="o">=</span> <span class="n">c</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">new_ctype</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">_default_ctype</span> <span class="o">=</span> <span class="n">new_ctype</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Expected new_ctype to be either type &quot;</span>
                    <span class="s2">&quot;or &#39;True&#39;; received: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">new_ctype</span><span class="p">,)</span>
                <span class="p">)</span>

        <span class="c1"># Register the new Block type in the same module as the BlockData</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span><span class="p">],</span> <span class="n">name</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="c1"># TODO: can we also register concrete Indexed* and Scalar*</span>
        <span class="c1"># classes into the original BlockData module (instead of relying</span>
        <span class="c1"># on metaclasses)?</span>

        <span class="c1"># are these necessary?</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_orig_name&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_orig_module&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span>

    <span class="k">return</span> <span class="n">proc_dec</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2008-2023, Sandia National Laboratories.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>