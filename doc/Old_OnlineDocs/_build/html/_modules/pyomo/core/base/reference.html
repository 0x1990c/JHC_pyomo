

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>pyomo.core.base.reference &mdash; Pyomo 6.5.1.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/theme_overrides.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/clipboard.min.js"></script>
        <script src="../../../../_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> Pyomo
          

          
          </a>

          
            
            
              <div class="version">
                6.5.1.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../citing_pyomo.html">Citing Pyomo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pyomo_overview/index.html">Pyomo Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pyomo_modeling_components/index.html">Pyomo Modeling Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../solving_pyomo_models.html">Solving Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_models.html">Working with Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_abstractmodels/index.html">Working with Abstract Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_transformations/index.html">Model Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modeling_extensions/index.html">Modeling Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial_examples.html">Pyomo Tutorial Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_debugging/index.html">Debugging Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../advanced_topics/index.html">Advanced Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../errors.html">Common Warnings/Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_reference/index.html">Developer Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../library_reference/index.html">Library Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contribution_guide.html">Contributing to Pyomo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributed_packages/index.html">Third-Party Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../related_packages.html">Related Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Pyomo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>pyomo.core.base.reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyomo.core.base.reference</h1><div class="highlight"><pre>
<span></span><span class="c1">#  ___________________________________________________________________________</span>
<span class="c1">#</span>
<span class="c1">#  Pyomo: Python Optimization Modeling Objects</span>
<span class="c1">#  Copyright (c) 2008-2022</span>
<span class="c1">#  National Technology and Engineering Solutions of Sandia, LLC</span>
<span class="c1">#  Under the terms of Contract DE-NA0003525 with National Technology and</span>
<span class="c1">#  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain</span>
<span class="c1">#  rights in this software.</span>
<span class="c1">#  This software is distributed under the 3-clause BSD License.</span>
<span class="c1">#  ___________________________________________________________________________</span>

<span class="kn">from</span> <span class="nn">pyomo.common</span> <span class="kn">import</span> <span class="n">DeveloperError</span>
<span class="kn">from</span> <span class="nn">pyomo.common.collections</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">UserDict</span><span class="p">,</span>
    <span class="n">OrderedDict</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">MutableMapping</span><span class="p">,</span>
    <span class="n">Set</span> <span class="k">as</span> <span class="n">collections_Set</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyomo.common.modeling</span> <span class="kn">import</span> <span class="n">NOTSET</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.set</span> <span class="kn">import</span> <span class="n">DeclareGlobalSet</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">SetOf</span><span class="p">,</span> <span class="n">OrderedSetOf</span><span class="p">,</span> <span class="n">_SetDataBase</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.component</span> <span class="kn">import</span> <span class="n">Component</span><span class="p">,</span> <span class="n">ComponentData</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.global_set</span> <span class="kn">import</span> <span class="n">UnindexedComponent_set</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.indexed_component</span> <span class="kn">import</span> <span class="n">IndexedComponent</span><span class="p">,</span> <span class="n">normalize_index</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.indexed_component_slice</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">IndexedComponent_slice</span><span class="p">,</span>
    <span class="n">_IndexedComponent_slice_iter</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.util</span> <span class="kn">import</span> <span class="n">flatten_tuple</span>
<span class="kn">from</span> <span class="nn">pyomo.common.deprecation</span> <span class="kn">import</span> <span class="n">deprecated</span>

<span class="n">_UnindexedComponent_key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">UnindexedComponent_set</span><span class="p">)</span>
<span class="n">_UnindexedComponent_base_key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">UnindexedComponent_set</span><span class="p">)</span>

<span class="n">DeclareGlobalSet</span><span class="p">(</span>
    <span class="n">Set</span><span class="p">(</span>
        <span class="n">initialize</span><span class="o">=</span><span class="n">UnindexedComponent_set</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;UnindexedComponent_ReferenceSet&#39;</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;An indexing set used by references to unindexed (scalar) &#39;</span>
        <span class="s1">&#39;components that is equivalent to but NOT the UnindexedComponent_set&#39;</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="nb">globals</span><span class="p">(),</span>
<span class="p">)</span>


<span class="k">class</span> <span class="nc">_fill_in_known_wildcards</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Variant of &quot;six.advance_iterator&quot; that substitutes wildcard values</span>

<span class="sd">    This object is initialized with a tuple of index values.  Calling</span>
<span class="sd">    the resulting object on a :py:class:`_slice_generator` will</span>
<span class="sd">    &quot;advance&quot; the iterator, substituting values from the tuple into the</span>
<span class="sd">    slice wildcards (&quot;:&quot; indices), and returning the resulting object.</span>
<span class="sd">    The motivation for implementing this as an iterator is so that we</span>
<span class="sd">    can re-use all the logic from</span>
<span class="sd">    :py:meth:`_IndexedComponent_slice_iter.__next__` when looking up</span>
<span class="sd">    specific indices within the slice.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    wildcard_values : tuple of index values</span>
<span class="sd">        a tuple containing index values to substitute into the slice wildcards</span>

<span class="sd">    look_in_index : :py:class:`bool` [optional]</span>
<span class="sd">        If True, the iterator will also look for matches using the</span>
<span class="sd">        components&#39; underlying index_set() in addition to the (sparse)</span>
<span class="sd">        indices matched by the components&#39; __contains__()</span>
<span class="sd">        method. [default: False]</span>

<span class="sd">    get_if_not_present : :py:class:`bool` [optional]</span>
<span class="sd">        If True, the iterator will attempt to retrieve data objects</span>
<span class="sd">        (through getitem) for indexes that match the underlying</span>
<span class="sd">        component index_set() but do not appear in the (sparse) indices</span>
<span class="sd">        matched by __contains__.  get_if_not_present implies</span>
<span class="sd">        look_in_index.  [default: False]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wildcard_values</span><span class="p">,</span> <span class="n">look_in_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">get_if_not_present</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_key</span> <span class="o">=</span> <span class="n">wildcard_values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">wildcard_values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">known_slices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">look_in_index</span> <span class="o">=</span> <span class="n">look_in_index</span> <span class="ow">or</span> <span class="n">get_if_not_present</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_if_not_present</span> <span class="o">=</span> <span class="n">get_if_not_present</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_slice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Advance the specified slice generator, substituting wildcard values</span>

<span class="sd">        This advances the passed :py:class:`_slice_generator</span>
<span class="sd">        &lt;pyomo.core.base.indexed_component_slice._slice_generator&gt;` by</span>
<span class="sd">        substituting values from the `wildcard_values` list for any</span>
<span class="sd">        wildcard slices (&quot;`:`&quot;).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        _slice : pyomo.core.base.indexed_component_slice._slice_generator</span>
<span class="sd">            the slice to advance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">_slice</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">known_slices</span><span class="p">:</span>
            <span class="c1"># We have encountered the same slice twice, i.e. IC_slice_iter</span>
            <span class="c1"># has constructed an iter_stack, and is now attempting to</span>
            <span class="c1"># exhaust the most recent iterator in that stack.</span>
            <span class="c1"># We know then that the iter stack is complete, and we</span>
            <span class="c1"># tell IC_slice_iter.__next__ to wrap up by raising</span>
            <span class="c1"># StopIteration.</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">known_slices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_slice</span><span class="p">)</span>

        <span class="c1"># `idx_count` is the number of indices this component needs.</span>
        <span class="k">if</span> <span class="n">_slice</span><span class="o">.</span><span class="n">ellipsis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">idx_count</span> <span class="o">=</span> <span class="n">_slice</span><span class="o">.</span><span class="n">explicit_index_count</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">_slice</span><span class="o">.</span><span class="n">component</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
            <span class="n">idx_count</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx_count</span> <span class="o">=</span> <span class="n">_slice</span><span class="o">.</span><span class="n">component</span><span class="o">.</span><span class="n">index_set</span><span class="p">()</span><span class="o">.</span><span class="n">dimen</span>
            <span class="k">if</span> <span class="n">idx_count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SliceEllipsisLookupError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot lookup elements in a _ReferenceDict when the &quot;</span>
                    <span class="s2">&quot;underlying slice object contains ellipsis over a jagged &quot;</span>
                    <span class="s2">&quot;(dimen=None) Set&quot;</span>
                <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Here we assemble the index we will actually use to access</span>
            <span class="c1"># the component.</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">_slice</span><span class="o">.</span><span class="n">fixed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_slice</span><span class="o">.</span><span class="n">fixed</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx_count</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># _slice corresponds to some sliced entry in the call/iter stacks</span>
            <span class="c1"># that contains the information describing the slice.</span>
            <span class="c1"># Here we fill in an index with the fixed indices from the slice</span>
            <span class="c1"># and the wildcard indices from the provided key.</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="c1"># Occurs if we try to pop from an empty list.</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="s2">&quot;Insufficient values for slice of indexed component &#39;</span><span class="si">%s</span><span class="s2">&#39; &quot;</span>
                <span class="s2">&quot;(found evaluating slice index </span><span class="si">%s</span><span class="s2">)&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">_slice</span><span class="o">.</span><span class="n">component</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_key</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">_slice</span><span class="o">.</span><span class="n">component</span><span class="p">:</span>
            <span class="c1"># We have found a matching component at this level of the</span>
            <span class="c1"># underlying slice _call_stack.  We need to record the index</span>
            <span class="c1"># for later use (i.e., with get_last_index() /</span>
            <span class="c1"># get_last_index_wildcards()).</span>
            <span class="n">_slice</span><span class="o">.</span><span class="n">last_index</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="c1"># Return the component. We have successfully accessed</span>
            <span class="c1"># the data value.</span>
            <span class="k">return</span> <span class="n">_slice</span><span class="o">.</span><span class="n">component</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">_slice</span><span class="o">.</span><span class="n">component</span><span class="p">:</span>
            <span class="c1"># `idx` is a len-1 tuple.  It is the scalar, not the tuple,</span>
            <span class="c1"># that is contained by the component.</span>
            <span class="n">_slice</span><span class="o">.</span><span class="n">last_index</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="k">return</span> <span class="n">_slice</span><span class="o">.</span><span class="n">component</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">idx</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_slice</span><span class="o">.</span><span class="n">component</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">look_in_index</span><span class="p">:</span>
            <span class="c1"># At this point we know our component is sparse and we did</span>
            <span class="c1"># not find the component data.  Since `look_in_index` is</span>
            <span class="c1"># True, we will verify that the index is valid in the</span>
            <span class="c1"># underlying indexing set, and if it is, we will trigger the</span>
            <span class="c1"># creation (and return) of the new component data.</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">_slice</span><span class="o">.</span><span class="n">component</span><span class="o">.</span><span class="n">index_set</span><span class="p">():</span>
                <span class="n">_slice</span><span class="o">.</span><span class="n">last_index</span> <span class="o">=</span> <span class="n">idx</span>
                <span class="k">return</span> <span class="n">_slice</span><span class="o">.</span><span class="n">component</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_if_not_present</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">_slice</span><span class="o">.</span><span class="n">component</span><span class="o">.</span><span class="n">index_set</span><span class="p">():</span>
                <span class="n">_slice</span><span class="o">.</span><span class="n">last_index</span> <span class="o">=</span> <span class="n">idx</span>
                <span class="k">return</span> <span class="n">_slice</span><span class="o">.</span><span class="n">component</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_if_not_present</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
            <span class="s2">&quot;Index </span><span class="si">%s</span><span class="s2"> is not valid for indexed component &#39;</span><span class="si">%s</span><span class="s2">&#39; &quot;</span>
            <span class="s2">&quot;(found evaluating slice index </span><span class="si">%s</span><span class="s2">)&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">_slice</span><span class="o">.</span><span class="n">component</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_key</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">check_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">_UnindexedComponent_key</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_key</span> <span class="o">==</span> <span class="n">_UnindexedComponent_base_key</span>
        <span class="p">):</span>
            <span class="k">return</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Extra (unused) values for slice index </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_key</span><span class="p">,))</span>


<span class="k">class</span> <span class="nc">SliceEllipsisLookupError</span><span class="p">(</span><span class="ne">LookupError</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">_ReferenceDict</span><span class="p">(</span><span class="n">MutableMapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A dict-like object whose values are defined by a slice.</span>

<span class="sd">    This implements a dict-like object whose keys and values are defined</span>
<span class="sd">    by a component slice (:py:class:`IndexedComponent_slice`).  The</span>
<span class="sd">    intent behind this object is to replace the normal ``_data``</span>
<span class="sd">    :py:class:`dict` in :py:class:`IndexedComponent` containers to</span>
<span class="sd">    create &quot;reference&quot; components.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    component_slice : :py:class:`IndexedComponent_slice`</span>
<span class="sd">        The slice object that defines the &quot;members&quot; of this mutable mapping.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component_slice</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span> <span class="o">=</span> <span class="n">component_slice</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
            <span class="c1"># This calls IC_slice_iter.__next__, which calls</span>
            <span class="c1"># _fill_in_known_wildcards.</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="n">SliceEllipsisLookupError</span><span class="p">:</span>
            <span class="c1"># We failed because the notion of &quot;location&quot; in an index</span>
            <span class="c1"># is ambiguous if the index_set has dimen None.</span>
            <span class="c1"># We can still brute-force the lookup by comparing the key</span>
            <span class="c1"># to the wildcards of the `last_index` cached by the</span>
            <span class="c1"># slice&#39;s iterator stack.</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Brute force (linear time) lookup</span>
            <span class="n">_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">_iter</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_iter</span><span class="o">.</span><span class="n">get_last_index_wildcards</span><span class="p">()</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">LookupError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">normalize_index</span><span class="o">.</span><span class="n">flatten</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">,</span> <span class="p">(</span><span class="n">key</span><span class="p">,)))</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">except</span> <span class="ne">LookupError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># This calls IC_slice_iter.__next__, which calls</span>
            <span class="c1"># _fill_in_known_wildcards.</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">get_if_not_present</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">SliceEllipsisLookupError</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Brute force (linear time) lookup</span>
            <span class="n">_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">_iter</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_iter</span><span class="o">.</span><span class="n">get_last_index_wildcards</span><span class="p">()</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">item</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;KeyError: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">StopIteration</span><span class="p">,</span> <span class="ne">LookupError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;KeyError: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,))</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_call_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Replace the end of the duplicated slice&#39;s call stack (deepest</span>
        <span class="c1"># level of the component hierarchy) with the appropriate</span>
        <span class="c1"># `set_item` call.  Then implement the actual __setitem__ by</span>
        <span class="c1"># advancing the duplicated iterator.</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="n">IndexedComponent_slice</span><span class="o">.</span><span class="n">get_item</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">_call_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">IndexedComponent_slice</span><span class="o">.</span><span class="n">set_item</span><span class="p">,</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">_call_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">val</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="n">IndexedComponent_slice</span><span class="o">.</span><span class="n">slice_info</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">_call_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">IndexedComponent_slice</span><span class="o">.</span><span class="n">set_item</span><span class="p">,</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">_call_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">val</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="n">IndexedComponent_slice</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">_call_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">IndexedComponent_slice</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">,</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">_call_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">val</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DeveloperError</span><span class="p">(</span><span class="s2">&quot;Unexpected slice _call_stack operation: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">op</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_iter</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">get_if_not_present</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">_call_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="n">IndexedComponent_slice</span><span class="o">.</span><span class="n">get_item</span><span class="p">:</span>
            <span class="c1"># If the last attribute of the slice gets an item,</span>
            <span class="c1"># change it to delete the item</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">_call_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">IndexedComponent_slice</span><span class="o">.</span><span class="n">del_item</span><span class="p">,</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">_call_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="n">IndexedComponent_slice</span><span class="o">.</span><span class="n">slice_info</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">_call_stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_iter</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">_iter</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">_iter</span><span class="o">.</span><span class="n">_iter_stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">component</span><span class="p">[</span><span class="n">_iter</span><span class="o">.</span><span class="n">get_last_index</span><span class="p">()]</span>
                <span class="k">return</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;KeyError: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,))</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="n">IndexedComponent_slice</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">:</span>
            <span class="c1"># If the last attribute of the slice retrieves an attribute,</span>
            <span class="c1"># change it to delete the attribute</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">_call_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">IndexedComponent_slice</span><span class="o">.</span><span class="n">del_attribute</span><span class="p">,</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">_call_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DeveloperError</span><span class="p">(</span><span class="s2">&quot;Unexpected slice _call_stack operation: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">op</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_iter</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">wildcard_keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Note that unlike for regular dicts, len() of a _ReferenceDict</span>
        <span class="c1"># is very slow (linear time).</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the wildcard, value tuples for this ReferenceDict</span>

<span class="sd">        This method is necessary because the default implementation</span>
<span class="sd">        iterates over the keys and looks the values up in the</span>
<span class="sd">        dictionary.  Unfortunately some slices have structures that make</span>
<span class="sd">        looking up components by the wildcard keys very expensive</span>
<span class="sd">        (linear time; e.g., the use of ellipses with jagged sets).  By</span>
<span class="sd">        implementing this method without using lookups, general methods</span>
<span class="sd">        that iterate over everything (like component.pprint()) will</span>
<span class="sd">        still be linear and not quadratic time.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">wildcard_items</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the values for this ReferenceDict</span>

<span class="sd">        This method is necessary because the default implementation</span>
<span class="sd">        iterates over the keys and looks the values up in the</span>
<span class="sd">        dictionary.  Unfortunately some slices have structures that make</span>
<span class="sd">        looking up components by the wildcard keys very expensive</span>
<span class="sd">        (linear time; e.g., the use of ellipses with jagged sets).  By</span>
<span class="sd">        implementing this method without using lookups, general methods</span>
<span class="sd">        that iterate over everything (like component.pprint()) will</span>
<span class="sd">        still be linear and not quadratic time.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s1">&#39;The iteritems method is deprecated. Use dict.items().&#39;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;6.0&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s1">&#39;The itervalues method is deprecated. Use dict.values().&#39;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;6.0&#39;</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_slice</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">get_if_not_present</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Construct a slice iter with `_fill_in_known_wildcards`</span>
        <span class="c1"># as `advance_iter`. This reuses all the logic from the slice</span>
        <span class="c1"># iter to walk the call/iter stacks, but just jumps to a</span>
        <span class="c1"># particular component rather than actually iterating.</span>
        <span class="c1"># This is how this object does lookups.</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">normalize_index</span><span class="o">.</span><span class="n">flatten</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">flatten_tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_IndexedComponent_slice_iter</span><span class="p">(</span>
            <span class="n">_slice</span><span class="p">,</span> <span class="n">_fill_in_known_wildcards</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">get_if_not_present</span><span class="o">=</span><span class="n">get_if_not_present</span><span class="p">)</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">_ReferenceDict_mapping</span><span class="p">(</span><span class="n">UserDict</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c1"># Overwrite the internal dict to keep a reference to whatever</span>
        <span class="c1"># mapping was passed in (potentially preserving the</span>
        <span class="c1"># &quot;orderedness&quot; of the source dictionary).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>


<span class="k">class</span> <span class="nc">_ReferenceSet</span><span class="p">(</span><span class="n">collections_Set</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A set-like object whose values are defined by a slice.</span>

<span class="sd">    This implements a set-like object whose members are defined by a</span>
<span class="sd">    component slice (:py:class:`IndexedComponent_slice`).</span>
<span class="sd">    :py:class:`_ReferenceSet` differs from the</span>
<span class="sd">    :py:class:`_ReferenceDict` above in that it looks in the underlying</span>
<span class="sd">    component ``index_set()`` for values that match the slice, and not</span>
<span class="sd">    just the (sparse) indices defined by the slice.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    component_slice : :py:class:`IndexedComponent_slice`</span>
<span class="sd">        The slice object that defines the &quot;members&quot; of this set</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component_slice</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span> <span class="o">=</span> <span class="n">component_slice</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="n">SliceEllipsisLookupError</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Brute force (linear time) lookup</span>
            <span class="n">_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">_iter</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_iter</span><span class="o">.</span><span class="n">get_last_index_wildcards</span><span class="p">()</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">StopIteration</span><span class="p">,</span> <span class="ne">LookupError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="o">.</span><span class="n">index_wildcard_keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_slice</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">normalize_index</span><span class="o">.</span><span class="n">flatten</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">flatten_tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_IndexedComponent_slice_iter</span><span class="p">(</span>
            <span class="n">_slice</span><span class="p">,</span>
            <span class="n">_fill_in_known_wildcards</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">look_in_index</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">iter_over_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;ReferenceSet(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">,)</span>


<span class="k">def</span> <span class="nf">_identify_wildcard_sets</span><span class="p">(</span><span class="n">iter_stack</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="c1"># Note that we can only _identify_wildcard_sets for a Reference if</span>
    <span class="c1"># normalize_index.flatten is True.</span>
    <span class="c1">#</span>
    <span class="c1"># If we have already decided that there isn&#39;t a common index for the</span>
    <span class="c1"># slices, there is nothing more we can do.  Bail.</span>
    <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">index</span>

    <span class="c1"># Walk the iter_stack that led to the current item and try to</span>
    <span class="c1"># identify the component wildcard sets</span>
    <span class="c1">#</span>
    <span class="c1"># `wildcard_stack` will be a list of dicts mirroring the</span>
    <span class="c1"># _iter_stack.  Each dict maps position within that level&#39;s</span>
    <span class="c1"># component&#39;s &quot;subsets&quot; list to the set at that position if it is a</span>
    <span class="c1"># wildcard set.</span>
    <span class="n">wildcard_stack</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">iter_stack</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iter_stack</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># `offset` is the position, within the total index tuple,</span>
            <span class="c1"># of the first coordinate of a set.</span>
            <span class="n">wildcard_sets</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># `wildcard_sets` maps position in the current level&#39;s</span>
            <span class="c1"># &quot;subsets list&quot; to its set if that set is a wildcard.</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">level</span><span class="o">.</span><span class="n">component</span><span class="o">.</span><span class="n">index_set</span><span class="p">()</span><span class="o">.</span><span class="n">subsets</span><span class="p">(</span><span class="n">expand_all_set_operators</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="c1"># Iterate over the sets that could possibly be wildcards</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="n">UnindexedComponent_set</span><span class="p">:</span>
                    <span class="n">wildcard_sets</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
                    <span class="n">offset</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">dimen</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="c1"># `wildcard_count` is the number of coordinates of this</span>
                <span class="c1"># set (which may be multi-dimensional) that have been</span>
                <span class="c1"># sliced.</span>
                <span class="k">if</span> <span class="n">level</span><span class="o">.</span><span class="n">fixed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">wildcard_count</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">dimen</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">wildcard_count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                        <span class="mi">1</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">dimen</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span> <span class="o">+</span> <span class="n">offset</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">level</span><span class="o">.</span><span class="n">fixed</span>
                    <span class="p">)</span>
                <span class="c1"># `k+offset` is a position in the &quot;total&quot; (flattened)</span>
                <span class="c1"># index tuple.  All the _slice_generator&#39;s information</span>
                <span class="c1"># is in terms of this total index tuple.</span>
                <span class="k">if</span> <span class="n">wildcard_count</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">dimen</span><span class="p">:</span>
                    <span class="c1"># Every coordinate of this subset is covered by a</span>
                    <span class="c1"># wildcard. This could happen because of explicit</span>
                    <span class="c1"># slices or an ellipsis.</span>
                    <span class="n">wildcard_sets</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
                <span class="k">elif</span> <span class="n">wildcard_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># This subset is &quot;touched&quot; by an explicit slice, but</span>
                    <span class="c1"># the whole set is not (i.e. there is a fixed</span>
                    <span class="c1"># component to this subset).  Therefore, as we</span>
                    <span class="c1"># cannot extract that subset, we quit.</span>
                    <span class="c1">#</span>
                    <span class="c1"># We do not simply `continue` as this &quot;partially sliced</span>
                    <span class="c1"># set&quot; has ruined our chance of extracting sets that</span>
                    <span class="c1"># perfectly describe our wildcards.</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="n">s</span><span class="o">.</span><span class="n">dimen</span>
            <span class="c1"># I believe that this check is not necessary: weirdnesses</span>
            <span class="c1"># with ellipsis should get caught by the check for s.dimen</span>
            <span class="c1"># above.</span>
            <span class="c1">#</span>
            <span class="c1"># if offset != level.explicit_index_count:</span>
            <span class="c1">#    return None</span>
            <span class="n">wildcard_stack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wildcard_sets</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">index</span><span class="p">:</span>
        <span class="c1"># index is an empty list, i.e. no wildcard sets have been</span>
        <span class="c1"># previously identified.  `wildcard_stack` will serve as the</span>
        <span class="c1"># basis for comparison for future components&#39; wildcard sets.</span>
        <span class="k">return</span> <span class="n">wildcard_stack</span>

    <span class="c1"># For objects to have &quot;the same&quot; wildcard sets, the same sets must</span>
    <span class="c1"># be sliced at the same coordinates of their &quot;subsets list&quot; at the</span>
    <span class="c1"># same level of the _iter_stack.</span>

    <span class="c1"># Any of the following would preclude identifying common sets</span>
    <span class="c1"># among the objects defined by a slice.</span>
    <span class="c1"># However, I can&#39;t see a way to actually create any of these</span>
    <span class="c1"># situations (i.e., I can&#39;t test them).  Assertions are left in for</span>
    <span class="c1"># defensive programming.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">wildcard_stack</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wildcard_stack</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># No slices at this level in the slice</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="c1"># if there are a differing number of wildcard &quot;subsets&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">level</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># if any wildcard &quot;subset&quot; differs in position or set.</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_set</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">_set</span> <span class="ow">in</span> <span class="n">level</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># These checks seem to intentionally preclude</span>
        <span class="c1">#     m.b1[:].v and m.b2[1,:].v</span>
        <span class="c1"># from having a common set, even if the sliced set is the same.</span>
        <span class="c1"># This is correct, as you cannot express a single reference that</span>
        <span class="c1"># covers this example.  You would have to create intermediate</span>
        <span class="c1"># References to unify the indexing scheme, e.g.:</span>
        <span class="c1">#     m.c[1] = Reference(m.b1[:])</span>
        <span class="c1">#     m.c[2] = Reference(m.b2[1,:])</span>
        <span class="c1">#     Reference(m.c[:].v)</span>
    <span class="k">return</span> <span class="n">index</span>


<div class="viewcode-block" id="Reference"><a class="viewcode-back" href="../../../../library_reference/aml/index.html#pyomo.environ.Reference">[docs]</a><span class="k">def</span> <span class="nf">Reference</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">ctype</span><span class="o">=</span><span class="n">NOTSET</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates a component that references other components</span>

<span class="sd">    ``Reference`` generates a *reference component*; that is, an indexed</span>
<span class="sd">    component that does not contain data, but instead references data</span>
<span class="sd">    stored in other components as defined by a component slice.  The</span>
<span class="sd">    ctype parameter sets the :py:meth:`Component.type` of the resulting</span>
<span class="sd">    indexed component.  If the ctype parameter is not set and all data</span>
<span class="sd">    identified by the slice (at construction time) share a common</span>
<span class="sd">    :py:meth:`Component.type`, then that type is assumed.  If either the</span>
<span class="sd">    ctype parameter is ``None`` or the data has more than one ctype, the</span>
<span class="sd">    resulting indexed component will have a ctype of</span>
<span class="sd">    :py:class:`IndexedComponent`.</span>

<span class="sd">    If the indices associated with wildcards in the component slice all</span>
<span class="sd">    refer to the same :py:class:`Set` objects for all data identifed by</span>
<span class="sd">    the slice, then the resulting indexed component will be indexed by</span>
<span class="sd">    the product of those sets.  However, if all data do not share common</span>
<span class="sd">    set objects, or only a subset of indices in a multidimentional set</span>
<span class="sd">    appear as wildcards, then the resulting indexed component will be</span>
<span class="sd">    indexed by a :py:class:`SetOf` containing a</span>
<span class="sd">    :py:class:`_ReferenceSet` for the slice.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reference : :py:class:`IndexedComponent_slice`</span>
<span class="sd">        component slice that defines the data to include in the</span>
<span class="sd">        Reference component</span>

<span class="sd">    ctype : :py:class:`type` [optional]</span>
<span class="sd">        the type used to create the resulting indexed component.  If not</span>
<span class="sd">        specified, the data&#39;s ctype will be used (if all data share a</span>
<span class="sd">        common ctype).  If multiple data ctypes are found or type is</span>
<span class="sd">        ``None``, then :py:class:`IndexedComponent` will be used.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    .. doctest::</span>

<span class="sd">        &gt;&gt;&gt; from pyomo.environ import *</span>
<span class="sd">        &gt;&gt;&gt; m = ConcreteModel()</span>
<span class="sd">        &gt;&gt;&gt; @m.Block([1,2],[3,4])</span>
<span class="sd">        ... def b(b,i,j):</span>
<span class="sd">        ...     b.x = Var(bounds=(i,j))</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; m.r1 = Reference(m.b[:,:].x)</span>
<span class="sd">        &gt;&gt;&gt; m.r1.pprint()</span>
<span class="sd">        r1 : Size=4, Index=r1_index, ReferenceTo=b[:, :].x</span>
<span class="sd">            Key    : Lower : Value : Upper : Fixed : Stale : Domain</span>
<span class="sd">            (1, 3) :     1 :  None :     3 : False :  True :  Reals</span>
<span class="sd">            (1, 4) :     1 :  None :     4 : False :  True :  Reals</span>
<span class="sd">            (2, 3) :     2 :  None :     3 : False :  True :  Reals</span>
<span class="sd">            (2, 4) :     2 :  None :     4 : False :  True :  Reals</span>

<span class="sd">    Reference components may also refer to subsets of the original data:</span>

<span class="sd">    .. doctest::</span>

<span class="sd">        &gt;&gt;&gt; m.r2 = Reference(m.b[:,3].x)</span>
<span class="sd">        &gt;&gt;&gt; m.r2.pprint()</span>
<span class="sd">        r2 : Size=2, Index=b_index_0, ReferenceTo=b[:, 3].x</span>
<span class="sd">            Key : Lower : Value : Upper : Fixed : Stale : Domain</span>
<span class="sd">              1 :     1 :  None :     3 : False :  True :  Reals</span>
<span class="sd">              2 :     2 :  None :     3 : False :  True :  Reals</span>

<span class="sd">    Reference components may have wildcards at multiple levels of the</span>
<span class="sd">    model hierarchy:</span>

<span class="sd">    .. doctest::</span>

<span class="sd">        &gt;&gt;&gt; m = ConcreteModel()</span>
<span class="sd">        &gt;&gt;&gt; @m.Block([1,2])</span>
<span class="sd">        ... def b(b,i):</span>
<span class="sd">        ...     b.x = Var([3,4], bounds=(i,None))</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; m.r3 = Reference(m.b[:].x[:])</span>
<span class="sd">        &gt;&gt;&gt; m.r3.pprint()</span>
<span class="sd">        r3 : Size=4, Index=r3_index, ReferenceTo=b[:].x[:]</span>
<span class="sd">            Key    : Lower : Value : Upper : Fixed : Stale : Domain</span>
<span class="sd">            (1, 3) :     1 :  None :  None : False :  True :  Reals</span>
<span class="sd">            (1, 4) :     1 :  None :  None : False :  True :  Reals</span>
<span class="sd">            (2, 3) :     2 :  None :  None : False :  True :  Reals</span>
<span class="sd">            (2, 4) :     2 :  None :  None : False :  True :  Reals</span>

<span class="sd">    The resulting reference component may be used just like any other</span>
<span class="sd">    component.  Changes to the stored data will be reflected in the</span>
<span class="sd">    original objects:</span>

<span class="sd">    .. doctest::</span>

<span class="sd">        &gt;&gt;&gt; m.r3[1,4] = 10</span>
<span class="sd">        &gt;&gt;&gt; m.b[1].x.pprint()</span>
<span class="sd">        x : Size=2, Index=b[1].x_index</span>
<span class="sd">            Key : Lower : Value : Upper : Fixed : Stale : Domain</span>
<span class="sd">              3 :     1 :  None :  None : False :  True :  Reals</span>
<span class="sd">              4 :     1 :    10 :  None : False : False :  Reals</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">referent</span> <span class="o">=</span> <span class="n">reference</span>
    <span class="c1">#</span>
    <span class="c1"># Before constructing the reference object that we will return,</span>
    <span class="c1"># we need to know its index set, its ctype, and its _data</span>
    <span class="c1"># dict. The following if statement sets the _data dict</span>
    <span class="c1"># for all possible input types and sets up data structures</span>
    <span class="c1"># necessary to determine the index set and ctype.</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">IndexedComponent_slice</span><span class="p">):</span>
        <span class="n">slice_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="n">_ReferenceDict</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>
        <span class="n">_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">Component</span><span class="p">):</span>
        <span class="n">slice_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">reference</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">index_set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">UnindexedComponent_ReferenceSet</span>
        <span class="k">if</span> <span class="n">ctype</span> <span class="ow">is</span> <span class="n">NOTSET</span><span class="p">:</span>
            <span class="n">ctype</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">ctype</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">reference</span><span class="p">[</span><span class="o">...</span><span class="p">]</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="n">_ReferenceDict</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>
        <span class="c1"># index and ctype are now set; no need to iterate over the slice</span>
        <span class="n">_iter</span> <span class="o">=</span> <span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">ComponentData</span><span class="p">):</span>
        <span class="n">slice_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">UnindexedComponent_ReferenceSet</span>
        <span class="k">if</span> <span class="n">ctype</span> <span class="ow">is</span> <span class="n">NOTSET</span><span class="p">:</span>
            <span class="n">ctype</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">ctype</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">IndexedComponent_slice</span><span class="p">(</span><span class="n">reference</span><span class="o">.</span><span class="n">parent_component</span><span class="p">())[</span>
            <span class="n">reference</span><span class="o">.</span><span class="n">index</span><span class="p">()</span>
        <span class="p">]</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="n">_ReferenceDict</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>
        <span class="c1"># index and ctype are now set; no need to iterate over the slice</span>
        <span class="n">_iter</span> <span class="o">=</span> <span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="n">slice_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="n">_ReferenceDict_mapping</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">reference</span><span class="p">))</span>
        <span class="n">_iter</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">SetOf</span><span class="p">(</span><span class="n">_data</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
        <span class="n">slice_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="n">_ReferenceDict_mapping</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">reference</span><span class="p">)))</span>
        <span class="n">_iter</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">OrderedSetOf</span><span class="p">(</span><span class="n">_data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;First argument to Reference constructors must be a &quot;</span>
            <span class="s2">&quot;component, component slice, Sequence, or Mapping (received </span><span class="si">%s</span><span class="s2">)&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">ctype</span> <span class="ow">is</span> <span class="n">NOTSET</span><span class="p">:</span>
        <span class="n">ctypes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">slice_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># A slice was not provided. We know the ctype and that there</span>
            <span class="c1"># cannot be common subsets (because a slice was not provided).</span>
            <span class="c1"># We don&#39;t need to iterate over the data objects at all.</span>
            <span class="c1"># Note that this is redundant for Component and ComponentData</span>
            <span class="c1"># inputs, as _iter was already empty.</span>
            <span class="n">_iter</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">_iter</span><span class="p">:</span>
        <span class="c1">#</span>
        <span class="c1"># We were provided a collection of ComponentData, either via</span>
        <span class="c1"># a slice, sequence, or mapping. Now we iterate over these</span>
        <span class="c1"># objects to attempt to infer both the ctype and, if a slice</span>
        <span class="c1"># was provided, the index_set (determined by slice_index).</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">ctype</span> <span class="ow">is</span> <span class="n">NOTSET</span><span class="p">:</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">ctype</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ComponentData</span><span class="p">):</span>
                <span class="c1"># This object is not a ComponentData (likely it is a pure</span>
                <span class="c1"># IndexedComponent container).  As the Reference will treat</span>
                <span class="c1"># it as if it *were* a ComponentData, we will skip ctype</span>
                <span class="c1"># identification and return a base IndexedComponent, thereby</span>
                <span class="c1"># preventing strange exceptions in the writers and with</span>
                <span class="c1"># things like pprint().  Of course, all of this logic is</span>
                <span class="c1"># skipped if the User knows better and forced a ctype on us.</span>
                <span class="n">ctypes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Note that we want to walk the entire slice, unless we can</span>
        <span class="c1"># prove that BOTH there aren&#39;t common indexing sets (i.e., index</span>
        <span class="c1"># is None) AND there is more than one ctype.</span>
        <span class="k">if</span> <span class="n">slice_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># As long as we haven&#39;t ruled out the possibility of common</span>
            <span class="c1"># wildcard sets, then we will use _identify_wildcard_sets to</span>
            <span class="c1"># identify the wildcards for this obj and check compatibility</span>
            <span class="c1"># of the wildcards with any previously-identified wildcards.</span>
            <span class="n">slice_idx</span> <span class="o">=</span> <span class="n">_identify_wildcard_sets</span><span class="p">(</span><span class="n">_iter</span><span class="o">.</span><span class="n">_iter_stack</span><span class="p">,</span> <span class="n">slice_idx</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ctype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">NOTSET</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">ctypes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#</span>
        <span class="c1"># index is None, i.e. a slice was provided. If a slice index</span>
        <span class="c1"># has been identified (by all slice members having the same</span>
        <span class="c1"># &quot;wildcard sets&quot;), use this to construct an indexing set.</span>
        <span class="c1"># Otherwise, use a _ReferenceSet.</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">slice_idx</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">SetOf</span><span class="p">(</span><span class="n">_ReferenceSet</span><span class="p">(</span><span class="n">reference</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wildcards</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">lvl</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="k">for</span> <span class="n">lvl</span> <span class="ow">in</span> <span class="n">slice_idx</span> <span class="k">if</span> <span class="n">lvl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span> <span class="p">[]</span>
            <span class="p">)</span>
            <span class="c1"># Wildcards is a list of (coordinate, set) tuples.  Coordinate</span>
            <span class="c1"># is that within the subsets list, and set is a wildcard set.</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">wildcards</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># index is the first wildcard set.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">_SetDataBase</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">SetOf</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">lvl</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">wildcards</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">_SetDataBase</span><span class="p">):</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">SetOf</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">*</span> <span class="n">idx</span>
            <span class="c1"># index is now either a single Set, or a SetProduct of the</span>
            <span class="c1"># wildcard sets.</span>
    <span class="k">if</span> <span class="n">ctype</span> <span class="ow">is</span> <span class="n">NOTSET</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ctypes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># If ctype is not set and only one ctype was identified above,</span>
            <span class="c1"># use this ctype.</span>
            <span class="n">ctype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ctype</span> <span class="o">=</span> <span class="n">IndexedComponent</span>
    <span class="k">elif</span> <span class="n">ctype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ctype</span> <span class="o">=</span> <span class="n">IndexedComponent</span>

    <span class="n">obj</span> <span class="o">=</span> <span class="n">ctype</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">ctype</span><span class="o">=</span><span class="n">ctype</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">_constructed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">_data</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">referent</span> <span class="o">=</span> <span class="n">referent</span>
    <span class="k">return</span> <span class="n">obj</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2008-2023, Sandia National Laboratories.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>