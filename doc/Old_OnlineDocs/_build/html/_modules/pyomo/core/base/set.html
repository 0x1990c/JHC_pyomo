

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>pyomo.core.base.set &mdash; Pyomo 6.5.1.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/theme_overrides.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/clipboard.min.js"></script>
        <script src="../../../../_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> Pyomo
          

          
          </a>

          
            
            
              <div class="version">
                6.5.1.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../citing_pyomo.html">Citing Pyomo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pyomo_overview/index.html">Pyomo Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pyomo_modeling_components/index.html">Pyomo Modeling Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../solving_pyomo_models.html">Solving Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_models.html">Working with Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_abstractmodels/index.html">Working with Abstract Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_transformations/index.html">Model Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modeling_extensions/index.html">Modeling Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial_examples.html">Pyomo Tutorial Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_debugging/index.html">Debugging Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../advanced_topics/index.html">Advanced Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../errors.html">Common Warnings/Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_reference/index.html">Developer Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../library_reference/index.html">Library Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contribution_guide.html">Contributing to Pyomo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributed_packages/index.html">Third-Party Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../related_packages.html">Related Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Pyomo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>pyomo.core.base.set</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyomo.core.base.set</h1><div class="highlight"><pre>
<span></span><span class="c1">#  ___________________________________________________________________________</span>
<span class="c1">#</span>
<span class="c1">#  Pyomo: Python Optimization Modeling Objects</span>
<span class="c1">#  Copyright (c) 2008-2022</span>
<span class="c1">#  National Technology and Engineering Solutions of Sandia, LLC</span>
<span class="c1">#  Under the terms of Contract DE-NA0003525 with National Technology and</span>
<span class="c1">#  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain</span>
<span class="c1">#  rights in this software.</span>
<span class="c1">#  This software is distributed under the 3-clause BSD License.</span>
<span class="c1">#  ___________________________________________________________________________</span>

<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">from</span> <span class="nn">pyomo.common.pyomo_typing</span> <span class="kn">import</span> <span class="n">overload</span>

<span class="kn">from</span> <span class="nn">pyomo.common.deprecation</span> <span class="kn">import</span> <span class="n">deprecated</span><span class="p">,</span> <span class="n">deprecation_warning</span><span class="p">,</span> <span class="n">RenamedClass</span>
<span class="kn">from</span> <span class="nn">pyomo.common.errors</span> <span class="kn">import</span> <span class="n">DeveloperError</span><span class="p">,</span> <span class="n">PyomoException</span>
<span class="kn">from</span> <span class="nn">pyomo.common.log</span> <span class="kn">import</span> <span class="n">is_debug_set</span>
<span class="kn">from</span> <span class="nn">pyomo.common.modeling</span> <span class="kn">import</span> <span class="n">NOTSET</span>
<span class="kn">from</span> <span class="nn">pyomo.common.sorting</span> <span class="kn">import</span> <span class="n">sorted_robust</span>
<span class="kn">from</span> <span class="nn">pyomo.common.timing</span> <span class="kn">import</span> <span class="n">ConstructionTimer</span>

<span class="kn">from</span> <span class="nn">pyomo.core.expr.numvalue</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">native_types</span><span class="p">,</span>
    <span class="n">native_numeric_types</span><span class="p">,</span>
    <span class="n">as_numeric</span><span class="p">,</span>
    <span class="n">value</span><span class="p">,</span>
    <span class="n">is_constant</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.disable_methods</span> <span class="kn">import</span> <span class="n">disable_methods</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.initializer</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">InitializerBase</span><span class="p">,</span>
    <span class="n">Initializer</span><span class="p">,</span>
    <span class="n">CountedCallInitializer</span><span class="p">,</span>
    <span class="n">IndexedCallInitializer</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.range</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">NumericRange</span><span class="p">,</span>
    <span class="n">NonNumericRange</span><span class="p">,</span>
    <span class="n">AnyRange</span><span class="p">,</span>
    <span class="n">RangeProduct</span><span class="p">,</span>
    <span class="n">RangeDifferenceError</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.component</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_ComponentBase</span><span class="p">,</span>
    <span class="n">Component</span><span class="p">,</span>
    <span class="n">ComponentData</span><span class="p">,</span>
    <span class="n">ModelComponentFactory</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.indexed_component</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">IndexedComponent</span><span class="p">,</span>
    <span class="n">UnindexedComponent_set</span><span class="p">,</span>
    <span class="n">normalize_index</span><span class="p">,</span>
    <span class="n">rule_wrapper</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.global_set</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">GlobalSets</span><span class="p">,</span>
    <span class="n">GlobalSetBase</span><span class="p">,</span>
    <span class="n">UnindexedComponent_index</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;pyomo.core&#39;</span><span class="p">)</span>

<span class="n">_prePython37</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>

<span class="n">_inf</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>

<span class="n">FLATTEN_CROSS_PRODUCT</span> <span class="o">=</span> <span class="kc">True</span>

<span class="sd">&quot;&quot;&quot;Set objects</span>

<span class="sd">Pyomo `Set` objects are designed to be &quot;API-compatible&quot; with Python</span>
<span class="sd">`set` objects.  However, not all Set objects implement the full `set`</span>
<span class="sd">API (e.g., only finite discrete Sets support `add()`).</span>

<span class="sd">All Sets implement one of the following APIs:</span>

<span class="sd">0. `class _SetDataBase(ComponentData)`</span>
<span class="sd">   *(pure virtual interface)*</span>

<span class="sd">1. `class _SetData(_SetDataBase)`</span>
<span class="sd">   *(base class for all AML Sets)*</span>

<span class="sd">2. `class _FiniteSetMixin(object)`</span>
<span class="sd">   *(pure virtual interface, adds support for discrete/iterable sets)*</span>

<span class="sd">4. `class _OrderedSetMixin(object)`</span>
<span class="sd">   *(pure virtual interface, adds support for ordered Sets)*</span>

<span class="sd">This is a bit of a change from python set objects.  First, the</span>
<span class="sd">lowest-level (non-abstract) Data object supports infinite sets; that is,</span>
<span class="sd">sets that contain an infinite number of values (this includes both</span>
<span class="sd">bounded continuous ranges as well as unbounded discrete ranges).  As</span>
<span class="sd">there are an infinite number of values, iteration is *not*</span>
<span class="sd">supported. The base class also implements all Python set operations.</span>
<span class="sd">Note that `_SetData` does *not* implement `len()`, as Python requires</span>
<span class="sd">`len()` to return a positive integer.</span>

<span class="sd">Finite sets add iteration and support for `len()`.  In addition, they</span>
<span class="sd">support access to members through three methods: `data()` returns the</span>
<span class="sd">members as a tuple (in the internal storage order), and may not be</span>
<span class="sd">deterministic.  `ordered_data()` returns the members, and is guaranteed</span>
<span class="sd">to be in a deterministic order (in the case of insertion order sets, up</span>
<span class="sd">to the determinism of the script that populated the set).  Finally,</span>
<span class="sd">`sorted_data()` returns the members in a sorted order (guaranteed</span>
<span class="sd">deterministic, up to the implementation of &lt; and ==).</span>

<span class="sd">..TODO: should these three members all return generators?  This would</span>
<span class="sd">further change the implementation of `data()`, but would allow consumers</span>
<span class="sd">to potentially access the members in a more efficient manner.</span>

<span class="sd">Ordered sets add support for `ord()` and `__getitem__`, as well as the</span>
<span class="sd">`first`, `last`, `next` and `prev` methods for stepping over set</span>
<span class="sd">members.</span>

<span class="sd">Note that the base APIs are all declared (and to the extent possible,</span>
<span class="sd">implemented) through Mixin classes.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">process_setarg</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_SetDataBase</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arg</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_ComponentBase</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">IndexedComponent</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arg</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot apply a Set operator to an &quot;</span>
                <span class="s2">&quot;indexed </span><span class="si">%s</span><span class="s2"> component (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">ctype</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">arg</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Component</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot apply a Set operator to a non-Set &quot;</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> component (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">arg</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ComponentData</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot apply a Set operator to a non-Set &quot;</span>
                <span class="s2">&quot;component data (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
            <span class="p">)</span>

    <span class="c1"># DEPRECATED: This functionality has never been documented,</span>
    <span class="c1"># and I don&#39;t know of a use of it in the wild.</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;set_options&#39;</span><span class="p">):</span>
        <span class="n">deprecation_warning</span><span class="p">(</span>
            <span class="s2">&quot;The set_options set attribute is deprecated.  &quot;</span>
            <span class="s2">&quot;Please explicitly construct complex sets&quot;</span><span class="p">,</span>
            <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.7.3&#39;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># If the argument has a set_options attribute, then use</span>
        <span class="c1"># it to initialize a set</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">set_options</span>
        <span class="n">args</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;initialize&#39;</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
        <span class="n">args</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ordered&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Set</span><span class="o">.</span><span class="n">_UnorderedInitializers</span><span class="p">)</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">Set</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">)</span>

        <span class="n">_init</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;initialize&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">inspect</span><span class="o">.</span><span class="n">isgenerator</span><span class="p">(</span><span class="n">_init</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">_init</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">_init</span><span class="p">,</span> <span class="n">ComponentData</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">_init</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span><span class="o">.</span><span class="n">is_constructed</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="n">ans</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ans</span>

    <span class="c1"># TBD: should lists/tuples be copied into Sets, or</span>
    <span class="c1"># should we preserve the reference using SetOf?</span>
    <span class="c1"># Historical behavior is to *copy* into a Set.</span>
    <span class="c1">#</span>
    <span class="c1"># ans.append(Set(initialize=arg,</span>
    <span class="c1">#               ordered=type(arg) in {tuple, list}))</span>
    <span class="c1"># ans.construct()</span>
    <span class="c1">#</span>
    <span class="c1"># But this causes problems, especially because Set()&#39;s constructor</span>
    <span class="c1"># needs to know if the object is ordered (Set defaults to ordered,</span>
    <span class="c1"># and will toss a warning if the underlying data source is not</span>
    <span class="c1"># ordered)).  While we could add checks where we create the Set</span>
    <span class="c1"># (like here and in the __r*__ operators) and pass in a reasonable</span>
    <span class="c1"># value for ordered, it is starting to make more sense to use SetOf</span>
    <span class="c1"># (which has that logic).  Alternatively, we could use SetOf to</span>
    <span class="c1"># create the Set:</span>
    <span class="c1">#</span>
    <span class="n">_defer_construct</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isgenerator</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
        <span class="n">_ordered</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">_defer_construct</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
        <span class="n">_ordered</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">_defer_construct</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;__contains__&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Cannot create a Set from data that does not support &quot;</span>
            <span class="s2">&quot;__contains__.  Expected set-like object supporting &quot;</span>
            <span class="s2">&quot;collections.abc.Collection interface, but received &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">arg</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">:</span>
        <span class="c1"># This catches the (deprecated) RealSet API.</span>
        <span class="k">return</span> <span class="n">process_setarg</span><span class="p">(</span><span class="n">arg</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">SetOf</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="n">_ordered</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">isordered</span><span class="p">()</span>

    <span class="n">ans</span> <span class="o">=</span> <span class="n">Set</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="n">arg</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="n">_ordered</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="c1"># Because the resulting set will be attached to the model (at least</span>
    <span class="c1"># for the time being), we will NOT construct it here unless the data</span>
    <span class="c1"># is already determined (either statically provided, or through an</span>
    <span class="c1"># already-constructed component).</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_defer_construct</span><span class="p">:</span>
        <span class="n">ans</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>
    <span class="c1">#</span>
    <span class="c1"># Or we can do the simple thing and just use SetOf:</span>
    <span class="c1">#</span>
    <span class="c1"># ans = SetOf(arg)</span>
    <span class="k">return</span> <span class="n">ans</span>


<span class="nd">@deprecated</span><span class="p">(</span>
    <span class="s1">&#39;The set_options decorator is deprecated; create Sets from &#39;</span>
    <span class="s1">&#39;functions explicitly by passing the function to the Set &#39;</span>
    <span class="s1">&#39;constructor using the &quot;initialize=&quot; keyword argument.&#39;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.7&#39;</span><span class="p">,</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">set_options</span><span class="p">(</span><span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a decorator for set initializer functions.  This</span>
<span class="sd">    decorator allows an arbitrary dictionary of values to passed</span>
<span class="sd">    through to the set constructor.</span>

<span class="sd">    Examples:</span>
<span class="sd">        @set_options(dimen=3)</span>
<span class="sd">        def B_index(model):</span>
<span class="sd">            return [(i,i+1,i*i) for i in model.A]</span>

<span class="sd">        @set_options(domain=Integers)</span>
<span class="sd">        def B_index(model):</span>
<span class="sd">            return range(10)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">func</span><span class="o">.</span><span class="n">set_options</span> <span class="o">=</span> <span class="n">kwds</span>
        <span class="k">return</span> <span class="n">func</span>

    <span class="k">return</span> <span class="n">decorator</span>


<span class="k">def</span> <span class="nf">simple_set_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a decorator that translates None into Set.End.</span>
<span class="sd">    This supports a simpler syntax in set rules, though these can be</span>
<span class="sd">    more difficult to debug when errors occur.</span>

<span class="sd">    Example:</span>

<span class="sd">    @simple_set_rule</span>
<span class="sd">    def A_rule(model, i, j):</span>
<span class="sd">        ...</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">rule_wrapper</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="p">{</span><span class="kc">None</span><span class="p">:</span> <span class="n">Set</span><span class="o">.</span><span class="n">End</span><span class="p">})</span>


<span class="k">class</span> <span class="nc">UnknownSetDimen</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">SetInitializer</span><span class="p">(</span><span class="n">InitializerBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An Initializer wrapper for returning Set objects</span>

<span class="sd">    This initializer wraps another Initializer and converts the return</span>
<span class="sd">    value to a proper Pyomo Set.  If the initializer is None, then Any</span>
<span class="sd">    is returned.  This initializer can be &#39;intersected&#39; with another</span>
<span class="sd">    initializer to return the SetIntersect of the Sets returned by the</span>
<span class="sd">    initializers.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_set&#39;</span><span class="p">,</span> <span class="s1">&#39;verified&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">allow_generators</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verified</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set</span> <span class="o">=</span> <span class="n">Initializer</span><span class="p">(</span>
                <span class="n">init</span><span class="p">,</span>
                <span class="n">allow_generators</span><span class="o">=</span><span class="n">allow_generators</span><span class="p">,</span>
                <span class="n">treat_sequences_as_mappings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">SetInitializer</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_set</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">SetInitializer</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set</span> <span class="o">=</span> <span class="n">SetIntersectInitializer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_set</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set</span> <span class="o">=</span> <span class="n">SetIntersectInitializer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Any</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">process_setarg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">constant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="o">.</span><span class="n">constant</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">contains_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="o">.</span><span class="n">contains_indices</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">SetInitializer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">setdefault</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set</span> <span class="o">=</span> <span class="n">Initializer</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SetIntersectInitializer</span><span class="p">(</span><span class="n">InitializerBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An Initializer that returns the intersection of two SetInitializers</span>

<span class="sd">    Users will typically not create a SetIntersectInitializer directly.</span>
<span class="sd">    Instead, SetInitializer.intersect() may return a SetInitializer that</span>
<span class="sd">    contains a SetIntersectInitializer instance.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_A&#39;</span><span class="p">,</span> <span class="s1">&#39;_B&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">setA</span><span class="p">,</span> <span class="n">setB</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A</span> <span class="o">=</span> <span class="n">setA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_B</span> <span class="o">=</span> <span class="n">setB</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SetIntersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">constant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">constant</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="o">.</span><span class="n">constant</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">contains_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">contains_indices</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="o">.</span><span class="n">contains_indices</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">contains_indices</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="o">.</span><span class="n">contains_indices</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">indices</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="o">.</span><span class="n">indices</span><span class="p">()):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;SetIntersectInitializer contains two &quot;</span>
                        <span class="s2">&quot;sub-initializers with inconsistent external indices&quot;</span>
                    <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># It is OK (and desirable) for this to raise the exception</span>
            <span class="c1"># if B does not contain external indices</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">BoundsInitializer</span><span class="p">(</span><span class="n">InitializerBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An Initializer wrapper that converts bounds information to a RangeSet</span>

<span class="sd">    The BoundsInitializer wraps another initializer that is expected to</span>
<span class="sd">    return valid arguments to the RangeSet constructor.  Nominally, this</span>
<span class="sd">    would be bounds information in the form of (lower bound, upper</span>
<span class="sd">    bound), but could also be a single scalar or a 3-tuple.  Calling</span>
<span class="sd">    this initializer will return a RangeSet object.</span>

<span class="sd">    BoundsInitializer objects can be intersected with other</span>
<span class="sd">    SetInitializer objects using the SetInitializer.intersect() method.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_init&#39;</span><span class="p">,</span> <span class="s1">&#39;default_step&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">default_step</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init</span> <span class="o">=</span> <span class="n">Initializer</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="n">treat_sequences_as_mappings</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_step</span> <span class="o">=</span> <span class="n">default_step</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_step</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">default_step</span><span class="p">,)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_step</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_step</span><span class="p">)</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">RangeSet</span><span class="p">(</span><span class="o">*</span><span class="n">val</span><span class="p">)</span>
        <span class="c1"># We don&#39;t need to construct here, as the RangeSet will</span>
        <span class="c1"># automatically construct itself if it can</span>
        <span class="c1"># ans.construct()</span>
        <span class="k">return</span> <span class="n">ans</span>

    <span class="k">def</span> <span class="nf">constant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init</span><span class="o">.</span><span class="n">constant</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">setdefault</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="c1"># This is a real range set... there is no default to set</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">TuplizeError</span><span class="p">(</span><span class="n">PyomoException</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">TuplizeValuesInitializer</span><span class="p">(</span><span class="n">InitializerBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An initializer wrapper that will &quot;tuplize&quot; a sequence</span>

<span class="sd">    This initializer takes the result of another initializer, and if it</span>
<span class="sd">    is a sequence that does not already contain tuples, will convert it</span>
<span class="sd">    to a sequence of tuples, each of length &#39;dimen&#39; before returning it.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_init&#39;</span><span class="p">,</span> <span class="s1">&#39;_dimen&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">args</span> <span class="o">==</span> <span class="p">(</span><span class="kc">None</span><span class="p">,):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">TuplizeValuesInitializer</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_init</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init</span> <span class="o">=</span> <span class="n">_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dimen</span> <span class="o">=</span> <span class="n">UnknownSetDimen</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimen</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">UnknownSetDimen</span><span class="p">}:</span>
            <span class="k">return</span> <span class="n">_val</span>
        <span class="k">elif</span> <span class="n">_val</span> <span class="ow">is</span> <span class="n">Set</span><span class="o">.</span><span class="n">Skip</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_val</span>
        <span class="k">elif</span> <span class="n">_val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_val</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_val</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">_val</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_val</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_val</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_val</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_val</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tuplize</span><span class="p">(</span><span class="n">_val</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">constant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init</span><span class="o">.</span><span class="n">constant</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">contains_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init</span><span class="o">.</span><span class="n">contains_indices</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init</span><span class="o">.</span><span class="n">indices</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_tuplize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_val</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimen</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_val</span><span class="p">)</span> <span class="o">%</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TuplizeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot tuplize list data for set </span><span class="si">%%</span><span class="s2">s</span><span class="si">%%</span><span class="s2">s because its &quot;</span>
                <span class="s2">&quot;length </span><span class="si">%s</span><span class="s2"> is not a multiple of dimen=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_val</span><span class="p">),</span> <span class="n">d</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">_val</span><span class="p">[</span><span class="n">d</span> <span class="o">*</span> <span class="n">i</span> <span class="p">:</span> <span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_val</span><span class="p">)</span> <span class="o">//</span> <span class="n">d</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">_NotFound</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="s2">&quot;Internal type flag used to indicate if an object is not found in a set&quot;</span>
    <span class="k">pass</span>


<span class="c1"># A trivial class that we can use to test if an object is a &quot;legitimate&quot;</span>
<span class="c1"># set (either ScalarSet, or a member of an IndexedSet)</span>
<span class="k">class</span> <span class="nc">_SetDataBase</span><span class="p">(</span><span class="n">ComponentData</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The base for all objects that can be used as a component indexing set.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>


<span class="k">class</span> <span class="nc">_SetData</span><span class="p">(</span><span class="n">_SetDataBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The base for all Pyomo AML objects that can be used as a component</span>
<span class="sd">    indexing set.</span>

<span class="sd">    Derived versions of this class can be used as the Index for any</span>
<span class="sd">    IndexedComponent (including IndexedSet).&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">_NotFound</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># In Python 3.x, Sets are unhashable</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">_SetData</span><span class="p">):</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">_NotFound</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>

        <span class="k">if</span> <span class="n">ans</span> <span class="ow">is</span> <span class="n">_NotFound</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">_SetData</span><span class="p">):</span>
                <span class="n">deprecation_warning</span><span class="p">(</span>
                    <span class="s2">&quot;Testing for set subsets with &#39;a in b&#39; is deprecated.  &quot;</span>
                    <span class="s2">&quot;Use &#39;a.issubset(b)&#39;.&quot;</span><span class="p">,</span>
                    <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.7&#39;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">DeveloperError</span><span class="p">(</span>
            <span class="s2">&quot;Derived set class (</span><span class="si">%s</span><span class="s2">) failed to &quot;</span>
            <span class="s2">&quot;implement get()&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">isdiscrete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if this set admits only discrete members&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if this is a finite discrete (iterable) Set&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">isordered</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if this is an ordered finite discrete (iterable) Set&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">subsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expand_all_set_operators</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">((</span><span class="bp">self</span><span class="p">,))</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over the set members</span>

<span class="sd">        Raises AttributeError for non-finite sets.  This must be</span>
<span class="sd">        declared for non-finite sets because scalar sets inherit from</span>
<span class="sd">        IndexedComponent, which provides an iterator (over the</span>
<span class="sd">        underlying indexing set).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; object is not iterable (non-finite Set &#39;</span><span class="si">%s</span><span class="s2">&#39; &quot;</span>
            <span class="s2">&quot;is not iterable)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="c1"># Special case: non-finite range sets that only contain finite</span>
        <span class="c1"># ranges (or no ranges).  We will re-generate non-finite sets to</span>
        <span class="c1"># make sure we get an accurate &quot;finiteness&quot; flag.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;isfinite&#39;</span><span class="p">):</span>
            <span class="n">other_isfinite</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">isfinite</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">other_isfinite</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="n">RangeSet</span><span class="p">(</span><span class="n">ranges</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">ranges</span><span class="p">()))</span>
                    <span class="n">other_isfinite</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">isfinite</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;__contains__&#39;</span><span class="p">):</span>
            <span class="c1"># we assume that everything that does not implement</span>
            <span class="c1"># isfinite() is a discrete set.</span>
            <span class="n">other_isfinite</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># For efficiency, if the other is not a Set, we will try</span>
                <span class="c1"># converting it to a Python set() for efficient lookup.</span>
                <span class="n">other</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfinite</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="n">RangeSet</span><span class="p">(</span><span class="n">ranges</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">()))</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfinite</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">other_isfinite</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">other_isfinite</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">DeveloperError</span><span class="p">(</span>
            <span class="s2">&quot;Derived set class (</span><span class="si">%s</span><span class="s2">) failed to &quot;</span>
            <span class="s2">&quot;implement __str__&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">DeveloperError</span><span class="p">(</span>
            <span class="s2">&quot;Derived set class (</span><span class="si">%s</span><span class="s2">) failed to &quot;</span>
            <span class="s2">&quot;implement dimen&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">DeveloperError</span><span class="p">(</span>
            <span class="s2">&quot;Derived set class (</span><span class="si">%s</span><span class="s2">) failed to &quot;</span>
            <span class="s2">&quot;implement domain&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">ranges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">DeveloperError</span><span class="p">(</span>
            <span class="s2">&quot;Derived set class (</span><span class="si">%s</span><span class="s2">) failed to &quot;</span>
            <span class="s2">&quot;implement ranges&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_bnds</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span><span class="p">)</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">step</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_bnds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">_bnds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">_bnds</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">_bnds</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">_bnds</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">lb</span> <span class="o">==</span> <span class="o">-</span><span class="n">_inf</span><span class="p">:</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">int</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span> <span class="o">==</span> <span class="n">lb</span><span class="p">:</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ub</span> <span class="o">==</span> <span class="n">_inf</span><span class="p">:</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">int</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span> <span class="o">==</span> <span class="n">ub</span><span class="p">:</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span>

    <span class="k">def</span> <span class="nf">get_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the interval for this Set as (start, end, step)</span>

<span class="sd">        Returns the effective interval for this Set as a (start, end,</span>
<span class="sd">        step) tuple.  Start and End are the same as returned by</span>
<span class="sd">        `bounds()`.  Step is 0 for continuous ranges, a positive value</span>
<span class="sd">        for regular discrete sets (e.g., 1 for Integers), or `None` for</span>
<span class="sd">        Sets that do not have a regular interval (e.g., semicontinuous</span>
<span class="sd">        sets, mixed type sets, sets with dimen != 1, etc).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimen</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isdiscrete</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_discrete_interval</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_continuous_interval</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_discrete_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#</span>
        <span class="c1"># Note: I&#39;d like to use set() for ranges, since we will be</span>
        <span class="c1"># randomly removing elements from the list; however, since we</span>
        <span class="c1"># do it by enumerating over ranges, using set() would make this</span>
        <span class="c1"># routine nondeterministic.  Not a huge issue for the result,</span>
        <span class="c1"># but problemmatic for code coverage.</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">normalize_bounds</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># Catching Any, NonNumericRange, etc...</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="kc">None</span> <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="o">-</span><span class="n">_inf</span> <span class="k">else</span> <span class="n">start</span><span class="p">,</span>
                <span class="kc">None</span> <span class="k">if</span> <span class="n">end</span> <span class="o">==</span> <span class="n">_inf</span> <span class="k">else</span> <span class="n">end</span><span class="p">,</span>
                <span class="nb">abs</span><span class="p">(</span><span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">step</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ranges</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">step</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># If all the ranges are single points, we will just</span>
            <span class="c1"># brute-force it: sort the values and ensure that the step</span>
            <span class="c1"># is consistent.  Note that we know at this point ranges</span>
            <span class="c1"># only contains NumericRange objects (or at least that they</span>
            <span class="c1"># all have a `step` attribute).</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">step</span> <span class="o">!=</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">step</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># Catching Any, NonNumericRange, RangeProduct, etc...</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>

        <span class="n">nRanges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">ranges</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">_rlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span>
        <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">step</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span>
        <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">step</span> <span class="o">%</span> <span class="n">step</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>
        <span class="c1"># Catch misaligned ranges</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="n">ref</span><span class="p">)</span> <span class="o">%</span> <span class="n">step</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">step</span> <span class="o">%</span> <span class="n">step</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>

        <span class="c1"># This loop terminates when we have a complete pass that doesn&#39;t</span>
        <span class="c1"># remove any ranges from the ranges list.</span>
        <span class="k">while</span> <span class="n">nRanges</span> <span class="o">&gt;</span> <span class="n">_rlen</span><span class="p">:</span>
            <span class="n">nRanges</span> <span class="o">=</span> <span class="n">_rlen</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ranges</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">rstart</span><span class="p">,</span> <span class="n">rend</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rend</span><span class="p">,</span> <span class="n">rstart</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">step</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">step</span><span class="p">)</span> <span class="o">==</span> <span class="n">step</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">rend</span> <span class="o">+</span> <span class="n">step</span> <span class="ow">and</span> <span class="n">rstart</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="o">+</span> <span class="n">step</span><span class="p">:</span>
                        <span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">rstart</span><span class="p">:</span>
                            <span class="n">start</span> <span class="o">=</span> <span class="n">rstart</span>
                        <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">rend</span><span class="p">:</span>
                            <span class="n">end</span> <span class="o">=</span> <span class="n">rend</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># The range has a step bigger than the base</span>
                    <span class="c1"># interval we are building.  For us to absorb</span>
                    <span class="c1"># it, it has to be contained within the current</span>
                    <span class="c1"># interval +/- step.</span>
                    <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">rstart</span> <span class="o">+</span> <span class="n">step</span> <span class="ow">and</span> <span class="n">end</span> <span class="o">&gt;=</span> <span class="n">rend</span> <span class="o">-</span> <span class="n">step</span><span class="p">:</span>
                        <span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">rstart</span><span class="p">:</span>
                            <span class="n">start</span> <span class="o">=</span> <span class="n">rstart</span>
                        <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">rend</span><span class="p">:</span>
                            <span class="n">end</span> <span class="o">=</span> <span class="n">rend</span>

            <span class="n">ranges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">ranges</span> <span class="k">if</span> <span class="n">_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">_rlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>
        <span class="c1"># Note: while unbounded NumericRanges are -inf..inf, Pyomo</span>
        <span class="c1"># Sets are None..None</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="o">-</span><span class="n">_inf</span> <span class="k">else</span> <span class="n">start</span><span class="p">,</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">end</span> <span class="o">==</span> <span class="n">_inf</span> <span class="k">else</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_continuous_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Note: this method assumes that at least one range is continuous.</span>
        <span class="c1">#</span>
        <span class="c1"># Note: I&#39;d like to use set() for ranges, since we will be</span>
        <span class="c1"># randomly removing elelments from the list; however, since we</span>
        <span class="c1"># do it by enumerating over ranges, using set() would make this</span>
        <span class="c1"># routine nondeterministic.  Not a hoge issue for the result,</span>
        <span class="c1"># but problemmatic for code coverage.</span>
        <span class="c1">#</span>
        <span class="c1"># Note: We do not need to trap non-NumericRange objects:</span>
        <span class="c1"># RangeProduct and AnyRange will be caught by the dimen test in</span>
        <span class="c1"># get_interval(), and NonNumericRange objects are cleanly</span>
        <span class="c1"># handled as if they were regular discrete ranges.</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">discrete</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Pull out the discrete intervals (for checking later), and</span>
        <span class="c1"># copy the continuous ranges (so we can later make them</span>
        <span class="c1"># closed, if applicable)</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">isdiscrete</span><span class="p">():</span>
                <span class="n">discrete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NumericRange</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">closed</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">discrete</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="kc">None</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span> <span class="o">==</span> <span class="o">-</span><span class="n">_inf</span> <span class="k">else</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                <span class="kc">None</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span> <span class="o">==</span> <span class="n">_inf</span> <span class="k">else</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                <span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">step</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="c1"># There is a particular edge case where we could get 2 disjoint</span>
        <span class="c1"># continuous ranges that are joined by a discrete range...  When</span>
        <span class="c1"># we encounter an open range, check to see if the endpoint is</span>
        <span class="c1"># in the discrete set, and if so, convert it to a closed range.</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">closed</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">discrete</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                        <span class="n">r</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">closed</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">closed</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">discrete</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                        <span class="n">r</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">closed</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>
                        <span class="k">break</span>

        <span class="n">nRanges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">ranges</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="n">NumericRange</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">closed</span><span class="p">)</span>
        <span class="n">_rlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span>

        <span class="c1"># This loop terminates when we have a complete pass that doesn&#39;t</span>
        <span class="c1"># remove any ranges from the ranges list.</span>
        <span class="k">while</span> <span class="n">_rlen</span> <span class="ow">and</span> <span class="n">nRanges</span> <span class="o">&gt;</span> <span class="n">_rlen</span><span class="p">:</span>
            <span class="n">nRanges</span> <span class="o">=</span> <span class="n">_rlen</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ranges</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">interval</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="c1"># r and interval overlap: merge r into interval</span>
                <span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                    <span class="n">interval</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span>
                    <span class="n">interval</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">closed</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">interval</span><span class="o">.</span><span class="n">closed</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">interval</span><span class="o">.</span><span class="n">closed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span> <span class="o">==</span> <span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                    <span class="n">interval</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">closed</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">interval</span><span class="o">.</span><span class="n">closed</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                    <span class="n">interval</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span>
                    <span class="n">interval</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">closed</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="o">.</span><span class="n">closed</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">interval</span><span class="o">.</span><span class="n">closed</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span> <span class="o">==</span> <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                    <span class="n">interval</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">closed</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="o">.</span><span class="n">closed</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">ranges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">ranges</span> <span class="k">if</span> <span class="n">_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">_rlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="c1"># The continuous ranges are disjoint</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">discrete</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">interval</span><span class="p">):</span>
                <span class="c1"># The discrete range extends outside the continuous</span>
                <span class="c1"># interval</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">interval</span><span class="o">.</span><span class="n">start</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="o">-</span><span class="n">_inf</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">interval</span><span class="o">.</span><span class="n">end</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">==</span> <span class="n">_inf</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;The &#39;virtual&#39; attribute is no longer supported&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.7&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">virtual</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">_AnySet</span><span class="p">,</span> <span class="n">SetOperator</span><span class="p">,</span> <span class="n">_InfiniteRangeSetData</span><span class="p">))</span>

    <span class="nd">@virtual</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">virtual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Attempting to set the (deprecated) &#39;virtual&#39; attribute on </span><span class="si">%s</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;to an invalid value (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;The &#39;concrete&#39; attribute is no longer supported.  &quot;</span>
        <span class="s2">&quot;Use isdiscrete() or isfinite()&quot;</span><span class="p">,</span>
        <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.7&#39;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">concrete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfinite</span><span class="p">()</span>

    <span class="nd">@concrete</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">concrete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">concrete</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Attempting to set the (deprecated) &#39;concrete&#39; attribute on </span><span class="si">%s</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;to an invalid value (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;The &#39;ordered&#39; attribute is no longer supported.  Use isordered()&quot;</span><span class="p">,</span>
        <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.7&#39;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">ordered</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isordered</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;&#39;filter&#39; is no longer a public attribute.&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.7&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;check_values() is deprecated: Sets only contain valid members&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.7&#39;</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">check_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that the values in this set are valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">isdisjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if this Set is disjoint from `other`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            other : ``Set`` or ``iterable``</span>
<span class="sd">                The Set or iterable object to compare this Set against</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool : True if this set is disjoint from `other`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;isfinite&#39;</span><span class="p">):</span>
            <span class="n">other_isfinite</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">isfinite</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;__contains__&#39;</span><span class="p">):</span>
            <span class="c1"># we assume that everything that does not implement</span>
            <span class="c1"># isfinite() is a discrete set.</span>
            <span class="n">other_isfinite</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># For efficiency, if the other is not a Set, we will try</span>
                <span class="c1"># converting it to a Python set() for efficient lookup.</span>
                <span class="n">other</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Raise an exception consistent with Python&#39;s set.isdisjoint()</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; object is not iterable&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfinite</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">other_isfinite</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">all</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">ranges</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">issubset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if this Set is a subset of `other`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            other : ``Set`` or ``iterable``</span>
<span class="sd">                The Set or iterable object to compare this Set against</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool : True if this set is a subset of `other`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Special case: non-finite range sets that only contain finite</span>
        <span class="c1"># ranges (or no ranges).  We will re-generate non-finite sets to</span>
        <span class="c1"># make sure we get an accurate &quot;finiteness&quot; flag.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;isfinite&#39;</span><span class="p">):</span>
            <span class="n">other_isfinite</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">isfinite</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">other_isfinite</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="n">RangeSet</span><span class="p">(</span><span class="n">ranges</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">ranges</span><span class="p">()))</span>
                    <span class="n">other_isfinite</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">isfinite</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;__contains__&#39;</span><span class="p">):</span>
            <span class="c1"># we assume that everything that does not implement</span>
            <span class="c1"># isfinite() is a discrete set.</span>
            <span class="n">other_isfinite</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># For efficiency, if the other is not a Set, we will try</span>
                <span class="c1"># converting it to a Python set() for efficient lookup.</span>
                <span class="n">other</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Raise an exception consistent with Python&#39;s set.issubset()</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; object is not iterable&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfinite</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="n">RangeSet</span><span class="p">(</span><span class="n">ranges</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">()))</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfinite</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">other_isfinite</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">range_difference</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">ranges</span><span class="p">()):</span>
                        <span class="k">return</span> <span class="kc">False</span>
                <span class="k">except</span> <span class="n">RangeDifferenceError</span><span class="p">:</span>
                    <span class="c1"># This only occurs when subtracting an infinite</span>
                    <span class="c1"># discrete set from an infinite continuous set, so r</span>
                    <span class="c1"># (and hence self) cannot be a subset of other</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">issuperset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if this Set is a superset of `other`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            other : ``Set`` or ``iterable``</span>
<span class="sd">                The Set or iterable object to compare this Set against</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool : True if this set is a superset of `other`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Special case: non-finite range sets that only contain finite</span>
        <span class="c1"># ranges (or no ranges).  We will re-generate non-finite sets to</span>
        <span class="c1"># make sure we get an accurate &quot;finiteness&quot; flag.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;isfinite&#39;</span><span class="p">):</span>
            <span class="n">other_isfinite</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">isfinite</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">other_isfinite</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="n">RangeSet</span><span class="p">(</span><span class="n">ranges</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">ranges</span><span class="p">()))</span>
                    <span class="n">other_isfinite</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">isfinite</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;__contains__&#39;</span><span class="p">):</span>
            <span class="c1"># we assume that everything that does not implement</span>
            <span class="c1"># isfinite() is a discrete set.</span>
            <span class="n">other_isfinite</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># For efficiency, if the other is not a Set, we will try</span>
                <span class="c1"># converting it to a Python set() for efficient lookup.</span>
                <span class="n">other</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Raise an exception consistent with Python&#39;s set.issuperset()</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; object is not iterable&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">other_isfinite</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="c1"># Other may contain elements that are not representable</span>
                <span class="c1"># in self.  Trap that error (a TypeError due to hashing)</span>
                <span class="c1"># and return False</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfinite</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="n">RangeSet</span><span class="p">(</span><span class="n">ranges</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">()))</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfinite</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the union of this set with one or more sets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">SetUnion</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmp</span>

    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the intersection of this set with one or more sets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">SetIntersection</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmp</span>

    <span class="k">def</span> <span class="nf">difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the difference between this set with one or more sets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">SetDifference</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmp</span>

    <span class="k">def</span> <span class="nf">symmetric_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the symmetric difference of this set with another set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SetSymmetricDifference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cross-product between this set and one or more sets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SetProduct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="c1"># &lt;= is equivalent to issubset</span>
    <span class="c1"># &gt;= is equivalent to issuperset</span>
    <span class="c1"># |  is equivalent to union</span>
    <span class="c1"># &amp;  is equivalent to intersection</span>
    <span class="c1"># -  is equivalent to difference</span>
    <span class="c1"># ^  is equivalent to symmetric_difference</span>
    <span class="c1"># *  is equivalent to cross</span>

    <span class="fm">__le__</span> <span class="o">=</span> <span class="n">issubset</span>
    <span class="fm">__ge__</span> <span class="o">=</span> <span class="n">issuperset</span>
    <span class="fm">__or__</span> <span class="o">=</span> <span class="n">union</span>
    <span class="fm">__and__</span> <span class="o">=</span> <span class="n">intersection</span>
    <span class="fm">__sub__</span> <span class="o">=</span> <span class="n">difference</span>
    <span class="fm">__xor__</span> <span class="o">=</span> <span class="n">symmetric_difference</span>
    <span class="fm">__mul__</span> <span class="o">=</span> <span class="n">cross</span>

    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># See the discussion of Set vs SetOf in process_setarg above</span>
        <span class="c1">#</span>
        <span class="c1"># return SetOf(other) | self</span>
        <span class="k">return</span> <span class="n">process_setarg</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">|</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__rand__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># See the discussion of Set vs SetOf in process_setarg above</span>
        <span class="c1">#</span>
        <span class="c1"># return SetOf(other) &amp; self</span>
        <span class="k">return</span> <span class="n">process_setarg</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># See the discussion of Set vs SetOf in process_setarg above</span>
        <span class="c1">#</span>
        <span class="c1"># return SetOf(other) - self</span>
        <span class="k">return</span> <span class="n">process_setarg</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__rxor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># See the discussion of Set vs SetOf in process_setarg above</span>
        <span class="c1">#</span>
        <span class="c1"># return SetOf(other) ^ self</span>
        <span class="k">return</span> <span class="n">process_setarg</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">^</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># See the discussion of Set vs SetOf in process_setarg above</span>
        <span class="c1">#</span>
        <span class="c1"># return SetOf(other) * self</span>
        <span class="k">return</span> <span class="n">process_setarg</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the set is a strict subset of &#39;other&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">&lt;=</span> <span class="n">other</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the set is a strict superset of &#39;other&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">&gt;=</span> <span class="n">other</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>


<span class="k">class</span> <span class="nc">_FiniteSetMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">DeveloperError</span><span class="p">(</span>
            <span class="s2">&quot;Derived finite set class (</span><span class="si">%s</span><span class="s2">) failed to &quot;</span>
            <span class="s2">&quot;implement __len__&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_iter_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">DeveloperError</span><span class="p">(</span>
            <span class="s2">&quot;Derived finite set class (</span><span class="si">%s</span><span class="s2">) failed to &quot;</span>
            <span class="s2">&quot;implement _iter_impl&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over the finite set</span>

<span class="sd">        Note: derived classes should NOT reimplement this method, and</span>
<span class="sd">        should instead overload _iter_impl.  The expression template</span>
<span class="sd">        system relies on being able to replace this method for all Sets</span>
<span class="sd">        during template generation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_impl</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">isdiscrete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if this set admits only discrete members&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if this is a finite discrete (iterable) Set&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;The &#39;value&#39; attribute is deprecated.  Use .data() to &quot;</span>
        <span class="s2">&quot;retrieve the values in a finite set.&quot;</span><span class="p">,</span>
        <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.7&#39;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;The &#39;value_list&#39; attribute is deprecated.  Use &quot;</span>
        <span class="s2">&quot;.ordered_data() to retrieve the values from a finite set &quot;</span>
        <span class="s2">&quot;in a deterministic order.&quot;</span><span class="p">,</span>
        <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.7&#39;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">value_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ordered_data</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">sorted_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sorted_robust</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">ordered_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_data</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="n">ub</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Python2/3 consistency: We will follow the Python3 convention</span>
        <span class="c1"># and not assume numeric/nonnumeric types are comparable.  If a</span>
        <span class="c1"># set is mixed non-numeric type, then we will report the bounds</span>
        <span class="c1"># as None.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">native_numeric_types</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">ub</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">native_numeric_types</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span>

    <span class="k">def</span> <span class="nf">ranges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># This is way inefficient, but should always work: the ranges in a</span>
        <span class="c1"># Finite set is the list of scalars</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">in</span> <span class="n">native_numeric_types</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">NumericRange</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">i</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">in</span> <span class="n">native_types</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">NonNumericRange</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Because of things like SetOf, self could contain types</span>
                <span class="c1"># we have never seen before.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">as_numeric</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">NumericRange</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">NonNumericRange</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_FiniteSetData</span><span class="p">(</span><span class="n">_FiniteSetMixin</span><span class="p">,</span> <span class="n">_SetData</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A general unordered iterable Set&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_values&#39;</span><span class="p">,</span> <span class="s1">&#39;_domain&#39;</span><span class="p">,</span> <span class="s1">&#39;_validate&#39;</span><span class="p">,</span> <span class="s1">&#39;_filter&#39;</span><span class="p">,</span> <span class="s1">&#39;_dimen&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
        <span class="n">_SetData</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">component</span><span class="p">)</span>
        <span class="c1"># Derived classes (like _OrderedSetData) may want to change the</span>
        <span class="c1"># storage</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_values&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_domain</span> <span class="o">=</span> <span class="n">Any</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dimen</span> <span class="o">=</span> <span class="n">UnknownSetDimen</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the set contains a given value.</span>

<span class="sd">        This method will raise TypeError for unhashable types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">normalize_index</span><span class="o">.</span><span class="n">flatten</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">normalize_index</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">_iter_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of elements in the set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span><span class="o">.</span><span class="n">_constructed</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimen</span> <span class="ow">is</span> <span class="n">UnknownSetDimen</span><span class="p">:</span>
            <span class="c1"># Special case: abstract Sets with constant dimen</span>
            <span class="c1"># initializers have a known dimen before construction</span>
            <span class="n">_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_comp</span><span class="o">.</span><span class="n">_constructed</span> <span class="ow">and</span> <span class="n">_comp</span><span class="o">.</span><span class="n">_init_dimen</span><span class="o">.</span><span class="n">constant</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">_comp</span><span class="o">.</span><span class="n">_init_dimen</span><span class="o">.</span><span class="n">val</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimen</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_domain</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;&#39;filter&#39; is no longer a public attribute.&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.7&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">):</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">normalize_index</span><span class="o">.</span><span class="n">flatten</span><span class="p">:</span>
                <span class="n">_value</span> <span class="o">=</span> <span class="n">normalize_index</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">_value</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
                    <span class="n">_d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_value</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_d</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If we are not normalizing indices, then we cannot reliably</span>
                <span class="c1"># infer the set dimen</span>
                <span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>
                <span class="n">_d</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_domain</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot add value </span><span class="si">%s</span><span class="s2"> to Set </span><span class="si">%s</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">The value is not in the domain </span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_domain</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># We wrap this check in a try-except because some values</span>
            <span class="c1">#  (like lists) are not hashable and can raise exceptions.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s2">&quot;Element </span><span class="si">%s</span><span class="s2"> already exists in Set </span><span class="si">%s</span><span class="s2">; no action taken&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">continue</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">exc</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Unable to insert &#39;</span><span class="si">%s</span><span class="s2">&#39; into Set </span><span class="si">%s</span><span class="s2">:</span><span class="se">\n\t</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">exc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">exc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">(</span><span class="n">_block</span><span class="p">,</span> <span class="n">_value</span><span class="p">):</span>
                    <span class="k">continue</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">_block</span><span class="p">,</span> <span class="n">_value</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="s2">&quot;Exception raised while validating element &#39;</span><span class="si">%s</span><span class="s2">&#39; &quot;</span>
                        <span class="s2">&quot;for Set </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">raise</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;The value=</span><span class="si">%s</span><span class="s2"> violates the validation rule of Set </span><span class="si">%s</span><span class="s2">&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="p">)</span>

            <span class="c1"># If the Set has a fixed dimension, check that this element is</span>
            <span class="c1"># compatible.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_d</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimen</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimen</span> <span class="ow">is</span> <span class="n">UnknownSetDimen</span><span class="p">:</span>
                        <span class="c1"># The first thing added to a Set with unknown</span>
                        <span class="c1"># dimension sets its dimension</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_dimen</span> <span class="o">=</span> <span class="n">_d</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;The value=</span><span class="si">%s</span><span class="s2"> has dimension </span><span class="si">%s</span><span class="s2"> and is not &quot;</span>
                            <span class="s2">&quot;valid for Set </span><span class="si">%s</span><span class="s2"> which has dimen=</span><span class="si">%s</span><span class="s2">&quot;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimen</span><span class="p">)</span>
                        <span class="p">)</span>

            <span class="c1"># Add the value to this object (this last redirection allows</span>
            <span class="c1"># derived classes to implement a different storage mechanism)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_impl</span><span class="p">(</span><span class="n">_value</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">count</span>

    <span class="k">def</span> <span class="nf">_add_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">discard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">val</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">_ScalarOrderedSetMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># This mixin is required because scalar ordered sets implement</span>
    <span class="c1"># __getitem__() as an alias of at()</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator of the component data objects in the dictionary&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">yield</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator of (index,data) tuples from the dictionary&quot;&quot;&quot;</span>
        <span class="n">_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">_keys</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">_OrderedSetMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">_valid_getitem_keys</span> <span class="o">=</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,),</span> <span class="bp">Ellipsis</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">DeveloperError</span><span class="p">(</span>
            <span class="s2">&quot;Derived ordered set class (</span><span class="si">%s</span><span class="s2">) failed to &quot;</span>
            <span class="s2">&quot;implement at&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">ord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">DeveloperError</span><span class="p">(</span>
            <span class="s2">&quot;Derived ordered set class (</span><span class="si">%s</span><span class="s2">) failed to &quot;</span>
            <span class="s2">&quot;implement ord&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># If key looks like the valid key for UnindexedComponent_set, or</span>
        <span class="c1"># is an Ellipsis/slice (because someone is generating a</span>
        <span class="c1"># component slice), then treat this like a regular Scalar</span>
        <span class="c1"># component and defer to the IndexedComponent implementation.</span>
        <span class="c1"># In any other case, defer to the deprecated OrderedScalarSet</span>
        <span class="c1"># functionality</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_getitem_keys</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">slice</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">deprecation_warning</span><span class="p">(</span>
            <span class="s2">&quot;Using __getitem__ to return a set value from its (ordered) &quot;</span>
            <span class="s2">&quot;position is deprecated.  Please use at()&quot;</span><span class="p">,</span>
            <span class="n">version</span><span class="o">=</span><span class="s1">&#39;6.1&#39;</span><span class="p">,</span>
            <span class="n">remove_in</span><span class="o">=</span><span class="s1">&#39;7.0&#39;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;card() was incorrectly added to the Set API.  Please use at()&quot;</span><span class="p">,</span>
        <span class="n">version</span><span class="o">=</span><span class="s1">&#39;6.1.2&#39;</span><span class="p">,</span>
        <span class="n">remove_in</span><span class="o">=</span><span class="s1">&#39;6.2&#39;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">card</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isordered</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if this is an ordered finite discrete (iterable) Set&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">ordered_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the next item in the set.</span>

<span class="sd">        The default behavior is to return the very next element. The `step`</span>
<span class="sd">        option can specify how many steps are taken to get the next element.</span>

<span class="sd">        If the search item is not in the Set, or the next element is beyond</span>
<span class="sd">        the end of the set, then an IndexError is raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ord</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">+</span> <span class="n">step</span>
        <span class="k">if</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Cannot advance before the beginning of the Set&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">position</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Cannot advance past the end of the Set&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nextw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the next item in the set with wrapping if necessary.</span>

<span class="sd">        The default behavior is to return the very next element. The `step`</span>
<span class="sd">        option can specify how many steps are taken to get the next element.</span>
<span class="sd">        If the next element is past the end of the Set, the search wraps back</span>
<span class="sd">        to the beginning of the Set.</span>

<span class="sd">        If the search item is not in the Set an IndexError is raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ord</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">at</span><span class="p">((</span><span class="n">position</span> <span class="o">+</span> <span class="n">step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">prev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the previous item in the set.</span>

<span class="sd">        The default behavior is to return the immediately previous</span>
<span class="sd">        element. The `step` option can specify how many steps are taken</span>
<span class="sd">        to get the previous element.</span>

<span class="sd">        If the search item is not in the Set, or the previous element is</span>
<span class="sd">        before the beginning of the set, then an IndexError is raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="o">-</span><span class="n">step</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">prevw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the previous item in the set with wrapping if necessary.</span>

<span class="sd">        The default behavior is to return the immediately</span>
<span class="sd">        previouselement. The `step` option can specify how many steps</span>
<span class="sd">        are taken to get the previous element. If the previous element</span>
<span class="sd">        is past the end of the Set, the search wraps back to the end of</span>
<span class="sd">        the Set.</span>

<span class="sd">        If the search item is not in the Set an IndexError is raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nextw</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="o">-</span><span class="n">step</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_0_based_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="c1"># Efficiency note: unlike older Set implementations, this</span>
        <span class="c1"># implementation does not guarantee that the index is valid (it</span>
        <span class="c1"># could be outside of abs(i) &lt;= len(self)).</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> indices must be integers, not </span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="n">item</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> indices must be integers, not </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">item</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">item</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">item</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> index out of range&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,))</span>
            <span class="k">return</span> <span class="n">item</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;Pyomo Sets are 1-indexed: valid index values for Sets are &quot;</span>
                <span class="s2">&quot;[1 .. len(Set)] or [-1 .. -len(Set)]&quot;</span>
            <span class="p">)</span>


<span class="k">class</span> <span class="nc">_OrderedSetData</span><span class="p">(</span><span class="n">_OrderedSetMixin</span><span class="p">,</span> <span class="n">_FiniteSetData</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class defines the base class for an ordered set of concrete data.</span>

<span class="sd">    In older Pyomo terms, this defines a &quot;concrete&quot; ordered set - that is,</span>
<span class="sd">    a set that &quot;owns&quot; the list of set members.  While this class actually</span>
<span class="sd">    implements a set ordered by insertion order, we make the &quot;official&quot;</span>
<span class="sd">    _InsertionOrderSetData an empty derivative class, so that</span>

<span class="sd">         issubclass(_SortedSetData, _InsertionOrderSetData) == False</span>

<span class="sd">    Constructor Arguments:</span>
<span class="sd">        component   The Set object that owns this data.</span>

<span class="sd">    Public Class Attributes:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_ordered_values&#39;</span><span class="p">,)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ordered_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">_FiniteSetData</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">component</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_iter_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator for the set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ordered_values</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ordered_values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ordered_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ordered_values</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ordered_values</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ordered_values</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">discard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ordered_values</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="c1"># Map the index error to a KeyError for consistency with</span>
            <span class="c1"># set().pop()</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;pop from an empty set&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span>

    <span class="k">def</span> <span class="nf">at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the specified member of the set.</span>

<span class="sd">        The public Set API is 1-based, even though the</span>
<span class="sd">        internal _lookup and _values are (pythonically) 0-based.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_0_based_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ordered_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> index out of range&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">ord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the position index of the input value.</span>

<span class="sd">        Note that Pyomo Set objects have positions starting at 1 (not 0).</span>

<span class="sd">        If the search item is not in the Set, then an IndexError is raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The bulk of single-value set members are stored as scalars.</span>
        <span class="c1"># However, we are now being more careful about matching tuples</span>
        <span class="c1"># when they are actually put as Set members.  So, we will look</span>
        <span class="c1"># for the exact thing that the user sent us and then fall back</span>
        <span class="c1"># on the scalar.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">tuple</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.ord(x): x not in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.ord(x): x not in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">_InsertionOrderSetData</span><span class="p">(</span><span class="n">_OrderedSetData</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class defines the data for a ordered set where the items are ordered</span>
<span class="sd">    in insertion order (similar to Python&#39;s OrderedSet.</span>

<span class="sd">    Constructor Arguments:</span>
<span class="sd">        component   The Set object that owns this data.</span>

<span class="sd">    Public Class Attributes:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">Set</span><span class="o">.</span><span class="n">_UnorderedInitializers</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Calling set_value() on an insertion order Set with &quot;</span>
                <span class="s2">&quot;a fundamentally unordered data source (type: </span><span class="si">%s</span><span class="s2">).  &quot;</span>
                <span class="s2">&quot;This WILL potentially lead to nondeterministic behavior &quot;</span>
                <span class="s2">&quot;in Pyomo&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span>
            <span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_InsertionOrderSetData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="ow">in</span> <span class="n">Set</span><span class="o">.</span><span class="n">_UnorderedInitializers</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Calling update() on an insertion order Set with &quot;</span>
                <span class="s2">&quot;a fundamentally unordered data source (type: </span><span class="si">%s</span><span class="s2">).  &quot;</span>
                <span class="s2">&quot;This WILL potentially lead to nondeterministic behavior &quot;</span>
                <span class="s2">&quot;in Pyomo&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span>
            <span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_InsertionOrderSetData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_SortedSetMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>


<span class="k">class</span> <span class="nc">_SortedSetData</span><span class="p">(</span><span class="n">_SortedSetMixin</span><span class="p">,</span> <span class="n">_OrderedSetData</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class defines the data for a sorted set.</span>

<span class="sd">    Constructor Arguments:</span>
<span class="sd">        component   The Set object that owns this data.</span>

<span class="sd">    Public Class Attributes:</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_is_sorted&#39;</span><span class="p">,)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
        <span class="c1"># An empty set is sorted...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_sorted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">_OrderedSetData</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">component</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_iter_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator for the set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_sorted</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">_SortedSetData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_iter_impl</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_sorted</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">_SortedSetData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__reversed__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_add_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># Note that the sorted status has no bearing on insertion,</span>
        <span class="c1"># so there is no reason to check if the data is correctly sorted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ordered_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_sorted</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Note: removing data does not affect the sorted flag</span>
    <span class="c1"># def remove(self, val):</span>
    <span class="c1"># def discard(self, val):</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_SortedSetData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_sorted</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the specified member of the set.</span>

<span class="sd">        The public Set API is 1-based, even though the</span>
<span class="sd">        internal _lookup and _values are (pythonically) 0-based.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_sorted</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">_SortedSetData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the position index of the input value.</span>

<span class="sd">        Note that Pyomo Set objects have positions starting at 1 (not 0).</span>

<span class="sd">        If the search item is not in the Set, then an IndexError is raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_sorted</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">_SortedSetData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">ord</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sorted_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ordered_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span><span class="o">.</span><span class="n">_sort_fcn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ordered_values</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="p">{</span><span class="n">j</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ordered_values</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_sorted</span> <span class="o">=</span> <span class="kc">True</span>


<span class="c1">############################################################################</span>

<span class="n">_SET_API</span> <span class="o">=</span> <span class="p">((</span><span class="s1">&#39;__contains__&#39;</span><span class="p">,</span> <span class="s1">&#39;test membership in&#39;</span><span class="p">),</span> <span class="s1">&#39;get&#39;</span><span class="p">,</span> <span class="s1">&#39;ranges&#39;</span><span class="p">,</span> <span class="s1">&#39;bounds&#39;</span><span class="p">)</span>
<span class="n">_FINITESET_API</span> <span class="o">=</span> <span class="n">_SET_API</span> <span class="o">+</span> <span class="p">(</span>
    <span class="p">(</span><span class="s1">&#39;__iter__&#39;</span><span class="p">,</span> <span class="s1">&#39;iterate over&#39;</span><span class="p">),</span>
    <span class="s1">&#39;__reversed__&#39;</span><span class="p">,</span>
    <span class="s1">&#39;__len__&#39;</span><span class="p">,</span>
    <span class="s1">&#39;data&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sorted_data&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ordered_data&#39;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">_ORDEREDSET_API</span> <span class="o">=</span> <span class="n">_FINITESET_API</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;at&#39;</span><span class="p">,</span> <span class="s1">&#39;ord&#39;</span><span class="p">)</span>
<span class="n">_SETDATA_API</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;set_value&#39;</span><span class="p">,</span> <span class="s1">&#39;add&#39;</span><span class="p">,</span> <span class="s1">&#39;remove&#39;</span><span class="p">,</span> <span class="s1">&#39;discard&#39;</span><span class="p">,</span> <span class="s1">&#39;clear&#39;</span><span class="p">,</span> <span class="s1">&#39;update&#39;</span><span class="p">,</span> <span class="s1">&#39;pop&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="Set"><a class="viewcode-back" href="../../../../library_reference/aml/index.html#pyomo.environ.Set">[docs]</a><span class="nd">@ModelComponentFactory</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;Set data that is used to define a model instance.&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Set</span><span class="p">(</span><span class="n">IndexedComponent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A component used to index other Pyomo components.</span>

<span class="sd">    This class provides a Pyomo component that is API-compatible with</span>
<span class="sd">    Python `set` objects, with additional features, including:</span>

<span class="sd">        1. Member validation and filtering.  The user can declare</span>
<span class="sd">           domains and provide callback functions to validate set</span>
<span class="sd">           members and to filter (ignore) potential members.</span>
<span class="sd">        2. Set expressions.  Operations on Set objects (&amp;,|,*,-,^)</span>
<span class="sd">           produce Set expressions that preserve their references to the</span>
<span class="sd">           original Set objects so that updating the argument Sets</span>
<span class="sd">           implicitly updates the Set operator instance.</span>
<span class="sd">        3. Support for set operations with RangeSet instances (both</span>
<span class="sd">           finite and non-finite ranges).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    initialize : initializer(iterable), optional</span>
<span class="sd">        The initial values to store in the Set when it is</span>
<span class="sd">        constructed.  Values passed to ``initialize`` may be</span>
<span class="sd">        overridden by ``data`` passed to the :py:meth:`construct`</span>
<span class="sd">        method.</span>

<span class="sd">    dimen : initializer(int), optional</span>
<span class="sd">        Specify the Set&#39;s arity (the required tuple length for all</span>
<span class="sd">        members of the Set), or None if no arity is enforced</span>

<span class="sd">    ordered : bool or Set.InsertionOrder or Set.SortedOrder or function</span>
<span class="sd">        Specifies whether the set is ordered.</span>
<span class="sd">        Possible values are:</span>

<span class="sd">          ======================  =====================================</span>
<span class="sd">          ``False``               Unordered</span>
<span class="sd">          ``True``                Ordered by insertion order</span>
<span class="sd">          ``Set.InsertionOrder``  Ordered by insertion order [default]</span>
<span class="sd">          ``Set.SortedOrder``     Ordered by sort order</span>
<span class="sd">          ``&lt;function&gt;``          Ordered with this comparison function</span>
<span class="sd">          ======================  =====================================</span>

<span class="sd">    within : initialiser(set), optional</span>
<span class="sd">        A set that defines the valid values that can be contained</span>
<span class="sd">        in this set</span>
<span class="sd">    domain : initializer(set), optional</span>
<span class="sd">        A set that defines the valid values that can be contained</span>
<span class="sd">        in this set</span>
<span class="sd">    bounds : initializer(tuple), optional</span>
<span class="sd">        A tuple that specifies the bounds for valid Set values</span>
<span class="sd">        (accepts 1-, 2-, or 3-tuple RangeSet arguments)</span>
<span class="sd">    filter : initializer(rule), optional</span>
<span class="sd">        A rule for determining membership in this set. This has the</span>
<span class="sd">        functional form:</span>

<span class="sd">            ``f: Block, *data -&gt; bool``</span>

<span class="sd">        and returns True if the data belongs in the set.  Set will</span>
<span class="sd">        quietly ignore any values where `filter` returns False.</span>
<span class="sd">    validate : initializer(rule), optional</span>
<span class="sd">        A rule for validating membership in this set. This has the</span>
<span class="sd">        functional form:</span>

<span class="sd">            ``f: Block, *data -&gt; bool``</span>

<span class="sd">        and returns True if the data belongs in the set.  Set will</span>
<span class="sd">        raise a ``ValueError`` for any values where `validate`</span>
<span class="sd">        returns False.</span>

<span class="sd">    name : str, optional</span>
<span class="sd">        The name of the set</span>

<span class="sd">    doc : str, optional</span>
<span class="sd">        A text string describing this component</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">      .. note::</span>

<span class="sd">        ``domain=``, ``within=``, and ``bounds=`` all provide</span>
<span class="sd">        restrictions on the valid set values.  If more than one is</span>
<span class="sd">        specified, Set values will be restricted to the intersection of</span>
<span class="sd">        ``domain``, ``within``, and ``bounds``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">End</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">class</span> <span class="nc">Skip</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">class</span> <span class="nc">InsertionOrder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">class</span> <span class="nc">SortedOrder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="n">_ValidOrderedAuguments</span> <span class="o">=</span> <span class="p">{</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">InsertionOrder</span><span class="p">,</span> <span class="n">SortedOrder</span><span class="p">}</span>
    <span class="n">_UnorderedInitializers</span> <span class="o">=</span> <span class="p">{</span><span class="nb">set</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">_prePython37</span><span class="p">:</span>
        <span class="n">_UnorderedInitializers</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Set</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="c1"># TBD: Should ordered be allowed to vary across an IndexedSet?</span>
        <span class="c1">#</span>
        <span class="c1"># Many things are easier by forcing it to be consistent across</span>
        <span class="c1"># the set (namely, the _ComponentDataClass is constant).</span>
        <span class="c1"># However, it is a bit off that &#39;ordered&#39; it the only arg NOT</span>
        <span class="c1"># processed by Initializer.  We can mock up a _SortedSetData</span>
        <span class="c1"># sort function that preserves Insertion Order (lambda x: x), but</span>
        <span class="c1"># the unsorted is harder (it would effectively be insertion</span>
        <span class="c1"># order, but ordered() may not be deterministic based on how the</span>
        <span class="c1"># set was populated - and we could not issue a warning?)</span>
        <span class="c1">#</span>
        <span class="c1"># JDS [5/2019]: Until someone demands otherwise, I think we</span>
        <span class="c1"># should leave it constant across an IndexedSet</span>
        <span class="n">ordered</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ordered&#39;</span><span class="p">,</span> <span class="n">Set</span><span class="o">.</span><span class="n">InsertionOrder</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ordered</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">ordered</span> <span class="o">=</span> <span class="n">Set</span><span class="o">.</span><span class="n">InsertionOrder</span>
        <span class="k">if</span> <span class="n">ordered</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Set</span><span class="o">.</span><span class="n">_ValidOrderedAuguments</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">ordered</span><span class="p">):</span>
                <span class="n">ordered</span> <span class="o">=</span> <span class="n">Set</span><span class="o">.</span><span class="n">SortedOrder</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We want the list to be deterministic, but not</span>
                <span class="c1"># alphabetical, so we first sort by type and then</span>
                <span class="c1"># convert evetything to string.  Note that we have to</span>
                <span class="c1"># convert *types* to string early, as the default</span>
                <span class="c1"># ordering of types is random: so InsertionOrder and</span>
                <span class="c1"># SortedOrder would occasionally swap places.</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Set &#39;ordered&#39; argument is not valid (must be one of {</span><span class="si">%s</span><span class="s2">})&quot;</span>
                    <span class="o">%</span> <span class="p">(</span>
                        <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                            <span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">sorted_robust</span><span class="p">(</span>
                                <span class="s1">&#39;Set.&#39;</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span>
                                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Set</span><span class="o">.</span><span class="n">_ValidOrderedAuguments</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                                    <span class="p">{</span><span class="s1">&#39;&lt;function&gt;&#39;</span><span class="p">}</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span> <span class="ow">or</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">UnindexedComponent_set</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ordered</span> <span class="ow">is</span> <span class="n">Set</span><span class="o">.</span><span class="n">InsertionOrder</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">AbstractOrderedScalarSet</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ordered</span> <span class="ow">is</span> <span class="n">Set</span><span class="o">.</span><span class="n">SortedOrder</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">AbstractSortedScalarSet</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">AbstractFiniteScalarSet</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newObj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Set</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">IndexedSet</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ordered</span> <span class="ow">is</span> <span class="n">Set</span><span class="o">.</span><span class="n">InsertionOrder</span><span class="p">:</span>
                <span class="n">newObj</span><span class="o">.</span><span class="n">_ComponentDataClass</span> <span class="o">=</span> <span class="n">_InsertionOrderSetData</span>
            <span class="k">elif</span> <span class="n">ordered</span> <span class="ow">is</span> <span class="n">Set</span><span class="o">.</span><span class="n">SortedOrder</span><span class="p">:</span>
                <span class="n">newObj</span><span class="o">.</span><span class="n">_ComponentDataClass</span> <span class="o">=</span> <span class="n">_SortedSetData</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newObj</span><span class="o">.</span><span class="n">_ComponentDataClass</span> <span class="o">=</span> <span class="n">_FiniteSetData</span>
            <span class="k">return</span> <span class="n">newObj</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">indexes</span><span class="p">,</span>
        <span class="n">initialize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dimen</span><span class="o">=</span><span class="n">UnknownSetDimen</span><span class="p">,</span>
        <span class="n">ordered</span><span class="o">=</span><span class="n">InsertionOrder</span><span class="p">,</span>
        <span class="n">within</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">domain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">validate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ctype&#39;</span><span class="p">,</span> <span class="n">Set</span><span class="p">)</span>

        <span class="c1"># The ordered flag was processed by __new__, but if this is a</span>
        <span class="c1"># sorted set, then we need to set the sorting function</span>
        <span class="n">_ordered</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ordered&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_ordered</span> <span class="ow">and</span> <span class="n">_ordered</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Set</span><span class="o">.</span><span class="n">InsertionOrder</span> <span class="ow">and</span> <span class="n">_ordered</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">_ordered</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sort_fcn</span> <span class="o">=</span> <span class="n">_ordered</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sort_fcn</span> <span class="o">=</span> <span class="n">sorted_robust</span>

        <span class="c1"># &#39;domain&#39;, &#39;within&#39;, and &#39;bounds&#39; are synonyms, in that they</span>
        <span class="c1"># restrict the set of valid set values.  If more than one is</span>
        <span class="c1"># specified, we will restrict the Set values to the intersection</span>
        <span class="c1"># of the individual arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_domain</span> <span class="o">=</span> <span class="n">SetInitializer</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">_domain</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;domain&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_domain</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">SetInitializer</span><span class="p">(</span><span class="n">_domain</span><span class="p">))</span>
        <span class="n">_within</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;within&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_within</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_domain</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">SetInitializer</span><span class="p">(</span><span class="n">_within</span><span class="p">))</span>
        <span class="n">_bounds</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;bounds&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_domain</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">BoundsInitializer</span><span class="p">(</span><span class="n">_bounds</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_dimen</span> <span class="o">=</span> <span class="n">Initializer</span><span class="p">(</span>
            <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dimen&#39;</span><span class="p">,</span> <span class="n">UnknownSetDimen</span><span class="p">),</span> <span class="n">arg_not_specified</span><span class="o">=</span><span class="n">NOTSET</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_values</span> <span class="o">=</span> <span class="n">TuplizeValuesInitializer</span><span class="p">(</span>
            <span class="n">Initializer</span><span class="p">(</span>
                <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;initialize&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="n">treat_sequences_as_mappings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">allow_generators</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_validate</span> <span class="o">=</span> <span class="n">Initializer</span><span class="p">(</span><span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;validate&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_filter</span> <span class="o">=</span> <span class="n">Initializer</span><span class="p">(</span><span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;filter&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="k">if</span> <span class="s1">&#39;virtual&#39;</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="n">deprecation_warning</span><span class="p">(</span>
                <span class="s2">&quot;Pyomo Sets ignore the &#39;virtual&#39; keyword argument&quot;</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="s1">&#39;pyomo.core.base&#39;</span><span class="p">,</span>
                <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.6.7&#39;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;virtual&#39;</span><span class="p">)</span>

        <span class="n">IndexedComponent</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

        <span class="c1"># HACK to make the &quot;counted call&quot; syntax work.  We wait until</span>
        <span class="c1"># after the base class is set up so that is_indexed() is</span>
        <span class="c1"># reliable.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_values</span><span class="o">.</span><span class="n">_init</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">IndexedCallInitializer</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_values</span><span class="o">.</span><span class="n">_init</span> <span class="o">=</span> <span class="n">CountedCallInitializer</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_values</span><span class="o">.</span><span class="n">_init</span>
            <span class="p">)</span>
        <span class="c1"># HACK: the DAT parser needs to know the domain of a set in</span>
        <span class="c1"># order to correctly parse the data stream.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_domain</span><span class="o">.</span><span class="n">constant</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_domain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_domain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_block</span><span class="p">(),</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_dimen</span><span class="o">.</span><span class="n">constant</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dimen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_dimen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_block</span><span class="p">(),</span> <span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="Set.check_values"><a class="viewcode-back" href="../../../../library_reference/aml/index.html#pyomo.environ.Set.check_values">[docs]</a>    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;check_values() is deprecated: Sets only contain valid members&quot;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.7&#39;</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">check_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that the values in this set are valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Set.construct"><a class="viewcode-back" href="../../../../library_reference/aml/index.html#pyomo.environ.Set.construct">[docs]</a>    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructed</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">timer</span> <span class="o">=</span> <span class="n">ConstructionTimer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_debug_set</span><span class="p">(</span><span class="n">logger</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Constructing Set, name=</span><span class="si">%s</span><span class="s2">, from data=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constructed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Data supplied to construct() should override data provided</span>
            <span class="c1"># to the constructor</span>
            <span class="n">tmp_init</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_values</span><span class="p">,</span> <span class="n">TuplizeValuesInitializer</span><span class="p">(</span>
                <span class="n">Initializer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">treat_sequences_as_mappings</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
                    <span class="c1"># This ensures backwards compatibility by causing all</span>
                    <span class="c1"># scalar sets (including set operators) to be</span>
                    <span class="c1"># initialized (and potentially empty) after construct().</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_getitem_when_not_present</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_values</span><span class="o">.</span><span class="n">contains_indices</span><span class="p">():</span>
                <span class="c1"># The index is coming in externally; we need to validate it</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_values</span><span class="o">.</span><span class="n">indices</span><span class="p">():</span>
                    <span class="n">IndexedComponent</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Bypass the index validation and create the member directly</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_set</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_getitem_when_not_present</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># Restore the original initializer (if overridden by data argument)</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_init_values</span> <span class="o">=</span> <span class="n">tmp_init</span>
        <span class="n">timer</span><span class="o">.</span><span class="n">report</span><span class="p">()</span></div>

    <span class="c1">#</span>
    <span class="c1"># This method must be defined on subclasses of</span>
    <span class="c1"># IndexedComponent that support implicit definition</span>
    <span class="c1">#</span>
    <span class="k">def</span> <span class="nf">_getitem_when_not_present</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the default component data value.&quot;&quot;&quot;</span>
        <span class="c1"># Because we allow sets within an IndexedSet to have different</span>
        <span class="c1"># dimen, we have moved the tuplization logic from PyomoModel</span>
        <span class="c1"># into Set (because we cannot know the dimen of a _SetData until</span>
        <span class="c1"># we are actually constructing that index).  This also means</span>
        <span class="c1"># that we need to potentially communicate the dimen to the</span>
        <span class="c1"># (wrapped) value initializer.  So, we will get the dimen first,</span>
        <span class="c1"># then get the values.  Only then will we know that this index</span>
        <span class="c1"># will actually be constructed (and not Skipped).</span>
        <span class="n">_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span>

        <span class="c1"># Note: _init_dimen and _init_domain are guaranteed to be non-None</span>
        <span class="n">_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_dimen</span><span class="p">(</span><span class="n">_block</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">normalize_index</span><span class="o">.</span><span class="n">flatten</span> <span class="ow">and</span> <span class="n">_d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">UnknownSetDimen</span> <span class="ow">and</span> <span class="n">_d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Ignoring non-None dimen (</span><span class="si">%s</span><span class="s2">) for set </span><span class="si">%s%s</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;(normalize_index.flatten is False, so dimen &quot;</span>
                <span class="s2">&quot;verification is not available).&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">index</span><span class="p">,)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">_d</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">domain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_domain</span><span class="p">(</span><span class="n">_block</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_d</span> <span class="ow">is</span> <span class="n">UnknownSetDimen</span> <span class="ow">and</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">domain</span><span class="o">.</span><span class="n">dimen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_d</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">dimen</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_values</span><span class="o">.</span><span class="n">_dimen</span> <span class="o">=</span> <span class="n">_d</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_values</span><span class="p">(</span><span class="n">_block</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">TuplizeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="n">index</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">_values</span> <span class="ow">is</span> <span class="n">Set</span><span class="o">.</span><span class="n">Skip</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="n">_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Set rule or initializer returned None instead of Set.Skip&quot;</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ComponentDataClass</span><span class="p">(</span><span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">if</span> <span class="n">_d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">UnknownSetDimen</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_dimen</span> <span class="o">=</span> <span class="n">_d</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_domain</span> <span class="o">=</span> <span class="n">domain</span>
            <span class="n">domain</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_validate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">_validate</span> <span class="o">=</span> <span class="n">Initializer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_validate</span><span class="p">(</span><span class="n">_block</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">_validate</span><span class="o">.</span><span class="n">constant</span><span class="p">():</span>
                    <span class="c1"># _init_validate was the actual validate function; use it.</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">_validate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_validate</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># We will assume any exceptions raised when getting the</span>
                <span class="c1"># validator for this index indicate that the function</span>
                <span class="c1"># should have been passed directly to the underlying sets.</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">_validate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_validate</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_filter</span> <span class="o">=</span> <span class="n">Initializer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_filter</span><span class="p">(</span><span class="n">_block</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">_filter</span><span class="o">.</span><span class="n">constant</span><span class="p">():</span>
                    <span class="c1"># _init_filter was the actual filter function; use it.</span>
                    <span class="n">_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_filter</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># We will assume any exceptions raised when getting the</span>
                <span class="c1"># filter for this index indicate that the function</span>
                <span class="c1"># should have been passed directly to the underlying sets.</span>
                <span class="n">_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_filter</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_filter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># _values was initialized above...</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">isordered</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">_values</span><span class="p">)</span> <span class="ow">in</span> <span class="n">Set</span><span class="o">.</span><span class="n">_UnorderedInitializers</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Initializing ordered Set </span><span class="si">%s</span><span class="s2"> with a fundamentally &quot;</span>
                    <span class="s2">&quot;unordered data source (type: </span><span class="si">%s</span><span class="s2">).  This WILL potentially &quot;</span>
                    <span class="s2">&quot;lead to nondeterministic behavior in Pyomo&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">_values</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="c1"># Special case: set operations that are not first attached</span>
            <span class="c1"># to the model must be constructed.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_values</span><span class="p">,</span> <span class="n">SetOperator</span><span class="p">):</span>
                <span class="n">_values</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">val_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">_values</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;Initializer for Set </span><span class="si">%s%s</span><span class="s2"> returned non-iterable object &quot;</span>
                    <span class="s2">&quot;of type </span><span class="si">%s</span><span class="s2">.&quot;</span>
                    <span class="o">%</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                        <span class="p">(</span><span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">index</span><span class="p">,)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
                        <span class="n">_values</span>
                        <span class="k">if</span> <span class="n">_values</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="nb">type</span>
                        <span class="k">else</span> <span class="nb">type</span><span class="p">(</span><span class="n">_values</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="k">raise</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">val_iter</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="n">Set</span><span class="o">.</span><span class="n">End</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">_filter</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">_filter</span><span class="p">(</span><span class="n">_block</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="c1"># We defer adding the filter until now so that add() doesn&#39;t</span>
        <span class="c1"># call it a second time.</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_filter</span> <span class="o">=</span> <span class="n">_filter</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_pprint_members</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">isfinite</span><span class="p">():</span>
            <span class="k">return</span> <span class="s1">&#39;{&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ordered_data</span><span class="p">())[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="s1">&#39; | &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">ranges</span><span class="p">())</span>
            <span class="k">if</span> <span class="s1">&#39; | &#39;</span> <span class="ow">in</span> <span class="n">ans</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="n">ans</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
            <span class="k">if</span> <span class="n">ans</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ans</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;[]&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_pprint_dimen</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">dimen</span>
        <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="n">UnknownSetDimen</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;--&quot;</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_pprint_domain</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">_domain</span> <span class="ow">is</span> <span class="n">x</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">SetOperator</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">_expression_str</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">_domain</span>

    <span class="k">def</span> <span class="nf">_pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return data that will be printed for this component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#</span>
        <span class="c1"># Eventually, we might want to support a &#39;verbose&#39; flag to</span>
        <span class="c1"># pprint() that will suppress some of the very long (less</span>
        <span class="c1"># informative) output</span>
        <span class="c1">#</span>
        <span class="c1"># if verbose:</span>
        <span class="c1">#     def members(x):</span>
        <span class="c1">#         return &#39;{&#39; + str(x.ordered_data())[1:-1] + &quot;}&quot;</span>
        <span class="c1"># else:</span>
        <span class="c1">#     MAX_MEMBERES=10</span>
        <span class="c1">#     def members(x):</span>
        <span class="c1">#         ans = x.ordered_data()</span>
        <span class="c1">#         if len(x) &gt; MAX_MEMBERES:</span>
        <span class="c1">#             return &#39;{&#39; + str(ans[:MAX_MEMBERES])[1:-1] + &#39;, ...}&#39;</span>
        <span class="c1">#         else:</span>
        <span class="c1">#             return &#39;{&#39; + str(ans)[1:-1] + &quot;}&quot;</span>

        <span class="c1"># TBD: In the current design, we force all _SetData within an</span>
        <span class="c1"># indexed Set to have the same isordered value, so we will only</span>
        <span class="c1"># print it once in the header.  Is this a good design?</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_ordered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isordered</span><span class="p">()</span>
            <span class="n">_refClass</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">_ordered</span> <span class="o">=</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ComponentDataClass</span><span class="p">,</span> <span class="n">_OrderedSetMixin</span><span class="p">)</span>
            <span class="n">_refClass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ComponentDataClass</span>
        <span class="k">if</span> <span class="n">_ordered</span><span class="p">:</span>
            <span class="c1"># This is a bit of an anachronism.  Historically Pyomo</span>
            <span class="c1"># reported &quot;Insertion&quot; for Set.InsertionOrder, &quot;Sorted&quot; for</span>
            <span class="c1"># Set.SortedOrder, and &quot;{user}&quot; for everything else.</span>
            <span class="c1"># However, we do not preserve that flag any more, so we</span>
            <span class="c1"># will infer it from the class hierarchy</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">_refClass</span><span class="p">,</span> <span class="n">_SortedSetMixin</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span><span class="o">.</span><span class="n">_sort_fcn</span> <span class="ow">is</span> <span class="n">sorted_robust</span><span class="p">:</span>
                    <span class="n">_ordered</span> <span class="o">=</span> <span class="s2">&quot;Sorted&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_ordered</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{user}</span><span class="s2">&quot;</span>
            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">_refClass</span><span class="p">,</span> <span class="n">_InsertionOrderSetData</span><span class="p">):</span>
                <span class="n">_ordered</span> <span class="o">=</span> <span class="s2">&quot;Insertion&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;Size&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)),</span>
                <span class="p">(</span><span class="s2">&quot;Index&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_set</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">()</span> <span class="k">else</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;Ordered&quot;</span><span class="p">,</span> <span class="n">_ordered</span><span class="p">),</span>
            <span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span>
            <span class="p">(</span><span class="s2">&quot;Dimen&quot;</span><span class="p">,</span> <span class="s2">&quot;Domain&quot;</span><span class="p">,</span> <span class="s2">&quot;Size&quot;</span><span class="p">,</span> <span class="s2">&quot;Members&quot;</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">Set</span><span class="o">.</span><span class="n">_pprint_dimen</span><span class="p">(</span><span class="n">v</span><span class="p">),</span>
                <span class="n">Set</span><span class="o">.</span><span class="n">_pprint_domain</span><span class="p">(</span><span class="n">v</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">isfinite</span><span class="p">()</span> <span class="k">else</span> <span class="s1">&#39;Inf&#39;</span><span class="p">,</span>
                <span class="n">Set</span><span class="o">.</span><span class="n">_pprint_members</span><span class="p">(</span><span class="n">v</span><span class="p">),</span>
            <span class="p">],</span>
        <span class="p">)</span></div>


<span class="k">class</span> <span class="nc">IndexedSet</span><span class="p">(</span><span class="n">Set</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Return a dict containing the data() of each Set in this IndexedSet&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">data</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>


<span class="k">class</span> <span class="nc">FiniteScalarSet</span><span class="p">(</span><span class="n">_FiniteSetData</span><span class="p">,</span> <span class="n">Set</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">_FiniteSetData</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">Set</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">UnindexedComponent_index</span>


<span class="k">class</span> <span class="nc">FiniteSimpleSet</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">RenamedClass</span><span class="p">):</span>
    <span class="n">__renamed__new_class__</span> <span class="o">=</span> <span class="n">FiniteScalarSet</span>
    <span class="n">__renamed__version__</span> <span class="o">=</span> <span class="s1">&#39;6.0&#39;</span>


<span class="k">class</span> <span class="nc">OrderedScalarSet</span><span class="p">(</span><span class="n">_ScalarOrderedSetMixin</span><span class="p">,</span> <span class="n">_InsertionOrderSetData</span><span class="p">,</span> <span class="n">Set</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="c1"># In case someone inherits from us, we will provide a rational</span>
        <span class="c1"># default for the &quot;ordered&quot; flag</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ordered&#39;</span><span class="p">,</span> <span class="n">Set</span><span class="o">.</span><span class="n">InsertionOrder</span><span class="p">)</span>

        <span class="n">_InsertionOrderSetData</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">Set</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">OrderedSimpleSet</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">RenamedClass</span><span class="p">):</span>
    <span class="n">__renamed__new_class__</span> <span class="o">=</span> <span class="n">OrderedScalarSet</span>
    <span class="n">__renamed__version__</span> <span class="o">=</span> <span class="s1">&#39;6.0&#39;</span>


<span class="k">class</span> <span class="nc">SortedScalarSet</span><span class="p">(</span><span class="n">_ScalarOrderedSetMixin</span><span class="p">,</span> <span class="n">_SortedSetData</span><span class="p">,</span> <span class="n">Set</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="c1"># In case someone inherits from us, we will provide a rational</span>
        <span class="c1"># default for the &quot;ordered&quot; flag</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ordered&#39;</span><span class="p">,</span> <span class="n">Set</span><span class="o">.</span><span class="n">SortedOrder</span><span class="p">)</span>

        <span class="n">_SortedSetData</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">Set</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">UnindexedComponent_index</span>


<span class="k">class</span> <span class="nc">SortedSimpleSet</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">RenamedClass</span><span class="p">):</span>
    <span class="n">__renamed__new_class__</span> <span class="o">=</span> <span class="n">SortedScalarSet</span>
    <span class="n">__renamed__version__</span> <span class="o">=</span> <span class="s1">&#39;6.0&#39;</span>


<span class="nd">@disable_methods</span><span class="p">(</span><span class="n">_FINITESET_API</span> <span class="o">+</span> <span class="n">_SETDATA_API</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">AbstractFiniteScalarSet</span><span class="p">(</span><span class="n">FiniteScalarSet</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">AbstractFiniteSimpleSet</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">RenamedClass</span><span class="p">):</span>
    <span class="n">__renamed__new_class__</span> <span class="o">=</span> <span class="n">AbstractFiniteScalarSet</span>
    <span class="n">__renamed__version__</span> <span class="o">=</span> <span class="s1">&#39;6.0&#39;</span>


<span class="nd">@disable_methods</span><span class="p">(</span><span class="n">_ORDEREDSET_API</span> <span class="o">+</span> <span class="n">_SETDATA_API</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">AbstractOrderedScalarSet</span><span class="p">(</span><span class="n">OrderedScalarSet</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">AbstractOrderedSimpleSet</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">RenamedClass</span><span class="p">):</span>
    <span class="n">__renamed__new_class__</span> <span class="o">=</span> <span class="n">AbstractOrderedScalarSet</span>
    <span class="n">__renamed__version__</span> <span class="o">=</span> <span class="s1">&#39;6.0&#39;</span>


<span class="nd">@disable_methods</span><span class="p">(</span><span class="n">_ORDEREDSET_API</span> <span class="o">+</span> <span class="n">_SETDATA_API</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">AbstractSortedScalarSet</span><span class="p">(</span><span class="n">SortedScalarSet</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">AbstractSortedSimpleSet</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">RenamedClass</span><span class="p">):</span>
    <span class="n">__renamed__new_class__</span> <span class="o">=</span> <span class="n">AbstractSortedScalarSet</span>
    <span class="n">__renamed__version__</span> <span class="o">=</span> <span class="s1">&#39;6.0&#39;</span>


<span class="c1">############################################################################</span>


<span class="k">class</span> <span class="nc">SetOf</span><span class="p">(</span><span class="n">_SetData</span><span class="p">,</span> <span class="n">Component</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">SetOf</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SetOf</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="p">(</span><span class="n">reference</span><span class="p">,)</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="p">(</span><span class="n">_SetData</span><span class="p">,</span> <span class="n">GlobalSetBase</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">reference</span><span class="o">.</span><span class="n">isfinite</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">reference</span><span class="o">.</span><span class="n">isordered</span><span class="p">():</span>
                    <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SetOf</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">OrderedSetOf</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SetOf</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">FiniteSetOf</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SetOf</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">InfiniteSetOf</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SetOf</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">OrderedSetOf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SetOf</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">FiniteSetOf</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">_SetData</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ctype&#39;</span><span class="p">,</span> <span class="n">SetOf</span><span class="p">)</span>
        <span class="n">Component</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ref</span> <span class="o">=</span> <span class="n">reference</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ref</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructed</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">timer</span> <span class="o">=</span> <span class="n">ConstructionTimer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_debug_set</span><span class="p">(</span><span class="n">logger</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Constructing SetOf, name=</span><span class="si">%s</span><span class="s2">, from data=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constructed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">timer</span><span class="o">.</span><span class="n">report</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ref</span><span class="p">,</span> <span class="n">_SetData</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref</span><span class="o">.</span><span class="n">dimen</span>
        <span class="n">_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">_iter</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_iter</span><span class="p">:</span>
            <span class="n">_this</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">_this</span> <span class="o">!=</span> <span class="n">ans</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">ans</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return data that will be printed for this component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">[(</span><span class="s2">&quot;Dimen&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimen</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;Size&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="p">(</span><span class="s2">&quot;Bounds&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">())],</span>
            <span class="p">{</span><span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="p">}</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span>
            <span class="p">(</span><span class="s2">&quot;Ordered&quot;</span><span class="p">,</span> <span class="s2">&quot;Members&quot;</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">isordered</span><span class="p">(),</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">_ref</span><span class="p">)],</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">InfiniteSetOf</span><span class="p">(</span><span class="n">SetOf</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">ranges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># InfiniteSetOf references are assumed to implement the Set API</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref</span><span class="o">.</span><span class="n">ranges</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">FiniteSetOf</span><span class="p">(</span><span class="n">_FiniteSetMixin</span><span class="p">,</span> <span class="n">SetOf</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Note that the efficiency of this depends on the reference object</span>
        <span class="c1">#</span>
        <span class="c1"># The bulk of single-value set members were stored as scalars.</span>
        <span class="c1"># Check that first.</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="nb">tuple</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">default</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ref</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_iter_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ref</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">UnorderedSetOf</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">RenamedClass</span><span class="p">):</span>
    <span class="n">__renamed__new_class__</span> <span class="o">=</span> <span class="n">FiniteSetOf</span>
    <span class="n">__renamed__version__</span> <span class="o">=</span> <span class="s1">&#39;6.2&#39;</span>


<span class="k">class</span> <span class="nc">OrderedSetOf</span><span class="p">(</span><span class="n">_ScalarOrderedSetMixin</span><span class="p">,</span> <span class="n">_OrderedSetMixin</span><span class="p">,</span> <span class="n">FiniteSetOf</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_0_based_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> index out of range&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">ord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="c1"># The bulk of single-value set members are stored as scalars.</span>
        <span class="c1"># However, we are now being more careful about matching tuples</span>
        <span class="c1"># when they are actually put as Set members.  So, we will look</span>
        <span class="c1"># for the exact thing that the user sent us and then fall back</span>
        <span class="c1"># on the scalar.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">tuple</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>


<span class="c1">############################################################################</span>


<span class="k">class</span> <span class="nc">_InfiniteRangeSetData</span><span class="p">(</span><span class="n">_SetData</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Data class for a infinite set.</span>

<span class="sd">    This Set implements an interface to an *infinite set* defined by one</span>
<span class="sd">    or more NumericRange objects.  As there are an infinite</span>
<span class="sd">    number of members, Infinite Range Sets are not iterable.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_ranges&#39;</span><span class="p">,)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
        <span class="n">_SetData</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="n">component</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ranges</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># The bulk of single-value set members were stored as scalars.</span>
        <span class="c1"># Check that first.</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="nb">tuple</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ranges</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">v</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">value</span> <span class="ow">in</span> <span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ranges</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">isdiscrete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if this set admits only discrete members&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">isdiscrete</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Reals</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ranges</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">ranges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ranges</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_FiniteRangeSetData</span><span class="p">(</span>
    <span class="n">_SortedSetMixin</span><span class="p">,</span> <span class="n">_OrderedSetMixin</span><span class="p">,</span> <span class="n">_FiniteSetMixin</span><span class="p">,</span> <span class="n">_InfiniteRangeSetData</span>
<span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_range_gen</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span><span class="p">)</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
        <span class="n">step</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">start</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">start</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">n</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">step</span>

    <span class="k">def</span> <span class="nf">_iter_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># If there is only a single underlying range, then we will</span>
        <span class="c1"># iterate over it</span>
        <span class="n">nIters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ranges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nIters</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">_FiniteRangeSetData</span><span class="o">.</span><span class="n">_range_gen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">return</span>

        <span class="c1"># The trick here is that we need to remove any duplicates from</span>
        <span class="c1"># the multiple ranges.  We will set up iterators for each range,</span>
        <span class="c1"># pull the first element from each iterator, sort and yield the</span>
        <span class="c1"># lowest value.</span>
        <span class="n">iters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ranges</span><span class="p">:</span>
            <span class="c1"># Note: there should always be at least 1 member in each</span>
            <span class="c1"># NumericRange</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">_FiniteRangeSetData</span><span class="o">.</span><span class="n">_range_gen</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">iters</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">next</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="p">])</span>

        <span class="n">iters</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">n</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="n">iters</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">iters</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">iters</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">yield</span> <span class="n">n</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">iters</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iters</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">nIters</span> <span class="ow">and</span> <span class="n">iters</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">iters</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">iters</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="n">iters</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">nIters</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ranges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># If there is only one range, then this set&#39;s range is equal</span>
            <span class="c1"># to the range&#39;s length</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span> <span class="o">==</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">//</span> <span class="n">r</span><span class="o">.</span><span class="n">step</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="n">index</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_0_based_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ranges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span><span class="o">.</span><span class="n">step</span>
            <span class="k">if</span> <span class="n">ans</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ans</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ans</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">ans</span>
                <span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> index out of range&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">ord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ranges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">item</span> <span class="o">-</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="n">r</span><span class="o">.</span><span class="n">step</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">item</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span>
                <span class="ow">and</span> <span class="n">item</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span>
                <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">.</span><span class="n">_EPS</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="n">item</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">ans</span>
                <span class="n">ans</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Cannot identify position of </span><span class="si">%s</span><span class="s2"> in Set </span><span class="si">%s</span><span class="s2">: item not in Set&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># We must redefine ranges(), bounds(), and domain so that we get the</span>
    <span class="c1"># _InfiniteRangeSetData version and not the one from</span>
    <span class="c1"># _FiniteSetMixin.</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="n">_InfiniteRangeSetData</span><span class="o">.</span><span class="n">bounds</span>
    <span class="n">ranges</span> <span class="o">=</span> <span class="n">_InfiniteRangeSetData</span><span class="o">.</span><span class="n">ranges</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">_InfiniteRangeSetData</span><span class="o">.</span><span class="n">domain</span>


<div class="viewcode-block" id="RangeSet"><a class="viewcode-back" href="../../../../library_reference/aml/index.html#pyomo.environ.RangeSet">[docs]</a><span class="nd">@ModelComponentFactory</span><span class="o">.</span><span class="n">register</span><span class="p">(</span>
    <span class="s2">&quot;A sequence of numeric values.  RangeSet(start,end,step) is a sequence &quot;</span>
    <span class="s2">&quot;starting a value &#39;start&#39;, and increasing in values by &#39;step&#39; until a &quot;</span>
    <span class="s2">&quot;value greater than or equal to &#39;end&#39; is reached.&quot;</span>
<span class="p">)</span>
<span class="k">class</span> <span class="nc">RangeSet</span><span class="p">(</span><span class="n">Component</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A set object that represents a set of numeric values</span>

<span class="sd">    `RangeSet` objects are based around `NumericRange` objects, which</span>
<span class="sd">    include support for non-finite ranges (both continuous and</span>
<span class="sd">    unbounded). Similarly, boutique ranges (like semi-continuous</span>
<span class="sd">    domains) can be represented, e.g.:</span>

<span class="sd">    .. doctest::</span>

<span class="sd">       &gt;&gt;&gt; from pyomo.core.base.range import NumericRange</span>
<span class="sd">       &gt;&gt;&gt; from pyomo.environ import RangeSet</span>
<span class="sd">       &gt;&gt;&gt; print(RangeSet(ranges=(NumericRange(0,0,0), NumericRange(1,100,0))))</span>
<span class="sd">       ([0] | [1..100])</span>

<span class="sd">    The `RangeSet` object continues to support the notation for</span>
<span class="sd">    specifying discrete ranges using &quot;[first=1], last, [step=1]&quot; values:</span>

<span class="sd">    .. doctest::</span>

<span class="sd">        &gt;&gt;&gt; r = RangeSet(3)</span>
<span class="sd">        &gt;&gt;&gt; print(r)</span>
<span class="sd">        [1:3]</span>
<span class="sd">        &gt;&gt;&gt; print(list(r))</span>
<span class="sd">        [1, 2, 3]</span>

<span class="sd">        &gt;&gt;&gt; r = RangeSet(2, 5)</span>
<span class="sd">        &gt;&gt;&gt; print(r)</span>
<span class="sd">        [2:5]</span>
<span class="sd">        &gt;&gt;&gt; print(list(r))</span>
<span class="sd">        [2, 3, 4, 5]</span>

<span class="sd">        &gt;&gt;&gt; r = RangeSet(2, 5, 2)</span>
<span class="sd">        &gt;&gt;&gt; print(r)</span>
<span class="sd">        [2:4:2]</span>
<span class="sd">        &gt;&gt;&gt; print(list(r))</span>
<span class="sd">        [2, 4]</span>

<span class="sd">        &gt;&gt;&gt; r = RangeSet(2.5, 4, 0.5)</span>
<span class="sd">        &gt;&gt;&gt; print(r)</span>
<span class="sd">        ([2.5] | [3.0] | [3.5] | [4.0])</span>
<span class="sd">        &gt;&gt;&gt; print(list(r))</span>
<span class="sd">        [2.5, 3.0, 3.5, 4.0]</span>

<span class="sd">    By implementing RangeSet using NumericRanges, the global Sets (like</span>
<span class="sd">    `Reals`, `Integers`, `PositiveReals`, etc.) are trivial</span>
<span class="sd">    instances of a RangeSet and support all Set operations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    *args: int | float | None</span>
<span class="sd">        The range defined by ([start=1], end, [step=1]).  If only a</span>
<span class="sd">        single positional parameter, `end` is supplied, then the</span>
<span class="sd">        RangeSet will be the integers starting at 1 up through and</span>
<span class="sd">        including end.  Providing two positional arguments, `x` and `y`,</span>
<span class="sd">        will result in a range starting at x up to and including y,</span>
<span class="sd">        incrementing by 1.  Providing a 3-tuple enables the</span>
<span class="sd">        specification of a step other than 1.</span>

<span class="sd">    finite: bool, optional</span>
<span class="sd">        This sets if this range is finite (discrete and bounded) or infinite</span>

<span class="sd">    ranges: iterable, optional</span>
<span class="sd">        The list of range objects that compose this RangeSet</span>

<span class="sd">    bounds: tuple, optional</span>
<span class="sd">        The lower and upper bounds of values that are admissible in this</span>
<span class="sd">        RangeSet</span>

<span class="sd">    filter: function, optional</span>
<span class="sd">        Function (rule) that returns True if the specified value is in</span>
<span class="sd">        the RangeSet or False if it is not.</span>

<span class="sd">    validate: function, optional</span>
<span class="sd">        Data validation function (rule).  The function will be called</span>
<span class="sd">        for every data member of the set, and if it returns False, a</span>
<span class="sd">        ValueError will be raised.</span>

<span class="sd">    name: str, optional</span>
<span class="sd">        Name for this component.</span>

<span class="sd">    doc: str, optional</span>
<span class="sd">        Text describing this component.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">RangeSet</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">RangeSet</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="n">finite</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;finite&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">finite</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;ranges&#39;</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">isfinite</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">[</span><span class="s1">&#39;ranges&#39;</span><span class="p">]):</span>
                    <span class="n">finite</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">native_types</span><span class="p">:</span>
                    <span class="c1"># Strange nosetest coverage issue: if the logic is</span>
                    <span class="c1"># negated and the continue is in the &quot;else&quot;, that</span>
                    <span class="c1"># line is not caught as being covered.</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">ComponentData</span><span class="p">)</span>
                        <span class="ow">or</span> <span class="ow">not</span> <span class="n">_</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span><span class="o">.</span><span class="n">is_constructed</span><span class="p">()</span>
                    <span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># &quot;Peek&quot; at constructed components to try and</span>
                        <span class="c1"># infer if this component will be Infinite</span>
                        <span class="n">_</span> <span class="o">=</span> <span class="n">value</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="n">_inf</span><span class="p">,</span> <span class="o">-</span><span class="n">_inf</span><span class="p">}:</span>
                        <span class="n">finite</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                <span class="k">elif</span> <span class="n">_</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">finite</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">finite</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Assume &quot;undetermined&quot; RangeSets will be finite.  If a</span>
                <span class="c1"># user wants them to be infinite, they can always</span>
                <span class="c1"># specify finite=False</span>
                <span class="n">finite</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">finite</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">RangeSet</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">AbstractFiniteScalarRangeSet</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">RangeSet</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">AbstractInfiniteScalarRangeSet</span><span class="p">)</span>

    <span class="c1"># `start`, `end`, `step` in `*args` are positional-only that cannot be filled with keywords.</span>
    <span class="c1"># But positional-only params syntax are not supported before python 3.8.</span>
    <span class="c1"># To emphasize they are positional-only, an underscore is added before their name.</span>
    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">_end</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">finite</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ranges</span><span class="o">=</span><span class="p">(),</span>
        <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">validate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">_start</span><span class="p">,</span>
        <span class="n">_end</span><span class="p">,</span>
        <span class="n">_step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">finite</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ranges</span><span class="o">=</span><span class="p">(),</span>
        <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">validate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">finite</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ranges</span><span class="o">=</span><span class="p">(),</span>
        <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">validate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="c1"># Finite was processed by __new__</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ctype&#39;</span><span class="p">,</span> <span class="n">RangeSet</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;RangeSet expects 3 or fewer positional &quot;</span>
                <span class="s2">&quot;arguments (received </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),)</span>
            <span class="p">)</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;finite&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ranges&#39;</span><span class="p">,</span> <span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_validate</span> <span class="o">=</span> <span class="n">Initializer</span><span class="p">(</span><span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;validate&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_filter</span> <span class="o">=</span> <span class="n">Initializer</span><span class="p">(</span><span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;filter&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_bounds</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;bounds&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_bounds</span> <span class="o">=</span> <span class="n">BoundsInitializer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_bounds</span><span class="p">)</span>

        <span class="n">Component</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="c1"># Shortcut: if all the relevant construction information is</span>
        <span class="c1"># simple (hard-coded) values, then it is safe to go ahead and</span>
        <span class="c1"># construct the set.</span>
        <span class="c1">#</span>
        <span class="c1"># NOTE: We will need to revisit this if we ever allow passing</span>
        <span class="c1"># data into the construct method (which would override the</span>
        <span class="c1"># hard-coded values here).</span>
        <span class="c1">#</span>
        <span class="c1"># NOTE: We will NOT automatically construct RangeSet objects</span>
        <span class="c1"># that reference mutable data so that we can generate a more</span>
        <span class="c1"># meaningful warning message about a RangeSet defined by mutable</span>
        <span class="c1"># data.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">native_types</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span><span class="o">.</span><span class="n">is_constructed</span><span class="p">()</span> <span class="ow">and</span> <span class="n">is_constant</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">args</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="c1"># Unconstructed floating components return their type</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructed</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="c1"># Named, constructed components should return their name e.g., Reals</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="c1"># Floating, unnamed constructed components return their ranges()</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="s1">&#39; | &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">())</span>
        <span class="k">if</span> <span class="s1">&#39; | &#39;</span> <span class="ow">in</span> <span class="n">ans</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="n">ans</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">if</span> <span class="n">ans</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ans</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;[]&quot;</span>

<div class="viewcode-block" id="RangeSet.construct"><a class="viewcode-back" href="../../../../library_reference/aml/index.html#pyomo.environ.RangeSet.construct">[docs]</a>    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructed</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">timer</span> <span class="o">=</span> <span class="n">ConstructionTimer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_debug_set</span><span class="p">(</span><span class="n">logger</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Constructing RangeSet, name=</span><span class="si">%s</span><span class="s2">, from data=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;RangeSet.construct() does not support the data= argument.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;Initialization data (range endpoints) can only be supplied &quot;</span>
                <span class="s2">&quot;as numbers, constants, or Params to the RangeSet() &quot;</span>
                <span class="s2">&quot;declaration&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constructed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">args</span><span class="p">,</span> <span class="n">ranges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_data</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">is_constant</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Constructing RangeSet &#39;</span><span class="si">%s</span><span class="s2">&#39; from non-constant data (e.g., &quot;</span>
                <span class="s2">&quot;Var or mutable Param).  The linkage between this RangeSet &quot;</span>
                <span class="s2">&quot;and the original source data will be broken, so updating &quot;</span>
                <span class="s2">&quot;the data value in the future will not be reflected in this &quot;</span>
                <span class="s2">&quot;RangeSet.  To suppress this warning, explicitly convert &quot;</span>
                <span class="s2">&quot;the source data to a constant type (e.g., float, int, or &quot;</span>
                <span class="s2">&quot;immutable Param)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
            <span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">value</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">ranges</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># This is a bit of a hack for backwards compatibility with</span>
            <span class="c1"># the old RangeSet implementation, where we did less</span>
            <span class="c1"># validation of the RangeSet arguments, and allowed the</span>
            <span class="c1"># creation of 0-length RangeSets</span>
            <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># No need to check for floating point - it will</span>
                <span class="c1"># automatically be truncated</span>
                <span class="n">ranges</span> <span class="o">=</span> <span class="n">ranges</span> <span class="o">+</span> <span class="p">(</span><span class="n">NumericRange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># This is a bit of a hack for backwards compatibility with</span>
            <span class="c1"># the old RangeSet implementation, where we did less</span>
            <span class="c1"># validation of the RangeSet arguments, and allowed the</span>
            <span class="c1"># creation of 0-length RangeSets</span>
            <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">args</span> <span class="ow">or</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># Discrete ranges anchored by a floating point value or</span>
            <span class="c1"># incremented by a floating point value cannot be handled by</span>
            <span class="c1"># the NumericRange object.  We will just discretize this</span>
            <span class="c1"># range (mostly for backwards compatibility)</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">args</span>
            <span class="k">if</span> <span class="n">step</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="p">,</span> <span class="n">start</span>
                    <span class="n">step</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

                <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Backwards compatibility: assume unbounded RangeSet</span>
                    <span class="c1"># is grounded at 0</span>
                    <span class="n">ranges</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">NumericRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="p">),</span>
                        <span class="n">NumericRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="n">step</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="nb">int</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="o">!=</span> <span class="n">step</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;RangeSet does not support unbounded ranges &quot;</span>
                            <span class="s2">&quot;with a non-integer step (got [</span><span class="si">%s</span><span class="s2">:</span><span class="si">%s</span><span class="s2">:</span><span class="si">%s</span><span class="s2">])&quot;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;RangeSet: start, end ordering incompatible with &quot;</span>
                            <span class="s2">&quot;step direction (got [</span><span class="si">%s</span><span class="s2">:</span><span class="si">%s</span><span class="s2">:</span><span class="si">%s</span><span class="s2">])&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">start</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">while</span> <span class="p">(</span><span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">):</span>
                        <span class="n">ranges</span> <span class="o">+=</span> <span class="p">(</span><span class="n">NumericRange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">),)</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">step</span> <span class="o">*</span> <span class="n">i</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ranges</span> <span class="o">+=</span> <span class="p">(</span><span class="n">NumericRange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">),)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ranges</span> <span class="o">+=</span> <span class="p">(</span><span class="n">NumericRange</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),)</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">NumericRange</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;RangeSet &#39;ranges&#39; argument must be an &quot;</span>
                    <span class="s2">&quot;iterable of NumericRange objects&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">isfinite</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfinite</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Constructing a finite RangeSet over a non-finite &quot;</span>
                    <span class="s2">&quot;range (</span><span class="si">%s</span><span class="s2">).  Either correct the range data or &quot;</span>
                    <span class="s2">&quot;specify &#39;finite=False&#39; when declaring the RangeSet&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">r</span><span class="p">,)</span>
                <span class="p">)</span>

        <span class="n">_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bnds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_bounds</span><span class="p">(</span><span class="n">_block</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
                <span class="n">tmp</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">range_intersection</span><span class="p">(</span><span class="n">bnds</span><span class="o">.</span><span class="n">ranges</span><span class="p">()))</span>
            <span class="n">ranges</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ranges</span> <span class="o">=</span> <span class="n">ranges</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfinite</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The &#39;filter&#39; keyword argument is not valid for &quot;</span>
                    <span class="s2">&quot;non-finite RangeSet component (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
                <span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">_filter</span> <span class="o">=</span> <span class="n">Initializer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_filter</span><span class="p">(</span><span class="n">_block</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">_filter</span><span class="o">.</span><span class="n">constant</span><span class="p">():</span>
                    <span class="c1"># _init_filter was the actual filter function; use it.</span>
                    <span class="n">_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_filter</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># We will assume any exceptions raised when getting the</span>
                <span class="c1"># filter for this index indicate that the function</span>
                <span class="c1"># should have been passed directly to the underlying sets.</span>
                <span class="n">_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_filter</span>

            <span class="c1"># If this is a finite set, then we can go ahead and filter</span>
            <span class="c1"># all the ranges.  This allows pprint and len to be correct,</span>
            <span class="c1"># without special handling</span>
            <span class="n">new_ranges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">old_ranges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">())</span>
            <span class="n">old_ranges</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="k">while</span> <span class="n">old_ranges</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">old_ranges</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_FiniteRangeSetData</span><span class="o">.</span><span class="n">_range_gen</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">_filter</span><span class="p">(</span><span class="n">_block</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
                        <span class="n">split_r</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">range_difference</span><span class="p">((</span><span class="n">NumericRange</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">),))</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_r</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="n">new_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">split_r</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                            <span class="n">old_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">split_r</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_r</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">old_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">split_r</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">new_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">split_r</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">new_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ranges</span> <span class="o">=</span> <span class="n">new_ranges</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_validate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfinite</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The &#39;validate&#39; keyword argument is not valid for &quot;</span>
                    <span class="s2">&quot;non-finite RangeSet component (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
                <span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">_validate</span> <span class="o">=</span> <span class="n">Initializer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_validate</span><span class="p">(</span><span class="n">_block</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">_validate</span><span class="o">.</span><span class="n">constant</span><span class="p">():</span>
                    <span class="c1"># _init_validate was the actual validate function; use it.</span>
                    <span class="n">_validate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_validate</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># We will assume any exceptions raised when getting the</span>
                <span class="c1"># validator for this index indicate that the function</span>
                <span class="c1"># should have been passed directly to the underlying set.</span>
                <span class="n">_validate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_validate</span>

            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="n">_validate</span><span class="p">(</span><span class="n">_block</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="s2">&quot;Exception raised while validating element &#39;</span><span class="si">%s</span><span class="s2">&#39; &quot;</span>
                        <span class="s2">&quot;for Set </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">raise</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;The value=</span><span class="si">%s</span><span class="s2"> violates the validation rule of &quot;</span>
                        <span class="s2">&quot;Set </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="p">)</span>

        <span class="n">timer</span><span class="o">.</span><span class="n">report</span><span class="p">()</span></div>

    <span class="c1">#</span>
    <span class="c1"># Until the time that we support indexed RangeSet objects, we will</span>
    <span class="c1"># mock up some of the IndexedComponent API for consistency with the</span>
    <span class="c1"># previous (&lt;=5.6.7) implementation.</span>
    <span class="c1">#</span>
    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">index_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">UnindexedComponent_set</span>

    <span class="k">def</span> <span class="nf">_pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return data that will be printed for this component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;Dimen&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimen</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;Size&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfinite</span><span class="p">()</span> <span class="k">else</span> <span class="s1">&#39;Inf&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;Bounds&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">()),</span>
            <span class="p">],</span>
            <span class="p">{</span><span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="p">}</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span>
            <span class="p">(</span><span class="s2">&quot;Finite&quot;</span><span class="p">,</span> <span class="s2">&quot;Members&quot;</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">v</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(),</span>  <span class="c1"># isinstance(v, _FiniteSetMixin),</span>
                <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">())</span> <span class="ow">or</span> <span class="s1">&#39;[]&#39;</span><span class="p">,</span>
            <span class="p">],</span>
        <span class="p">)</span></div>


<span class="k">class</span> <span class="nc">InfiniteScalarRangeSet</span><span class="p">(</span><span class="n">_InfiniteRangeSetData</span><span class="p">,</span> <span class="n">RangeSet</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">_InfiniteRangeSetData</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">RangeSet</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">UnindexedComponent_index</span>

    <span class="c1"># We want the RangeSet.__str__ to override the one in _FiniteSetMixin</span>
    <span class="fm">__str__</span> <span class="o">=</span> <span class="n">RangeSet</span><span class="o">.</span><span class="fm">__str__</span>


<span class="k">class</span> <span class="nc">InfiniteSimpleRangeSet</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">RenamedClass</span><span class="p">):</span>
    <span class="n">__renamed__new_class__</span> <span class="o">=</span> <span class="n">InfiniteScalarRangeSet</span>
    <span class="n">__renamed__version__</span> <span class="o">=</span> <span class="s1">&#39;6.0&#39;</span>


<span class="k">class</span> <span class="nc">FiniteScalarRangeSet</span><span class="p">(</span><span class="n">_ScalarOrderedSetMixin</span><span class="p">,</span> <span class="n">_FiniteRangeSetData</span><span class="p">,</span> <span class="n">RangeSet</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">_FiniteRangeSetData</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">RangeSet</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">UnindexedComponent_index</span>

    <span class="c1"># We want the RangeSet.__str__ to override the one in _FiniteSetMixin</span>
    <span class="fm">__str__</span> <span class="o">=</span> <span class="n">RangeSet</span><span class="o">.</span><span class="fm">__str__</span>


<span class="k">class</span> <span class="nc">FiniteSimpleRangeSet</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">RenamedClass</span><span class="p">):</span>
    <span class="n">__renamed__new_class__</span> <span class="o">=</span> <span class="n">FiniteScalarRangeSet</span>
    <span class="n">__renamed__version__</span> <span class="o">=</span> <span class="s1">&#39;6.0&#39;</span>


<span class="nd">@disable_methods</span><span class="p">(</span><span class="n">_SET_API</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">AbstractInfiniteScalarRangeSet</span><span class="p">(</span><span class="n">InfiniteScalarRangeSet</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">AbstractInfiniteSimpleRangeSet</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">RenamedClass</span><span class="p">):</span>
    <span class="n">__renamed__new_class__</span> <span class="o">=</span> <span class="n">AbstractInfiniteScalarRangeSet</span>
    <span class="n">__renamed__version__</span> <span class="o">=</span> <span class="s1">&#39;6.0&#39;</span>


<span class="nd">@disable_methods</span><span class="p">(</span><span class="n">_ORDEREDSET_API</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">AbstractFiniteScalarRangeSet</span><span class="p">(</span><span class="n">FiniteScalarRangeSet</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">AbstractFiniteSimpleRangeSet</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">RenamedClass</span><span class="p">):</span>
    <span class="n">__renamed__new_class__</span> <span class="o">=</span> <span class="n">AbstractFiniteScalarRangeSet</span>
    <span class="n">__renamed__version__</span> <span class="o">=</span> <span class="s1">&#39;6.0&#39;</span>


<span class="c1">############################################################################</span>
<span class="c1"># Set Operators</span>
<span class="c1">############################################################################</span>


<span class="k">class</span> <span class="nc">SetOperator</span><span class="p">(</span><span class="n">_SetData</span><span class="p">,</span> <span class="n">Set</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_sets&#39;</span><span class="p">,)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">_SetData</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">Set</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">implicit</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_set</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">_new_set</span> <span class="o">=</span> <span class="n">process_setarg</span><span class="p">(</span><span class="n">_set</span><span class="p">)</span>
            <span class="n">sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_new_set</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_new_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_set</span> <span class="ow">or</span> <span class="n">_new_set</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">implicit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_new_set</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_subsets</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">implicit</span><span class="p">)</span>
        <span class="c1"># We will implicitly construct all set operators if the operands</span>
        <span class="c1"># are all constructed.</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span><span class="o">.</span><span class="n">_constructed</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructed</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">timer</span> <span class="o">=</span> <span class="n">ConstructionTimer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_debug_set</span><span class="p">(</span><span class="n">logger</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Constructing SetOperator, name=</span><span class="si">%s</span><span class="s2">, from data=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SetOperator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">deprecation_warning</span><span class="p">(</span>
                <span class="s2">&quot;Providing construction data to SetOperator objects is &quot;</span>
                <span class="s2">&quot;deprecated.  This data is ignored and in a future version &quot;</span>
                <span class="s2">&quot;will not be allowed&quot;</span><span class="p">,</span>
                <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.7&#39;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">fail</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="kc">None</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">fail</span><span class="p">:</span>
                <span class="n">_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_data</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="n">fail</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_data</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                            <span class="n">fail</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
            <span class="k">if</span> <span class="n">fail</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Constructing SetOperator </span><span class="si">%s</span><span class="s2"> with incompatible data &quot;</span>
                    <span class="s2">&quot;(data=</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="n">timer</span><span class="o">.</span><span class="n">report</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the length of this Set</span>

<span class="sd">        Because Set objects (and therefore SetOperator objects) are a</span>
<span class="sd">        subclass of IndexedComponent, we need to override the definition</span>
<span class="sd">        of len() to return the length of the Set and not the Component.</span>
<span class="sd">        Failing to do so would result in scalar infinite set operators</span>
<span class="sd">        to return a length of &quot;1&quot;.</span>

<span class="sd">        Python requires len() to return a nonnegatie integer.  Instead</span>
<span class="sd">        of returning `float(&#39;inf&#39;)` here and allowing Python to raise</span>
<span class="sd">        the OverflowError, we will raise it directly here where we can</span>
<span class="sd">        provide a more informative error message.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">OverflowError</span><span class="p">(</span>
            <span class="s2">&quot;The length of a non-finite Set is Inf; however, Python &quot;</span>
            <span class="s2">&quot;requires len() to return a non-negative integer value. Check &quot;</span>
            <span class="s2">&quot;isfinite() before calling len() for possibly infinite Sets&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expression_str</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="c1"># SetOperators form an expression system.  As we allow operators</span>
        <span class="c1"># on abstract Set objects, it is important to *always* deepcopy</span>
        <span class="c1"># SetOperators that have not been assigned to a Block.  For</span>
        <span class="c1"># example, consider an abstract indexed model component whose</span>
        <span class="c1"># domain is specified by a Set expression:</span>
        <span class="c1">#</span>
        <span class="c1">#   def x_init(m,i):</span>
        <span class="c1">#       if i == 2:</span>
        <span class="c1">#           return Set.Skip</span>
        <span class="c1">#       else:</span>
        <span class="c1">#           return []</span>
        <span class="c1">#   m.x = Set( [1,2],</span>
        <span class="c1">#              domain={1: m.A*m.B, 2: m.A*m.A},</span>
        <span class="c1">#              initialize=x_init )</span>
        <span class="c1">#</span>
        <span class="c1"># We do not want to automatically add all the Set operators to</span>
        <span class="c1"># the model at declaration time, as m.x[2] is never actually</span>
        <span class="c1"># created.  Plus, doing so would require complex parsing of the</span>
        <span class="c1"># initializers.  BUT, we need to ensure that the operators are</span>
        <span class="c1"># deepcopied, otherwise when the model is cloned before</span>
        <span class="c1"># construction the operators will still refer to the sets on the</span>
        <span class="c1"># original abstract model (in particular, the Set x will have an</span>
        <span class="c1"># unknown dimen).</span>
        <span class="c1">#</span>
        <span class="c1"># Our solution is to cause SetOperators to be automatically</span>
        <span class="c1"># cloned if they haven&#39;t been assigned to a block.</span>
        <span class="k">if</span> <span class="s1">&#39;__block_scope__&#39;</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Hijack the block scope rules to cause this object to</span>
                <span class="c1"># be deepcopied.</span>
                <span class="n">memo</span><span class="p">[</span><span class="s1">&#39;__block_scope__&#39;</span><span class="p">][</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SetOperator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__deepcopy__</span><span class="p">(</span><span class="n">memo</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expression_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">:</span>
            <span class="n">arg_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39; &#39;</span> <span class="ow">in</span> <span class="n">arg_str</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">SetOperator</span><span class="p">):</span>
                <span class="n">arg_str</span> <span class="o">=</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="n">arg_str</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
            <span class="n">_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg_str</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operator</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isdiscrete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if this set admits only discrete members&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">isdiscrete</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">subsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expand_all_set_operators</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SetProduct</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">expand_all_set_operators</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Extracting subsets for Set %s, which is a SetOperator</span>
<span class="sd">                other than a SetProduct.  Returning this set and not</span>
<span class="sd">                descending into the set operands.  To descend into this</span>
<span class="sd">                operator, specify</span>
<span class="sd">                &#39;subsets(expand_all_set_operators=True)&#39; or to suppress</span>
<span class="sd">                this warning, specify</span>
<span class="sd">                &#39;subsets(expand_all_set_operators=False)&#39;&quot;&quot;&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
                <span class="p">)</span>
                <span class="k">yield</span> <span class="bp">self</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">expand_all_set_operators</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span>
                <span class="k">return</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">s</span><span class="o">.</span><span class="n">subsets</span><span class="p">(</span><span class="n">expand_all_set_operators</span><span class="o">=</span><span class="n">expand_all_set_operators</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;SetProduct.set_tuple is deprecated.  &quot;</span>
        <span class="s2">&quot;Use SetProduct.subsets() to get the operator arguments.&quot;</span><span class="p">,</span>
        <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.7&#39;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Despite its name, in the old SetProduct, set_tuple held a list</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subsets</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_domain</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># We hijack the _domain attribute of SetOperator so that pprint</span>
        <span class="c1"># prints out the expression as the Set&#39;s &quot;domain&quot;.  Doing this</span>
        <span class="c1"># as a property prevents the circular reference</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@_domain</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Any</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Setting the domain of a Set Operator is not allowed: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">val</span>
            <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_checkArgs</span><span class="p">(</span><span class="o">*</span><span class="n">sets</span><span class="p">):</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sets</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">_SetDataBase</span><span class="p">):</span>
                <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">s</span><span class="o">.</span><span class="n">isordered</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">isfinite</span><span class="p">()))</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">}:</span>
                <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ans</span>


<span class="c1">############################################################################</span>


<span class="k">class</span> <span class="nc">SetUnion</span><span class="p">(</span><span class="n">SetOperator</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="n">_operator</span> <span class="o">=</span> <span class="s2">&quot; | &quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="o">!=</span> <span class="n">SetUnion</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SetUnion</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="n">set0</span><span class="p">,</span> <span class="n">set1</span> <span class="o">=</span> <span class="n">SetOperator</span><span class="o">.</span><span class="n">_checkArgs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">set0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">set1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">SetUnion_OrderedSet</span>
        <span class="k">elif</span> <span class="n">set0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">set1</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">SetUnion_FiniteSet</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">SetUnion_InfiniteSet</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ranges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ranges</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dimen</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dimen</span>
        <span class="k">if</span> <span class="n">d0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">d1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">d0</span> <span class="ow">is</span> <span class="n">UnknownSetDimen</span> <span class="ow">or</span> <span class="n">d1</span> <span class="ow">is</span> <span class="n">UnknownSetDimen</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">UnknownSetDimen</span>
        <span class="k">if</span> <span class="n">d0</span> <span class="o">==</span> <span class="n">d1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">SetUnion_InfiniteSet</span><span class="p">(</span><span class="n">SetUnion</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># return any(val in s for s in self._sets)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">default</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">default</span>


<span class="k">class</span> <span class="nc">SetUnion_FiniteSet</span><span class="p">(</span><span class="n">_FiniteSetMixin</span><span class="p">,</span> <span class="n">SetUnion_InfiniteSet</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_iter_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">set0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">set0</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">set0</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of elements in the set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># There is no easy way to tell how many duplicates there are in</span>
        <span class="c1"># the second set.  Our only choice is to count them.  We will</span>
        <span class="c1"># try and be a little efficient by using len() for the first</span>
        <span class="c1"># set, though.</span>
        <span class="n">set0</span><span class="p">,</span> <span class="n">set1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">set0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">set1</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">set0</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SetUnion_OrderedSet</span><span class="p">(</span><span class="n">_ScalarOrderedSetMixin</span><span class="p">,</span> <span class="n">_OrderedSetMixin</span><span class="p">,</span> <span class="n">SetUnion_FiniteSet</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_0_based_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">set0_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">set0_len</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">-=</span> <span class="n">set0_len</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">set1_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">idx</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">set1_iter</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> index out of range&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,))</span>
            <span class="k">return</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">ord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the position index of the input value.</span>

<span class="sd">        Note that Pyomo Set objects have positions starting at 1 (not 0).</span>

<span class="sd">        If the search item is not in the Set, then an IndexError is raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ord</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot identify position of </span><span class="si">%s</span><span class="s2"> in Set </span><span class="si">%s</span><span class="s2">: item not in Set&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">_iter</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="n">item</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span>


<span class="c1">############################################################################</span>


<span class="k">class</span> <span class="nc">SetIntersection</span><span class="p">(</span><span class="n">SetOperator</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="n">_operator</span> <span class="o">=</span> <span class="s2">&quot; &amp; &quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="o">!=</span> <span class="n">SetIntersection</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SetIntersection</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="n">set0</span><span class="p">,</span> <span class="n">set1</span> <span class="o">=</span> <span class="n">SetOperator</span><span class="o">.</span><span class="n">_checkArgs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">set0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">set1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">SetIntersection_OrderedSet</span>
        <span class="k">elif</span> <span class="n">set0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">set1</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">SetIntersection_FiniteSet</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">SetIntersection_InfiniteSet</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SetIntersection</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">construct</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfinite</span><span class="p">():</span>
            <span class="n">_finite</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">isfinite</span><span class="p">():</span>
                    <span class="n">_finite</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">_finite</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">SetIntersection_OrderedSet</span>

    <span class="k">def</span> <span class="nf">ranges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ranges</span><span class="p">():</span>
            <span class="k">yield from</span> <span class="n">a</span><span class="o">.</span><span class="n">range_intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ranges</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dimen</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dimen</span>
        <span class="k">if</span> <span class="n">d1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d2</span>
        <span class="k">elif</span> <span class="n">d2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d1</span>
        <span class="k">elif</span> <span class="n">d1</span> <span class="o">==</span> <span class="n">d2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d1</span>
        <span class="k">elif</span> <span class="n">d1</span> <span class="ow">is</span> <span class="n">UnknownSetDimen</span> <span class="ow">or</span> <span class="n">d2</span> <span class="ow">is</span> <span class="n">UnknownSetDimen</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">UnknownSetDimen</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>


<span class="k">class</span> <span class="nc">SetIntersection_InfiniteSet</span><span class="p">(</span><span class="n">SetIntersection</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># return all(val in s for s in self._sets)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="n">default</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">default</span>
        <span class="k">return</span> <span class="n">v</span>


<span class="k">class</span> <span class="nc">SetIntersection_FiniteSet</span><span class="p">(</span><span class="n">_FiniteSetMixin</span><span class="p">,</span> <span class="n">SetIntersection_InfiniteSet</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_iter_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">set0</span><span class="p">,</span> <span class="n">set1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">set0</span><span class="o">.</span><span class="n">isordered</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">set1</span><span class="o">.</span><span class="n">isordered</span><span class="p">():</span>
                <span class="n">set0</span><span class="p">,</span> <span class="n">set1</span> <span class="o">=</span> <span class="n">set1</span><span class="p">,</span> <span class="n">set0</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">set0</span><span class="o">.</span><span class="n">isfinite</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">set1</span><span class="o">.</span><span class="n">isfinite</span><span class="p">():</span>
                    <span class="n">set0</span><span class="p">,</span> <span class="n">set1</span> <span class="o">=</span> <span class="n">set1</span><span class="p">,</span> <span class="n">set0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># The odd case of a finite continuous range</span>
                    <span class="c1"># intersected with an infinite discrete range...</span>
                    <span class="n">ranges</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">r0</span> <span class="ow">in</span> <span class="n">set0</span><span class="o">.</span><span class="n">ranges</span><span class="p">():</span>
                        <span class="n">ranges</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">r0</span><span class="o">.</span><span class="n">range_intersection</span><span class="p">(</span><span class="n">set1</span><span class="o">.</span><span class="n">ranges</span><span class="p">()))</span>
                    <span class="c1"># Note that the RangeSet is automatically</span>
                    <span class="c1"># constructed, as it has no non-native positional</span>
                    <span class="c1"># parameters.</span>
                    <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">RangeSet</span><span class="p">(</span><span class="n">ranges</span><span class="o">=</span><span class="n">ranges</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">set0</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">set1</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of elements in the set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SetIntersection_OrderedSet</span><span class="p">(</span>
    <span class="n">_ScalarOrderedSetMixin</span><span class="p">,</span> <span class="n">_OrderedSetMixin</span><span class="p">,</span> <span class="n">SetIntersection_FiniteSet</span>
<span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_0_based_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">idx</span><span class="p">:</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">_iter</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">_iter</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> index out of range&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">ord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the position index of the input value.</span>

<span class="sd">        Note that Pyomo Set objects have positions starting at 1 (not 0).</span>

<span class="sd">        If the search item is not in the Set, then an IndexError is raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot identify position of </span><span class="si">%s</span><span class="s2"> in Set </span><span class="si">%s</span><span class="s2">: item not in Set&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">next</span><span class="p">(</span><span class="n">_iter</span><span class="p">)</span> <span class="o">!=</span> <span class="n">item</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span>


<span class="c1">############################################################################</span>


<span class="k">class</span> <span class="nc">SetDifference</span><span class="p">(</span><span class="n">SetOperator</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="n">_operator</span> <span class="o">=</span> <span class="s2">&quot; - &quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="o">!=</span> <span class="n">SetDifference</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SetDifference</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="n">set0</span><span class="p">,</span> <span class="n">set1</span> <span class="o">=</span> <span class="n">SetOperator</span><span class="o">.</span><span class="n">_checkArgs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">set0</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">SetDifference_OrderedSet</span>
        <span class="k">elif</span> <span class="n">set0</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">SetDifference_FiniteSet</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">SetDifference_InfiniteSet</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ranges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ranges</span><span class="p">():</span>
            <span class="k">yield from</span> <span class="n">a</span><span class="o">.</span><span class="n">range_difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ranges</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dimen</span>


<span class="k">class</span> <span class="nc">SetDifference_InfiniteSet</span><span class="p">(</span><span class="n">SetDifference</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># return val in self._sets[0] and not val in self._sets[1]</span>
        <span class="n">v_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">v_l</span> <span class="ow">is</span> <span class="n">default</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>
        <span class="n">v_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">v_r</span> <span class="ow">is</span> <span class="n">default</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v_l</span>
        <span class="k">return</span> <span class="n">default</span>


<span class="k">class</span> <span class="nc">SetDifference_FiniteSet</span><span class="p">(</span><span class="n">_FiniteSetMixin</span><span class="p">,</span> <span class="n">SetDifference_InfiniteSet</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_iter_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">set0</span><span class="p">,</span> <span class="n">set1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">set0</span> <span class="k">if</span> <span class="n">_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">set1</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of elements in the set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SetDifference_OrderedSet</span><span class="p">(</span>
    <span class="n">_ScalarOrderedSetMixin</span><span class="p">,</span> <span class="n">_OrderedSetMixin</span><span class="p">,</span> <span class="n">SetDifference_FiniteSet</span>
<span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_0_based_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">idx</span><span class="p">:</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">_iter</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">_iter</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> index out of range&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">ord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the position index of the input value.</span>

<span class="sd">        Note that Pyomo Set objects have positions starting at 1 (not 0).</span>

<span class="sd">        If the search item is not in the Set, then an IndexError is raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot identify position of </span><span class="si">%s</span><span class="s2"> in Set </span><span class="si">%s</span><span class="s2">: item not in Set&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">next</span><span class="p">(</span><span class="n">_iter</span><span class="p">)</span> <span class="o">!=</span> <span class="n">item</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span>


<span class="c1">############################################################################</span>


<span class="k">class</span> <span class="nc">SetSymmetricDifference</span><span class="p">(</span><span class="n">SetOperator</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="n">_operator</span> <span class="o">=</span> <span class="s2">&quot; ^ &quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="o">!=</span> <span class="n">SetSymmetricDifference</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SetSymmetricDifference</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="n">set0</span><span class="p">,</span> <span class="n">set1</span> <span class="o">=</span> <span class="n">SetOperator</span><span class="o">.</span><span class="n">_checkArgs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">set0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">set1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">SetSymmetricDifference_OrderedSet</span>
        <span class="k">elif</span> <span class="n">set0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">set1</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">SetSymmetricDifference_FiniteSet</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">SetSymmetricDifference_InfiniteSet</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ranges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Note: the following loop implements for (a,b), (b,a)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="n">set_a</span><span class="p">,</span> <span class="n">set_b</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">a_r</span> <span class="ow">in</span> <span class="n">set_a</span><span class="o">.</span><span class="n">ranges</span><span class="p">():</span>
                <span class="k">yield from</span> <span class="n">a_r</span><span class="o">.</span><span class="n">range_difference</span><span class="p">(</span><span class="n">set_b</span><span class="o">.</span><span class="n">ranges</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dimen</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dimen</span>
        <span class="k">if</span> <span class="n">d0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">d1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">d0</span> <span class="ow">is</span> <span class="n">UnknownSetDimen</span> <span class="ow">or</span> <span class="n">d1</span> <span class="ow">is</span> <span class="n">UnknownSetDimen</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">UnknownSetDimen</span>
        <span class="k">if</span> <span class="n">d0</span> <span class="o">==</span> <span class="n">d1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">SetSymmetricDifference_InfiniteSet</span><span class="p">(</span><span class="n">SetSymmetricDifference</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># return (val in self._sets[0]) ^ (val in self._sets[1])</span>
        <span class="n">v_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
        <span class="n">v_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">v_l</span> <span class="ow">is</span> <span class="n">default</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v_r</span>
        <span class="k">if</span> <span class="n">v_r</span> <span class="ow">is</span> <span class="n">default</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v_l</span>
        <span class="k">return</span> <span class="n">default</span>


<span class="k">class</span> <span class="nc">SetSymmetricDifference_FiniteSet</span><span class="p">(</span>
    <span class="n">_FiniteSetMixin</span><span class="p">,</span> <span class="n">SetSymmetricDifference_InfiniteSet</span>
<span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_iter_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">set0</span><span class="p">,</span> <span class="n">set1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span>
        <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="p">(</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">set0</span> <span class="k">if</span> <span class="n">_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">set1</span><span class="p">),</span> <span class="p">(</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">set1</span> <span class="k">if</span> <span class="n">_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">set0</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of elements in the set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SetSymmetricDifference_OrderedSet</span><span class="p">(</span>
    <span class="n">_ScalarOrderedSetMixin</span><span class="p">,</span> <span class="n">_OrderedSetMixin</span><span class="p">,</span> <span class="n">SetSymmetricDifference_FiniteSet</span>
<span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_0_based_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">idx</span><span class="p">:</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">_iter</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">_iter</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> index out of range&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">ord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the position index of the input value.</span>

<span class="sd">        Note that Pyomo Set objects have positions starting at 1 (not 0).</span>

<span class="sd">        If the search item is not in the Set, then an IndexError is raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot identify position of </span><span class="si">%s</span><span class="s2"> in Set </span><span class="si">%s</span><span class="s2">: item not in Set&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">next</span><span class="p">(</span><span class="n">_iter</span><span class="p">)</span> <span class="o">!=</span> <span class="n">item</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span>


<span class="c1">############################################################################</span>


<span class="k">class</span> <span class="nc">SetProduct</span><span class="p">(</span><span class="n">SetOperator</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="n">_operator</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="o">!=</span> <span class="n">SetProduct</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SetProduct</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="n">_sets</span> <span class="o">=</span> <span class="n">SetOperator</span><span class="o">.</span><span class="n">_checkArgs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">_sets</span><span class="p">):</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">SetProduct_OrderedSet</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">_sets</span><span class="p">):</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">SetProduct_FiniteSet</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="n">SetProduct_InfiniteSet</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ranges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">RangeProduct</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ranges</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsets</span><span class="p">(</span><span class="kc">False</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">bounds</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsets</span><span class="p">(</span><span class="kc">False</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">FLATTEN_CROSS_PRODUCT</span> <span class="ow">and</span> <span class="n">normalize_index</span><span class="o">.</span><span class="n">flatten</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># By convention, &quot;None&quot; trumps UnknownSetDimen.  That is, a set</span>
        <span class="c1"># product is &quot;non-dimentioned&quot; if any term is non-dimentioned,</span>
        <span class="c1"># even if we do not yet know the dimentionality of another term.</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">_unknown</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">:</span>
            <span class="n">s_dim</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">dimen</span>
            <span class="k">if</span> <span class="n">s_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">s_dim</span> <span class="ow">is</span> <span class="n">UnknownSetDimen</span><span class="p">:</span>
                <span class="n">_unknown</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">+=</span> <span class="n">s_dim</span>
        <span class="k">return</span> <span class="n">UnknownSetDimen</span> <span class="k">if</span> <span class="n">_unknown</span> <span class="k">else</span> <span class="n">ans</span>

    <span class="k">def</span> <span class="nf">_flatten_product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flatten any nested set product terms (due to nested products)</span>

<span class="sd">        Note that because this is called in a recursive context, this</span>
<span class="sd">        method is assured that there is no more than a single level of</span>
<span class="sd">        nested tuples (so this only needs to check the top-level terms)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">val</span>


<span class="k">class</span> <span class="nc">SetProduct_InfiniteSet</span><span class="p">(</span><span class="n">SetProduct</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># return self._find_val(val) is not None</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_val</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>
        <span class="k">if</span> <span class="n">normalize_index</span><span class="o">.</span><span class="n">flatten</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatten_product</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_find_val</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Locate a value in this SetProduct</span>

<span class="sd">        Locate a value in this SetProduct.  Returns None if the value is</span>
<span class="sd">        not found, otherwise returns a (value, cutpoints) tuple.  Value</span>
<span class="sd">        is the value that was searched for, possibly normalized.</span>
<span class="sd">        Cutpoints is the set of indices that specify how to split the</span>
<span class="sd">        value into the corresponding subsets such that subset[i] =</span>
<span class="sd">        cutpoints[i:i+1].  Cutpoints is None if the value is trivially</span>
<span class="sd">        split with a single index for each subset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        val: tuple</span>
<span class="sd">        cutpoints: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Support for ambiguous cross products: if val matches the</span>
        <span class="c1"># number of subsets, we will start by checking each value</span>
        <span class="c1"># against the corresponding subset.  Failure is not sufficient</span>
        <span class="c1"># to determine the val is not in this set.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">val</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">val</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># If we are not normalizing indices, then if the above did not</span>
        <span class="c1"># match, we will NOT attempt to guess how to split the indices</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">normalize_index</span><span class="o">.</span><span class="n">flatten</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">val</span> <span class="o">=</span> <span class="n">normalize_index</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">v_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="p">,)</span>
            <span class="n">v_len</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Get the dimentionality of all the component sets</span>
        <span class="n">setDims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">dimen</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">)</span>

        <span class="c1"># For this search, if a subset has an unknown dimension, assume</span>
        <span class="c1"># it is &quot;None&quot;.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">setDims</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="n">UnknownSetDimen</span><span class="p">:</span>
                <span class="n">setDims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Find the starting index for each subset (based on dimentionality)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">setDims</span><span class="p">)</span>
        <span class="n">lastIndex</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">setDims</span><span class="p">):</span>
            <span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lastIndex</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">firstNonDimSet</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">break</span>
            <span class="n">lastIndex</span> <span class="o">+=</span> <span class="n">dim</span>
            <span class="c1"># We can also check for this subset member immediately.</span>
            <span class="c1"># Non-membership is sufficient to return &quot;not found&quot;</span>
            <span class="k">if</span> <span class="n">lastIndex</span> <span class="o">&gt;</span> <span class="n">v_len</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">val</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">:</span> <span class="n">lastIndex</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># The end of the last subset is always the length of the val</span>
        <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_len</span><span class="p">)</span>

        <span class="c1"># If there were no non-dimentioned sets, then we have checked</span>
        <span class="c1"># each subset, found a match, and can reach a verdict:</span>
        <span class="k">if</span> <span class="kc">None</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">setDims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lastIndex</span> <span class="o">==</span> <span class="n">v_len</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">val</span><span class="p">,</span> <span class="n">index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># If a subset is non-dimentioned, then we will have broken out</span>
        <span class="c1"># of the forward loop early.  Start at the end and work</span>
        <span class="c1"># backwards.</span>
        <span class="n">lastIndex</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">iEnd</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">setDims</span><span class="p">)):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">setDims</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">iEnd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lastNonDimSet</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">break</span>
            <span class="n">lastIndex</span> <span class="o">-=</span> <span class="n">dim</span>
            <span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lastIndex</span>
            <span class="c1"># We can also check for this subset member immediately.</span>
            <span class="c1"># Non-membership is sufficient to return &quot;not found&quot;</span>
            <span class="k">if</span> <span class="n">val</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">:</span> <span class="n">index</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">firstNonDimSet</span> <span class="o">==</span> <span class="n">lastNonDimSet</span><span class="p">:</span>
            <span class="c1"># We have inferred the subpart of val that must be in the</span>
            <span class="c1"># (single) non-dimentioned subset.  Check membership and</span>
            <span class="c1"># return the final verdict.</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">val</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">firstNonDimSet</span><span class="p">]</span> <span class="p">:</span> <span class="n">index</span><span class="p">[</span><span class="n">firstNonDimSet</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="n">firstNonDimSet</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="n">val</span><span class="p">,</span> <span class="n">index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># There were multiple subsets with dimen==None.  The only thing</span>
        <span class="c1"># we can do at this point is to search for any possible</span>
        <span class="c1"># combination that works</span>

        <span class="n">subsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">[</span><span class="n">firstNonDimSet</span> <span class="p">:</span> <span class="n">lastNonDimSet</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">_val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">firstNonDimSet</span><span class="p">]</span> <span class="p">:</span> <span class="n">index</span><span class="p">[</span><span class="n">lastNonDimSet</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">cuts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cutPointGenerator</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">_val</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">_val</span><span class="p">[</span><span class="n">cuts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">:</span> <span class="n">cuts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subsets</span><span class="p">)):</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">firstNonDimSet</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">subsets</span><span class="p">)):</span>
                    <span class="n">index</span><span class="p">[</span><span class="n">firstNonDimSet</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">cuts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">val</span><span class="p">,</span> <span class="n">index</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_cutPointGenerator</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">val_len</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate the sequence of cut points for a series of subsets.</span>

<span class="sd">        This generator produces the valid set of cut points for</span>
<span class="sd">        separating a list of length val_len into chunks that are valid</span>
<span class="sd">        for the specified subsets.  In this method, the first and last</span>
<span class="sd">        subsets must have dimen==None.  The return value is a list with</span>
<span class="sd">        length one greater that then number of subsets.  Value slices</span>
<span class="sd">        (for membership tests) are determined by</span>

<span class="sd">            cuts[i]:cuts[i+1] in subsets[i]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">setDims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">dimen</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">subsets</span><span class="p">)</span>
        <span class="n">cutIters</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subsets</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cutPoints</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subsets</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">cutIters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">val_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">cutPoints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val_len</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cutPoints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">cutIters</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">subsets</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">setDims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">cutIters</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">((</span><span class="n">cutPoints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">setDims</span><span class="p">[</span><span class="n">i</span><span class="p">],))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">cutIters</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">cutPoints</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">cutPoints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">val_len</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">cutPoints</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>


<span class="k">class</span> <span class="nc">SetProduct_FiniteSet</span><span class="p">(</span><span class="n">_FiniteSetMixin</span><span class="p">,</span> <span class="n">SetProduct_InfiniteSet</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_iter_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_iter</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">)</span>
        <span class="c1"># Note: if all the member sets are simple 1-d sets, then there</span>
        <span class="c1"># is no need to call flatten_product.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">FLATTEN_CROSS_PRODUCT</span>
            <span class="ow">and</span> <span class="n">normalize_index</span><span class="o">.</span><span class="n">flatten</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimen</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_flatten_product</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">_iter</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_iter</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of elements in the set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">*=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ans</span>


<span class="k">class</span> <span class="nc">SetProduct_OrderedSet</span><span class="p">(</span>
    <span class="n">_ScalarOrderedSetMixin</span><span class="p">,</span> <span class="n">_OrderedSetMixin</span><span class="p">,</span> <span class="n">SetProduct_FiniteSet</span>
<span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_0_based_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">_ord</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_ord</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">_ord</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_idx</span> <span class="o">=</span> <span class="n">_idx</span> <span class="o">%</span> <span class="n">_ord</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_idx</span> <span class="o">//</span> <span class="n">_ord</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">_idx</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> index out of range&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,))</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">,</span> <span class="n">_ord</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">FLATTEN_CROSS_PRODUCT</span> <span class="ow">and</span> <span class="n">normalize_index</span><span class="o">.</span><span class="n">flatten</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimen</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ans</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatten_product</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span>

    <span class="k">def</span> <span class="nf">ord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the position index of the input value.</span>

<span class="sd">        Note that Pyomo Set objects have positions starting at 1 (not 0).</span>

<span class="sd">        If the search item is not in the Set, then an IndexError is raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">found</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_val</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">found</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot identify position of </span><span class="si">%s</span><span class="s2"> in Set </span><span class="si">%s</span><span class="s2">: item not in Set&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">val</span><span class="p">,</span> <span class="n">cutPoints</span> <span class="o">=</span> <span class="n">found</span>
        <span class="k">if</span> <span class="n">cutPoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">val</span><span class="p">[</span><span class="n">cutPoints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">:</span> <span class="n">cutPoints</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="n">_idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ord</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">))</span>
        <span class="n">_len</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sets</span><span class="p">)</span>
        <span class="n">_len</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">_idx</span><span class="p">,</span> <span class="n">_len</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">pos</span>
            <span class="n">ans</span> <span class="o">*=</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">ans</span> <span class="o">+</span> <span class="mi">1</span>


<span class="c1">############################################################################</span>


<span class="k">class</span> <span class="nc">_AnySet</span><span class="p">(</span><span class="n">_SetData</span><span class="p">,</span> <span class="n">Set</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">_SetData</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># There is a chicken-and-egg game here: the SetInitializer uses</span>
        <span class="c1"># Any as part of the processing of the domain/within/bounds</span>
        <span class="c1"># domain restrictions.  However, Any has not been declared when</span>
        <span class="c1"># constructing Any, so we need to bypass that logic.  This</span>
        <span class="c1"># works, but requires us to declare a special domain setter to</span>
        <span class="c1"># accept (and ignore) this value.</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;domain&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">Set</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">val</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">Ellipsis</span> <span class="k">else</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">ranges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">AnyRange</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># We need to implement this to override the clear() from IndexedComponent</span>
    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="c1"># We need to implement this to override __len__ from IndexedComponent</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;object of type &#39;Any&#39; has no len()&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Any</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>


<span class="k">class</span> <span class="nc">_AnyWithNoneSet</span><span class="p">(</span><span class="n">_AnySet</span><span class="p">):</span>
    <span class="c1"># Note that we put the deprecation warning on contains() and not on</span>
    <span class="c1"># the class because we will always create a global instance for</span>
    <span class="c1"># backwards compatibility with the Book.</span>
    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;The AnyWithNone set is deprecated.  Use Any, which includes None&quot;</span><span class="p">,</span>
        <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.7&#39;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">_AnyWithNoneSet</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_EmptySet</span><span class="p">(</span><span class="n">_FiniteSetMixin</span><span class="p">,</span> <span class="n">_SetData</span><span class="p">,</span> <span class="n">Set</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">_SetData</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">Set</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">default</span>

    <span class="c1"># We need to implement this to override clear from IndexedComponent</span>
    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="c1"># We need to implement this to override __len__ from IndexedComponent</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_iter_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">tuple</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">EmptySet</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>


<span class="c1">############################################################################</span>


<span class="k">def</span> <span class="nf">DeclareGlobalSet</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">caller_globals</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Declare a copy of a set as a global set in the calling module</span>

<span class="sd">    This takes a Set object and declares a duplicate of it as a</span>
<span class="sd">    GlobalSet object in the global namespace of the caller&#39;s module</span>
<span class="sd">    using the local name of the passed set.  GlobalSet objects are</span>
<span class="sd">    pseudo-singletons, in that copy.deepcopy (and Model.clone()) will</span>
<span class="sd">    not duplcicate them, and when you pickle and restore objects</span>
<span class="sd">    containing GlobalSets will still refer to the same object.  The</span>
<span class="sd">    declared GlobalSet object will be an instance of the original Set</span>
<span class="sd">    type.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">parent_component</span><span class="p">()</span> <span class="ow">is</span> <span class="n">obj</span>
    <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">parent_block</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="c1"># Build the global set before registering its name so that we don&#39;t</span>
    <span class="c1"># run afoul of the logic in GlobalSet.__new__</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">local_name</span>
    <span class="k">if</span> <span class="n">_name</span> <span class="ow">in</span> <span class="n">GlobalSets</span> <span class="ow">and</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">GlobalSets</span><span class="p">[</span><span class="n">_name</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Duplicate Global Set declaration, </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">_name</span><span class="p">,))</span>

    <span class="c1"># Push this object into the caller&#39;s module namespace</span>
    <span class="c1"># Stack: 0: DeclareGlobalSet()</span>
    <span class="c1">#        1: the caller</span>
    <span class="k">if</span> <span class="n">caller_globals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">caller_globals</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_back</span><span class="o">.</span><span class="n">f_globals</span>
    <span class="k">if</span> <span class="n">_name</span> <span class="ow">in</span> <span class="n">caller_globals</span> <span class="ow">and</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">caller_globals</span><span class="p">[</span><span class="n">_name</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Refusing to overwrite global object, </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">_name</span><span class="p">,))</span>

    <span class="k">if</span> <span class="n">_name</span> <span class="ow">in</span> <span class="n">GlobalSets</span><span class="p">:</span>
        <span class="n">_set</span> <span class="o">=</span> <span class="n">caller_globals</span><span class="p">[</span><span class="n">_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">GlobalSets</span><span class="p">[</span><span class="n">_name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">_set</span>

    <span class="c1"># Handle duplicate registrations before defining the GlobalSet</span>
    <span class="c1"># object to avoid inconsistent MRO order.</span>

    <span class="k">class</span> <span class="nc">GlobalSet</span><span class="p">(</span><span class="n">GlobalSetBase</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
        <span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="si">%s</span><span class="s2"></span>

<span class="s2">        References to this object will not be duplicated by deepcopy</span>
<span class="s2">        and be maintained/restored by pickle.</span>

<span class="s2">        &quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">doc</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Note: a simple docstring does not appear to be picked up (at</span>
        <span class="c1"># least in Python 2.7), so we will explicitly set the __doc__</span>
        <span class="c1"># attribute.</span>

        <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_bounds&#39;</span><span class="p">,</span> <span class="s1">&#39;_interval&#39;</span><span class="p">)</span>

        <span class="n">global_name</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Hijack __new__ to mock up old RealSet el al. interface</span>

<span class="sd">            In the original Set implementation (Pyomo&lt;=5.6.7), the</span>
<span class="sd">            global sets were instances of their own virtual set classes</span>
<span class="sd">            (RealSet, IntegerSet, BooleanSet), and one could create new</span>
<span class="sd">            instances of those sets with modified bounds.  Since the</span>
<span class="sd">            GlobalSet mechanism also declares new classes for every</span>
<span class="sd">            GlobalSet, we can mock up the old behavior through how we</span>
<span class="sd">            handle __new__().</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">cls</span> <span class="ow">is</span> <span class="n">GlobalSet</span>
                <span class="ow">and</span> <span class="n">GlobalSet</span><span class="o">.</span><span class="n">global_name</span>
                <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">GlobalSet</span><span class="p">,</span> <span class="n">RangeSet</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">deprecation_warning</span><span class="p">(</span>
                    <span class="s2">&quot;The use of RealSet, IntegerSet, BinarySet and &quot;</span>
                    <span class="s2">&quot;BooleanSet as Pyomo Set class generators is &quot;</span>
                    <span class="s2">&quot;deprecated.  Please either use one of the pre-declared &quot;</span>
                    <span class="s2">&quot;global Sets (e.g., Reals, NonNegativeReals, Integers, &quot;</span>
                    <span class="s2">&quot;PositiveIntegers, Binary), or create a custom RangeSet.&quot;</span><span class="p">,</span>
                    <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.7.1&#39;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># Note: we will completely ignore any positional</span>
                <span class="c1"># arguments.  In this situation, these could be the</span>
                <span class="c1"># parent_block and any indices; e.g.,</span>
                <span class="c1">#    Var(m.I, within=RealSet)</span>
                <span class="n">base_set</span> <span class="o">=</span> <span class="n">GlobalSets</span><span class="p">[</span><span class="n">GlobalSet</span><span class="o">.</span><span class="n">global_name</span><span class="p">]</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;bounds&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">range_init</span> <span class="o">=</span> <span class="n">SetInitializer</span><span class="p">(</span><span class="n">base_set</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">range_init</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">BoundsInitializer</span><span class="p">(</span><span class="n">bounds</span><span class="p">))</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">name_kwd</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">cls_name</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;class_name&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cls_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="n">base_set</span><span class="o">.</span><span class="n">name</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="n">cls_name</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">RangeSet</span><span class="p">(</span><span class="n">ranges</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">range_init</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">ranges</span><span class="p">()),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">name_kwd</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">cls_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">ans</span><span class="o">.</span><span class="n">_name</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ans</span><span class="o">.</span><span class="n">bounds</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">GlobalSet</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kwds</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unexpected keyword arguments: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">kwds</span><span class="p">,))</span>
            <span class="k">return</span> <span class="n">ans</span>

        <span class="c1">#</span>
        <span class="c1"># Global sets are assumed to be constant sets.  For performance,</span>
        <span class="c1"># we will precompute and cache the Set bounds() and interval</span>
        <span class="c1">#</span>
        <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span>

        <span class="k">def</span> <span class="nf">get_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interval</span>

    <span class="n">_set</span> <span class="o">=</span> <span class="n">GlobalSet</span><span class="p">()</span>
    <span class="c1"># TODO: Can GlobalSets be a proper Block?</span>
    <span class="n">GlobalSets</span><span class="p">[</span><span class="n">_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">caller_globals</span><span class="p">[</span><span class="n">_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_set</span>
    <span class="n">GlobalSet</span><span class="o">.</span><span class="n">global_name</span> <span class="o">=</span> <span class="n">_name</span>

    <span class="n">_set</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">_set</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">())</span>
    <span class="n">_set</span><span class="o">.</span><span class="n">_component</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">_set</span><span class="p">)</span>
    <span class="n">_set</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>
    <span class="c1"># Cache the set bounds / interval</span>
    <span class="n">_set</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span>
    <span class="n">_set</span><span class="o">.</span><span class="n">_interval</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">get_interval</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">_set</span>


<span class="n">DeclareGlobalSet</span><span class="p">(</span>
    <span class="n">_AnySet</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Any&#39;</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A global Pyomo Set that admits any value&quot;</span><span class="p">),</span> <span class="nb">globals</span><span class="p">()</span>
<span class="p">)</span>
<span class="n">DeclareGlobalSet</span><span class="p">(</span>
    <span class="n">_AnyWithNoneSet</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;AnyWithNone&#39;</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A global Pyomo Set that admits any value&quot;</span><span class="p">),</span>
    <span class="nb">globals</span><span class="p">(),</span>
<span class="p">)</span>
<span class="n">DeclareGlobalSet</span><span class="p">(</span>
    <span class="n">_EmptySet</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;EmptySet&#39;</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;A global Pyomo Set that contains no members&quot;</span><span class="p">),</span>
    <span class="nb">globals</span><span class="p">(),</span>
<span class="p">)</span>

<span class="n">DeclareGlobalSet</span><span class="p">(</span>
    <span class="n">RangeSet</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Reals&#39;</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;A global Pyomo Set that admits any real (floating point) value&#39;</span><span class="p">,</span>
        <span class="n">ranges</span><span class="o">=</span><span class="p">(</span><span class="n">NumericRange</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">),),</span>
    <span class="p">),</span>
    <span class="nb">globals</span><span class="p">(),</span>
<span class="p">)</span>
<span class="n">DeclareGlobalSet</span><span class="p">(</span>
    <span class="n">RangeSet</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;NonNegativeReals&#39;</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;A global Pyomo Set admitting any real value in [0, +inf]&#39;</span><span class="p">,</span>
        <span class="n">ranges</span><span class="o">=</span><span class="p">(</span><span class="n">NumericRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">),),</span>
    <span class="p">),</span>
    <span class="nb">globals</span><span class="p">(),</span>
<span class="p">)</span>
<span class="n">DeclareGlobalSet</span><span class="p">(</span>
    <span class="n">RangeSet</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;NonPositiveReals&#39;</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;A global Pyomo Set admitting any real value in [-inf, 0]&#39;</span><span class="p">,</span>
        <span class="n">ranges</span><span class="o">=</span><span class="p">(</span><span class="n">NumericRange</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),),</span>
    <span class="p">),</span>
    <span class="nb">globals</span><span class="p">(),</span>
<span class="p">)</span>
<span class="n">DeclareGlobalSet</span><span class="p">(</span>
    <span class="n">RangeSet</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;NegativeReals&#39;</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;A global Pyomo Set admitting any real value in [-inf, 0)&#39;</span><span class="p">,</span>
        <span class="n">ranges</span><span class="o">=</span><span class="p">(</span><span class="n">NumericRange</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)),),</span>
    <span class="p">),</span>
    <span class="nb">globals</span><span class="p">(),</span>
<span class="p">)</span>
<span class="n">DeclareGlobalSet</span><span class="p">(</span>
    <span class="n">RangeSet</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;PositiveReals&#39;</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;A global Pyomo Set admitting any real value in (0, +inf]&#39;</span><span class="p">,</span>
        <span class="n">ranges</span><span class="o">=</span><span class="p">(</span><span class="n">NumericRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)),),</span>
    <span class="p">),</span>
    <span class="nb">globals</span><span class="p">(),</span>
<span class="p">)</span>

<span class="n">DeclareGlobalSet</span><span class="p">(</span>
    <span class="n">RangeSet</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Integers&#39;</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;A global Pyomo Set admitting any integer value&#39;</span><span class="p">,</span>
        <span class="n">ranges</span><span class="o">=</span><span class="p">(</span><span class="n">NumericRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">NumericRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span>
    <span class="p">),</span>
    <span class="nb">globals</span><span class="p">(),</span>
<span class="p">)</span>
<span class="n">DeclareGlobalSet</span><span class="p">(</span>
    <span class="n">RangeSet</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;NonNegativeIntegers&#39;</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;A global Pyomo Set admitting any integer value in [0, +inf]&#39;</span><span class="p">,</span>
        <span class="n">ranges</span><span class="o">=</span><span class="p">(</span><span class="n">NumericRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">),),</span>
    <span class="p">),</span>
    <span class="nb">globals</span><span class="p">(),</span>
<span class="p">)</span>
<span class="n">DeclareGlobalSet</span><span class="p">(</span>
    <span class="n">RangeSet</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;NonPositiveIntegers&#39;</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;A global Pyomo Set admitting any integer value in [-inf, 0]&#39;</span><span class="p">,</span>
        <span class="n">ranges</span><span class="o">=</span><span class="p">(</span><span class="n">NumericRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),),</span>
    <span class="p">),</span>
    <span class="nb">globals</span><span class="p">(),</span>
<span class="p">)</span>
<span class="n">DeclareGlobalSet</span><span class="p">(</span>
    <span class="n">RangeSet</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;NegativeIntegers&#39;</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;A global Pyomo Set admitting any integer value in [-inf, -1]&#39;</span><span class="p">,</span>
        <span class="n">ranges</span><span class="o">=</span><span class="p">(</span><span class="n">NumericRange</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),),</span>
    <span class="p">),</span>
    <span class="nb">globals</span><span class="p">(),</span>
<span class="p">)</span>
<span class="n">DeclareGlobalSet</span><span class="p">(</span>
    <span class="n">RangeSet</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;PositiveIntegers&#39;</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;A global Pyomo Set admitting any integer value in [1, +inf]&#39;</span><span class="p">,</span>
        <span class="n">ranges</span><span class="o">=</span><span class="p">(</span><span class="n">NumericRange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">),),</span>
    <span class="p">),</span>
    <span class="nb">globals</span><span class="p">(),</span>
<span class="p">)</span>

<span class="n">DeclareGlobalSet</span><span class="p">(</span>
    <span class="n">RangeSet</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Binary&#39;</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;A global Pyomo Set admitting the integers {0, 1}&#39;</span><span class="p">,</span>
        <span class="n">ranges</span><span class="o">=</span><span class="p">(</span><span class="n">NumericRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),),</span>
    <span class="p">),</span>
    <span class="nb">globals</span><span class="p">(),</span>
<span class="p">)</span>

<span class="c1"># TODO: Convert Boolean from an alias for Binary to a proper Boolean Set</span>
<span class="c1">#      admitting {True, False})</span>
<span class="n">DeclareGlobalSet</span><span class="p">(</span>
    <span class="n">RangeSet</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Boolean&#39;</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;A global Pyomo Set admitting the integers {0, 1}&#39;</span><span class="p">,</span>
        <span class="n">ranges</span><span class="o">=</span><span class="p">(</span><span class="n">NumericRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),),</span>
    <span class="p">),</span>
    <span class="nb">globals</span><span class="p">(),</span>
<span class="p">)</span>

<span class="n">DeclareGlobalSet</span><span class="p">(</span>
    <span class="n">RangeSet</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;PercentFraction&#39;</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;A global Pyomo Set admitting any real value in [0, 1]&#39;</span><span class="p">,</span>
        <span class="n">ranges</span><span class="o">=</span><span class="p">(</span><span class="n">NumericRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),),</span>
    <span class="p">),</span>
    <span class="nb">globals</span><span class="p">(),</span>
<span class="p">)</span>
<span class="n">DeclareGlobalSet</span><span class="p">(</span>
    <span class="n">RangeSet</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;UnitInterval&#39;</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;A global Pyomo Set admitting any real value in [0, 1]&#39;</span><span class="p">,</span>
        <span class="n">ranges</span><span class="o">=</span><span class="p">(</span><span class="n">NumericRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),),</span>
    <span class="p">),</span>
    <span class="nb">globals</span><span class="p">(),</span>
<span class="p">)</span>

<span class="c1"># DeclareGlobalSet(Set(</span>
<span class="c1">#     initialize=[None],</span>
<span class="c1">#     name=&#39;UnindexedComponent_set&#39;,</span>
<span class="c1">#     doc=&#39;A global Pyomo Set for unindexed (scalar) IndexedComponent objects&#39;,</span>
<span class="c1"># ), globals())</span>


<span class="n">real_global_set_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
    <span class="nb">id</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">(</span>
        <span class="n">Reals</span><span class="p">,</span>
        <span class="n">NonNegativeReals</span><span class="p">,</span>
        <span class="n">NonPositiveReals</span><span class="p">,</span>
        <span class="n">NegativeReals</span><span class="p">,</span>
        <span class="n">PositiveReals</span><span class="p">,</span>
        <span class="n">PercentFraction</span><span class="p">,</span>
        <span class="n">UnitInterval</span><span class="p">,</span>
    <span class="p">)</span>
<span class="p">)</span>
<span class="n">integer_global_set_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
    <span class="nb">id</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">(</span>
        <span class="n">Integers</span><span class="p">,</span>
        <span class="n">NonNegativeIntegers</span><span class="p">,</span>
        <span class="n">NonPositiveIntegers</span><span class="p">,</span>
        <span class="n">NegativeIntegers</span><span class="p">,</span>
        <span class="n">PositiveIntegers</span><span class="p">,</span>
        <span class="n">Binary</span><span class="p">,</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="n">RealSet</span> <span class="o">=</span> <span class="n">Reals</span><span class="o">.</span><span class="vm">__class__</span>
<span class="n">IntegerSet</span> <span class="o">=</span> <span class="n">Integers</span><span class="o">.</span><span class="vm">__class__</span>
<span class="n">BinarySet</span> <span class="o">=</span> <span class="n">Binary</span><span class="o">.</span><span class="vm">__class__</span>
<span class="n">BooleanSet</span> <span class="o">=</span> <span class="n">Boolean</span><span class="o">.</span><span class="vm">__class__</span>


<span class="c1">#</span>
<span class="c1"># Backwards compatibility: declare the RealInterval and IntegerInterval</span>
<span class="c1"># classes (leveraging the new global RangeSet objects)</span>
<span class="c1">#</span>


<span class="nd">@deprecated</span><span class="p">(</span>
    <span class="s2">&quot;RealInterval has been deprecated.  Please use RangeSet(lower, upper, 0)&quot;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.7&#39;</span><span class="p">,</span>
<span class="p">)</span>
<span class="k">class</span> <span class="nc">RealInterval</span><span class="p">(</span><span class="n">RealSet</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;class_name&#39;</span><span class="p">,</span> <span class="s1">&#39;RealInterval&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">RealInterval</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">RealSet</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>


<span class="nd">@deprecated</span><span class="p">(</span>
    <span class="s2">&quot;IntegerInterval has been deprecated.  Please use RangeSet(lower, upper, 1)&quot;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="s1">&#39;5.7&#39;</span><span class="p">,</span>
<span class="p">)</span>
<span class="k">class</span> <span class="nc">IntegerInterval</span><span class="p">(</span><span class="n">IntegerSet</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;class_name&#39;</span><span class="p">,</span> <span class="s1">&#39;IntegerInterval&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">IntegerInterval</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">IntegerSet</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2008-2023, Sandia National Laboratories.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>