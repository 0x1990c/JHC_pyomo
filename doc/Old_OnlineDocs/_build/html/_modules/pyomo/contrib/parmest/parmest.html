

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>pyomo.contrib.parmest.parmest &mdash; Pyomo 6.5.1.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/theme_overrides.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/clipboard.min.js"></script>
        <script src="../../../../_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> Pyomo
          

          
          </a>

          
            
            
              <div class="version">
                6.5.1.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../citing_pyomo.html">Citing Pyomo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pyomo_overview/index.html">Pyomo Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pyomo_modeling_components/index.html">Pyomo Modeling Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../solving_pyomo_models.html">Solving Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_models.html">Working with Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_abstractmodels/index.html">Working with Abstract Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_transformations/index.html">Model Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modeling_extensions/index.html">Modeling Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial_examples.html">Pyomo Tutorial Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_debugging/index.html">Debugging Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../advanced_topics/index.html">Advanced Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../errors.html">Common Warnings/Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_reference/index.html">Developer Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../library_reference/index.html">Library Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contribution_guide.html">Contributing to Pyomo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributed_packages/index.html">Third-Party Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../related_packages.html">Related Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Pyomo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>pyomo.contrib.parmest.parmest</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyomo.contrib.parmest.parmest</h1><div class="highlight"><pre>
<span></span><span class="c1">#  ___________________________________________________________________________</span>
<span class="c1">#</span>
<span class="c1">#  Pyomo: Python Optimization Modeling Objects</span>
<span class="c1">#  Copyright (c) 2008-2022</span>
<span class="c1">#  National Technology and Engineering Solutions of Sandia, LLC</span>
<span class="c1">#  Under the terms of Contract DE-NA0003525 with National Technology and</span>
<span class="c1">#  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain</span>
<span class="c1">#  rights in this software.</span>
<span class="c1">#  This software is distributed under the 3-clause BSD License.</span>
<span class="c1">#  ___________________________________________________________________________</span>
<span class="c1">#### Using mpi-sppy instead of PySP; May 2020</span>
<span class="c1">#### Adding option for &quot;local&quot; EF starting Sept 2020</span>
<span class="c1">#### Wrapping mpi-sppy functionality and local option Jan 2021, Feb 2021</span>

<span class="c1"># TODO: move use_mpisppy to a Pyomo configuration option</span>
<span class="c1">#</span>
<span class="c1"># False implies always use the EF that is local to parmest</span>
<span class="n">use_mpisppy</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Use it if we can but use local if not.</span>
<span class="k">if</span> <span class="n">use_mpisppy</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># MPI-SPPY has an unfortunate side effect of outputting</span>
        <span class="c1"># &quot;[ 0.00] Initializing mpi-sppy&quot; when it is imported.  This can</span>
        <span class="c1"># cause things like doctests to fail.  We will suppress that</span>
        <span class="c1"># information here.</span>
        <span class="kn">from</span> <span class="nn">pyomo.common.tee</span> <span class="kn">import</span> <span class="n">capture_output</span>

        <span class="k">with</span> <span class="n">capture_output</span><span class="p">():</span>
            <span class="kn">import</span> <span class="nn">mpisppy.utils.sputils</span> <span class="k">as</span> <span class="nn">sputils</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="n">use_mpisppy</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># we can&#39;t use it</span>
<span class="k">if</span> <span class="n">use_mpisppy</span><span class="p">:</span>
    <span class="c1"># These things should be outside the try block.</span>
    <span class="n">sputils</span><span class="o">.</span><span class="n">disable_tictoc_output</span><span class="p">()</span>
    <span class="kn">import</span> <span class="nn">mpisppy.opt.ef</span> <span class="k">as</span> <span class="nn">st</span>
    <span class="kn">import</span> <span class="nn">mpisppy.scenario_tree</span> <span class="k">as</span> <span class="nn">scenario_tree</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pyomo.contrib.parmest.utils.create_ef</span> <span class="k">as</span> <span class="nn">local_ef</span>
    <span class="kn">import</span> <span class="nn">pyomo.contrib.parmest.utils.scenario_tree</span> <span class="k">as</span> <span class="nn">scenario_tree</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">importlib</span> <span class="k">as</span> <span class="nn">im</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>

<span class="kn">from</span> <span class="nn">pyomo.common.dependencies</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">attempt_import</span><span class="p">,</span>
    <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span><span class="p">,</span>
    <span class="n">numpy_available</span><span class="p">,</span>
    <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span><span class="p">,</span>
    <span class="n">pandas_available</span><span class="p">,</span>
    <span class="n">scipy</span><span class="p">,</span>
    <span class="n">scipy_available</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">pyomo.environ</span> <span class="k">as</span> <span class="nn">pyo</span>

<span class="kn">from</span> <span class="nn">pyomo.opt</span> <span class="kn">import</span> <span class="n">SolverFactory</span>
<span class="kn">from</span> <span class="nn">pyomo.environ</span> <span class="kn">import</span> <span class="n">Block</span><span class="p">,</span> <span class="n">ComponentUID</span>

<span class="kn">import</span> <span class="nn">pyomo.contrib.parmest.utils</span> <span class="k">as</span> <span class="nn">utils</span>
<span class="kn">import</span> <span class="nn">pyomo.contrib.parmest.graphics</span> <span class="k">as</span> <span class="nn">graphics</span>
<span class="kn">from</span> <span class="nn">pyomo.dae</span> <span class="kn">import</span> <span class="n">ContinuousSet</span>

<span class="n">parmest_available</span> <span class="o">=</span> <span class="n">numpy_available</span> <span class="o">&amp;</span> <span class="n">pandas_available</span> <span class="o">&amp;</span> <span class="n">scipy_available</span>

<span class="n">inverse_reduced_hessian</span><span class="p">,</span> <span class="n">inverse_reduced_hessian_available</span> <span class="o">=</span> <span class="n">attempt_import</span><span class="p">(</span>
    <span class="s1">&#39;pyomo.contrib.interior_point.inverse_reduced_hessian&#39;</span>
<span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="ef_nonants"><a class="viewcode-back" href="../../../../contributed_packages/parmest/api.html#pyomo.contrib.parmest.parmest.ef_nonants">[docs]</a><span class="k">def</span> <span class="nf">ef_nonants</span><span class="p">(</span><span class="n">ef</span><span class="p">):</span>
    <span class="c1"># Wrapper to call someone&#39;s ef_nonants</span>
    <span class="c1"># (the function being called is very short, but it might be changed)</span>
    <span class="k">if</span> <span class="n">use_mpisppy</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sputils</span><span class="o">.</span><span class="n">ef_nonants</span><span class="p">(</span><span class="n">ef</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">local_ef</span><span class="o">.</span><span class="n">ef_nonants</span><span class="p">(</span><span class="n">ef</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_experiment_instance_creation_callback</span><span class="p">(</span>
    <span class="n">scenario_name</span><span class="p">,</span> <span class="n">node_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cb_data</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is going to be called by mpi-sppy or the local EF and it will call into</span>
<span class="sd">    the user&#39;s model&#39;s callback.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    scenario_name: `str` Scenario name should end with a number</span>
<span class="sd">    node_names: `None` ( Not used here )</span>
<span class="sd">    cb_data : dict with [&quot;callback&quot;], [&quot;BootList&quot;],</span>
<span class="sd">              [&quot;theta_names&quot;], [&quot;cb_data&quot;], etc.</span>
<span class="sd">              &quot;cb_data&quot; is passed through to user&#39;s callback function</span>
<span class="sd">                        that is the &quot;callback&quot; value.</span>
<span class="sd">              &quot;BootList&quot; is None or bootstrap experiment number list.</span>
<span class="sd">                       (called cb_data by mpisppy)</span>


<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    instance: `ConcreteModel`</span>
<span class="sd">        instantiated scenario</span>

<span class="sd">    Note:</span>
<span class="sd">    ----</span>
<span class="sd">    There is flexibility both in how the function is passed and its signature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">cb_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="n">outer_cb_data</span> <span class="o">=</span> <span class="n">cb_data</span>
    <span class="n">scen_num_str</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\d+)$&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">scenario_name</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">scen_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">scen_num_str</span><span class="p">)</span>
    <span class="n">basename</span> <span class="o">=</span> <span class="n">scenario_name</span><span class="p">[:</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">scen_num_str</span><span class="p">)]</span>  <span class="c1"># to reconstruct name</span>

    <span class="n">CallbackFunction</span> <span class="o">=</span> <span class="n">outer_cb_data</span><span class="p">[</span><span class="s2">&quot;callback&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">CallbackFunction</span><span class="p">):</span>
        <span class="n">callback</span> <span class="o">=</span> <span class="n">CallbackFunction</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cb_name</span> <span class="o">=</span> <span class="n">CallbackFunction</span>

        <span class="k">if</span> <span class="s2">&quot;CallbackModule&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">outer_cb_data</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Internal Error: need CallbackModule in parmest callback&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">modname</span> <span class="o">=</span> <span class="n">outer_cb_data</span><span class="p">[</span><span class="s2">&quot;CallbackModule&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">cb_module</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="n">package</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">):</span>
            <span class="n">cb_module</span> <span class="o">=</span> <span class="n">modname</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Internal Error: bad CallbackModule&quot;</span><span class="p">)</span>
            <span class="k">raise</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cb_module</span><span class="p">,</span> <span class="n">cb_name</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error getting function=&quot;</span> <span class="o">+</span> <span class="n">cb_name</span> <span class="o">+</span> <span class="s2">&quot; from module=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">modname</span><span class="p">))</span>
            <span class="k">raise</span>

    <span class="k">if</span> <span class="s2">&quot;BootList&quot;</span> <span class="ow">in</span> <span class="n">outer_cb_data</span><span class="p">:</span>
        <span class="n">bootlist</span> <span class="o">=</span> <span class="n">outer_cb_data</span><span class="p">[</span><span class="s2">&quot;BootList&quot;</span><span class="p">]</span>
        <span class="c1"># print(&quot;debug in callback: using bootlist=&quot;,str(bootlist))</span>
        <span class="c1"># assuming bootlist itself is zero based</span>
        <span class="n">exp_num</span> <span class="o">=</span> <span class="n">bootlist</span><span class="p">[</span><span class="n">scen_num</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">exp_num</span> <span class="o">=</span> <span class="n">scen_num</span>

    <span class="n">scen_name</span> <span class="o">=</span> <span class="n">basename</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">exp_num</span><span class="p">)</span>

    <span class="n">cb_data</span> <span class="o">=</span> <span class="n">outer_cb_data</span><span class="p">[</span><span class="s2">&quot;cb_data&quot;</span><span class="p">]</span>  <span class="c1"># cb_data might be None.</span>

    <span class="c1"># at least three signatures are supported. The first is preferred</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="n">callback</span><span class="p">(</span><span class="n">experiment_number</span><span class="o">=</span><span class="n">exp_num</span><span class="p">,</span> <span class="n">cb_data</span><span class="o">=</span><span class="n">cb_data</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s2">&quot;Only one callback signature is supported: &quot;</span>
            <span class="s2">&quot;callback(experiment_number, cb_data) &quot;</span>
        <span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        try:</span>
<span class="sd">            instance = callback(scenario_tree_model, scen_name, node_names)</span>
<span class="sd">        except TypeError:  # deprecated signature?</span>
<span class="sd">            try:</span>
<span class="sd">                instance = callback(scen_name, node_names)</span>
<span class="sd">            except:</span>
<span class="sd">                print(&quot;Failed to create instance using callback; TypeError+&quot;)</span>
<span class="sd">                raise</span>
<span class="sd">        except:</span>
<span class="sd">            print(&quot;Failed to create instance using callback.&quot;)</span>
<span class="sd">            raise</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s2">&quot;_mpisppy_node_list&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;scenario for experiment </span><span class="si">{</span><span class="n">exp_num</span><span class="si">}</span><span class="s2"> has _mpisppy_node_list&quot;</span><span class="p">)</span>
    <span class="n">nonant_list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">find_component</span><span class="p">(</span><span class="n">vstr</span><span class="p">)</span> <span class="k">for</span> <span class="n">vstr</span> <span class="ow">in</span> <span class="n">outer_cb_data</span><span class="p">[</span><span class="s2">&quot;theta_names&quot;</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="n">use_mpisppy</span><span class="p">:</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">_mpisppy_node_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">scenario_tree</span><span class="o">.</span><span class="n">ScenarioNode</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ROOT&quot;</span><span class="p">,</span>
                <span class="n">cond_prob</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                <span class="n">stage</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">cost_expression</span><span class="o">=</span><span class="n">instance</span><span class="o">.</span><span class="n">FirstStageCost</span><span class="p">,</span>
                <span class="n">nonant_list</span><span class="o">=</span><span class="n">nonant_list</span><span class="p">,</span>
                <span class="n">scen_model</span><span class="o">=</span><span class="n">instance</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">_mpisppy_node_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">scenario_tree</span><span class="o">.</span><span class="n">ScenarioNode</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ROOT&quot;</span><span class="p">,</span>
                <span class="n">cond_prob</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                <span class="n">stage</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">cost_expression</span><span class="o">=</span><span class="n">instance</span><span class="o">.</span><span class="n">FirstStageCost</span><span class="p">,</span>
                <span class="n">scen_name_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">nonant_list</span><span class="o">=</span><span class="n">nonant_list</span><span class="p">,</span>
                <span class="n">scen_model</span><span class="o">=</span><span class="n">instance</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">]</span>

    <span class="k">if</span> <span class="s2">&quot;ThetaVals&quot;</span> <span class="ow">in</span> <span class="n">outer_cb_data</span><span class="p">:</span>
        <span class="n">thetavals</span> <span class="o">=</span> <span class="n">outer_cb_data</span><span class="p">[</span><span class="s2">&quot;ThetaVals&quot;</span><span class="p">]</span>

        <span class="c1"># dlw august 2018: see mea code for more general theta</span>
        <span class="k">for</span> <span class="n">vstr</span> <span class="ow">in</span> <span class="n">thetavals</span><span class="p">:</span>
            <span class="n">theta_cuid</span> <span class="o">=</span> <span class="n">ComponentUID</span><span class="p">(</span><span class="n">vstr</span><span class="p">)</span>
            <span class="n">theta_object</span> <span class="o">=</span> <span class="n">theta_cuid</span><span class="o">.</span><span class="n">find_component_on</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">thetavals</span><span class="p">[</span><span class="n">vstr</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># print(&quot;Fixing&quot;,vstr,&quot;at&quot;,str(thetavals[vstr]))</span>
                <span class="n">theta_object</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="n">thetavals</span><span class="p">[</span><span class="n">vstr</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># print(&quot;Freeing&quot;,vstr)</span>
                <span class="n">theta_object</span><span class="o">.</span><span class="n">unfix</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">instance</span>


<span class="c1"># =============================================</span>
<span class="k">def</span> <span class="nf">_treemaker</span><span class="p">(</span><span class="n">scenlist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes a scenario tree (avoids dependence on daps)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    scenlist (list of `int`): experiment (i.e. scenario) numbers</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a `ConcreteModel` that is the scenario tree</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">num_scenarios</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">scenlist</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">scenario_tree</span><span class="o">.</span><span class="n">tree_structure_model</span><span class="o">.</span><span class="n">CreateAbstractScenarioTreeModel</span><span class="p">()</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">create_instance</span><span class="p">()</span>
    <span class="n">m</span><span class="o">.</span><span class="n">Stages</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;Stage1&#39;</span><span class="p">)</span>
    <span class="n">m</span><span class="o">.</span><span class="n">Stages</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;Stage2&#39;</span><span class="p">)</span>
    <span class="n">m</span><span class="o">.</span><span class="n">Nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;RootNode&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">scenlist</span><span class="p">:</span>
        <span class="n">m</span><span class="o">.</span><span class="n">Nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;LeafNode_Experiment&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">m</span><span class="o">.</span><span class="n">Scenarios</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;Experiment&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="n">m</span><span class="o">.</span><span class="n">NodeStage</span><span class="p">[</span><span class="s1">&#39;RootNode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Stage1&#39;</span>
    <span class="n">m</span><span class="o">.</span><span class="n">ConditionalProbability</span><span class="p">[</span><span class="s1">&#39;RootNode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">Nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="o">!=</span> <span class="s1">&#39;RootNode&#39;</span><span class="p">:</span>
            <span class="n">m</span><span class="o">.</span><span class="n">NodeStage</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Stage2&#39;</span>
            <span class="n">m</span><span class="o">.</span><span class="n">Children</span><span class="p">[</span><span class="s1">&#39;RootNode&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">m</span><span class="o">.</span><span class="n">Children</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">m</span><span class="o">.</span><span class="n">ConditionalProbability</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">num_scenarios</span>
            <span class="n">m</span><span class="o">.</span><span class="n">ScenarioLeafNode</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;LeafNode_&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">node</span>

    <span class="k">return</span> <span class="n">m</span>


<div class="viewcode-block" id="group_data"><a class="viewcode-back" href="../../../../contributed_packages/parmest/api.html#pyomo.contrib.parmest.parmest.group_data">[docs]</a><span class="k">def</span> <span class="nf">group_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">groupby_column_name</span><span class="p">,</span> <span class="n">use_mean</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Group data by scenario</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data: DataFrame</span>
<span class="sd">        Data</span>
<span class="sd">    groupby_column_name: strings</span>
<span class="sd">        Name of data column which contains scenario numbers</span>
<span class="sd">    use_mean: list of column names or None, optional</span>
<span class="sd">        Name of data columns which should be reduced to a single value per</span>
<span class="sd">        scenario by taking the mean</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    grouped_data: list of dictionaries</span>
<span class="sd">        Grouped data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">use_mean</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">use_mean_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">use_mean_list</span> <span class="o">=</span> <span class="n">use_mean</span>

    <span class="n">grouped_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">exp_num</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">groupby_column_name</span><span class="p">]):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">use_mean_list</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
        <span class="n">grouped_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">grouped_data</span></div>


<span class="k">class</span> <span class="nc">_SecondStageCostExpr</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to pass objective expression into the Pyomo model</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ssc_function</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ssc_function</span> <span class="o">=</span> <span class="n">ssc_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ssc_function</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>


<div class="viewcode-block" id="Estimator"><a class="viewcode-back" href="../../../../contributed_packages/parmest/api.html#pyomo.contrib.parmest.parmest.Estimator">[docs]</a><span class="k">class</span> <span class="nc">Estimator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameter estimation class</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model_function: function</span>
<span class="sd">        Function that generates an instance of the Pyomo model using &#39;data&#39;</span>
<span class="sd">        as the input argument</span>
<span class="sd">    data: pd.DataFrame, list of dictionaries, list of dataframes, or list of json file names</span>
<span class="sd">        Data that is used to build an instance of the Pyomo model and build</span>
<span class="sd">        the objective function</span>
<span class="sd">    theta_names: list of strings</span>
<span class="sd">        List of Var names to estimate</span>
<span class="sd">    obj_function: function, optional</span>
<span class="sd">        Function used to formulate parameter estimation objective, generally</span>
<span class="sd">        sum of squared error between measurements and model variables.</span>
<span class="sd">        If no function is specified, the model is used</span>
<span class="sd">        &quot;as is&quot; and should be defined with a &quot;FirstStageCost&quot; and</span>
<span class="sd">        &quot;SecondStageCost&quot; expression that are used to build an objective.</span>
<span class="sd">    tee: bool, optional</span>
<span class="sd">        Indicates that ef solver output should be teed</span>
<span class="sd">    diagnostic_mode: bool, optional</span>
<span class="sd">        If True, print diagnostics from the solver</span>
<span class="sd">    solver_options: dict, optional</span>
<span class="sd">        Provides options to the solver (also the name of an attribute)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model_function</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">theta_names</span><span class="p">,</span>
        <span class="n">obj_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tee</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">diagnostic_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">solver_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_function</span> <span class="o">=</span> <span class="n">model_function</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span>
        <span class="p">),</span> <span class="s2">&quot;Data must be a list or DataFrame&quot;</span>
        <span class="c1"># convert dataframe into a list of dataframes, each row = one scenario</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callback_data</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callback_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callback_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="p">),</span> <span class="s2">&quot;The scenarios in data must be a dictionary, DataFrame or filename&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">theta_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;parmest_dummy_var&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta_names</span> <span class="o">=</span> <span class="n">theta_names</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">obj_function</span> <span class="o">=</span> <span class="n">obj_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tee</span> <span class="o">=</span> <span class="n">tee</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diagnostic_mode</span> <span class="o">=</span> <span class="n">diagnostic_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_options</span> <span class="o">=</span> <span class="n">solver_options</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_second_stage_cost_exp</span> <span class="o">=</span> <span class="s2">&quot;SecondStageCost&quot;</span>
        <span class="c1"># boolean to indicate if model is initialized using a square solve</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_initialized</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_return_theta_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return list of fitted model parameter names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if fitted model parameter names differ from theta_names created when Estimator object is created</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;theta_names_updated&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta_names_updated</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">theta_names</span>
            <span class="p">)</span>  <span class="c1"># default theta_names, created when Estimator object is created</span>

    <span class="k">def</span> <span class="nf">_create_parmest_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modify the Pyomo model for parameter estimation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_function</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;parmest_dummy_var&#39;</span>
        <span class="p">):</span>
            <span class="n">model</span><span class="o">.</span><span class="n">parmest_dummy_var</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Var</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="c1"># Add objective function (optional)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_function</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">component_objects</span><span class="p">(</span><span class="n">pyo</span><span class="o">.</span><span class="n">Objective</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Total_Cost_Objective&quot;</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="s2">&quot;Parmest will not override the existing model Objective named &quot;</span>
                        <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">name</span>
                    <span class="p">)</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">deactivate</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">component_data_objects</span><span class="p">(</span><span class="n">pyo</span><span class="o">.</span><span class="n">Expression</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;FirstStageCost&quot;</span><span class="p">,</span> <span class="s2">&quot;SecondStageCost&quot;</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="s2">&quot;Parmest will not override the existing model Expression named &quot;</span>
                        <span class="o">+</span> <span class="n">expr</span><span class="o">.</span><span class="n">name</span>
                    <span class="p">)</span>
            <span class="n">model</span><span class="o">.</span><span class="n">FirstStageCost</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Expression</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">model</span><span class="o">.</span><span class="n">SecondStageCost</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Expression</span><span class="p">(</span>
                <span class="n">rule</span><span class="o">=</span><span class="n">_SecondStageCostExpr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_function</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="k">def</span> <span class="nf">TotalCost_rule</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">model</span><span class="o">.</span><span class="n">FirstStageCost</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">SecondStageCost</span>

            <span class="n">model</span><span class="o">.</span><span class="n">Total_Cost_Objective</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Objective</span><span class="p">(</span>
                <span class="n">rule</span><span class="o">=</span><span class="n">TotalCost_rule</span><span class="p">,</span> <span class="n">sense</span><span class="o">=</span><span class="n">pyo</span><span class="o">.</span><span class="n">minimize</span>
            <span class="p">)</span>

        <span class="c1"># Convert theta Params to Vars, and unfix theta Vars</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">convert_params_to_vars</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta_names</span><span class="p">)</span>

        <span class="c1"># Update theta names list to use CUID string representation</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">theta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta_names</span><span class="p">):</span>
            <span class="n">var_cuid</span> <span class="o">=</span> <span class="n">ComponentUID</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">var_validate</span> <span class="o">=</span> <span class="n">var_cuid</span><span class="o">.</span><span class="n">find_component_on</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">var_validate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;theta_name[</span><span class="si">%s</span><span class="s2">] (</span><span class="si">%s</span><span class="s2">) was not found on the model&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># If the component is not a variable,</span>
                    <span class="c1"># this will generate an exception (and the warning</span>
                    <span class="c1"># in the &#39;except&#39;)</span>
                    <span class="n">var_validate</span><span class="o">.</span><span class="n">unfix</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">theta_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">var_cuid</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">theta</span> <span class="o">+</span> <span class="s1">&#39; is not a variable&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parmest_model</span> <span class="o">=</span> <span class="n">model</span>

        <span class="k">return</span> <span class="n">model</span>

    <span class="k">def</span> <span class="nf">_instance_creation_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">experiment_number</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cb_data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># cb_data is a list of dictionaries, list of dataframes, OR list of json file names</span>
        <span class="n">exp_data</span> <span class="o">=</span> <span class="n">cb_data</span><span class="p">[</span><span class="n">experiment_number</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exp_data</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exp_data</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">exp_data</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">infile</span><span class="p">:</span>
                    <span class="n">exp_data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Could not read </span><span class="si">{</span><span class="n">exp_data</span><span class="si">}</span><span class="s1"> as json&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unexpected data format for cb_data=</span><span class="si">{</span><span class="n">cb_data</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_parmest_model</span><span class="p">(</span><span class="n">exp_data</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">model</span>

    <span class="k">def</span> <span class="nf">_Q_opt</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ThetaVals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">solver</span><span class="o">=</span><span class="s2">&quot;ef_ipopt&quot;</span><span class="p">,</span>
        <span class="n">return_values</span><span class="o">=</span><span class="p">[],</span>
        <span class="n">bootlist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">calc_cov</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">cov_n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set up all thetas as first stage Vars, return resulting theta</span>
<span class="sd">        values as well as the objective function value.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;k_aug&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;k_aug no longer supported.&quot;</span><span class="p">)</span>

        <span class="c1"># (Bootstrap scenarios will use indirection through the bootlist)</span>
        <span class="k">if</span> <span class="n">bootlist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scenario_numbers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_data</span><span class="p">)))</span>
            <span class="n">scen_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Scenario</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">scenario_numbers</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scen_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Scenario</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bootlist</span><span class="p">))]</span>

        <span class="c1"># tree_model.CallbackModule = None</span>
        <span class="n">outer_cb_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">outer_cb_data</span><span class="p">[</span><span class="s2">&quot;callback&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance_creation_callback</span>
        <span class="k">if</span> <span class="n">ThetaVals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outer_cb_data</span><span class="p">[</span><span class="s2">&quot;ThetaVals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ThetaVals</span>
        <span class="k">if</span> <span class="n">bootlist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outer_cb_data</span><span class="p">[</span><span class="s2">&quot;BootList&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bootlist</span>
        <span class="n">outer_cb_data</span><span class="p">[</span><span class="s2">&quot;cb_data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_data</span>  <span class="c1"># None is OK</span>
        <span class="n">outer_cb_data</span><span class="p">[</span><span class="s2">&quot;theta_names&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta_names</span>

        <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;solver&quot;</span><span class="p">:</span> <span class="s2">&quot;ipopt&quot;</span><span class="p">}</span>
        <span class="n">scenario_creator_options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;cb_data&quot;</span><span class="p">:</span> <span class="n">outer_cb_data</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">use_mpisppy</span><span class="p">:</span>
            <span class="n">ef</span> <span class="o">=</span> <span class="n">sputils</span><span class="o">.</span><span class="n">create_EF</span><span class="p">(</span>
                <span class="n">scen_names</span><span class="p">,</span>
                <span class="n">_experiment_instance_creation_callback</span><span class="p">,</span>
                <span class="n">EF_name</span><span class="o">=</span><span class="s2">&quot;_Q_opt&quot;</span><span class="p">,</span>
                <span class="n">suppress_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">scenario_creator_kwargs</span><span class="o">=</span><span class="n">scenario_creator_options</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ef</span> <span class="o">=</span> <span class="n">local_ef</span><span class="o">.</span><span class="n">create_EF</span><span class="p">(</span>
                <span class="n">scen_names</span><span class="p">,</span>
                <span class="n">_experiment_instance_creation_callback</span><span class="p">,</span>
                <span class="n">EF_name</span><span class="o">=</span><span class="s2">&quot;_Q_opt&quot;</span><span class="p">,</span>
                <span class="n">suppress_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">scenario_creator_kwargs</span><span class="o">=</span><span class="n">scenario_creator_options</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ef_instance</span> <span class="o">=</span> <span class="n">ef</span>

        <span class="c1"># Solve the extensive form with ipopt</span>
        <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;ef_ipopt&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">calc_cov</span><span class="p">:</span>
                <span class="c1"># Do not calculate the reduced hessian</span>

                <span class="n">solver</span> <span class="o">=</span> <span class="n">SolverFactory</span><span class="p">(</span><span class="s1">&#39;ipopt&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_options</span><span class="p">:</span>
                        <span class="n">solver</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_options</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

                <span class="n">solve_result</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ef_instance</span><span class="p">,</span> <span class="n">tee</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tee</span><span class="p">)</span>

            <span class="c1"># The import error will be raised when we attempt to use</span>
            <span class="c1"># inv_reduced_hessian_barrier below.</span>
            <span class="c1">#</span>
            <span class="c1"># elif not asl_available:</span>
            <span class="c1">#    raise ImportError(&quot;parmest requires ASL to calculate the &quot;</span>
            <span class="c1">#                      &quot;covariance matrix with solver &#39;ipopt&#39;&quot;)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># parmest makes the fitted parameters stage 1 variables</span>
                <span class="n">ind_vars</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">ndname</span><span class="p">,</span> <span class="n">Var</span><span class="p">,</span> <span class="n">solval</span> <span class="ow">in</span> <span class="n">ef_nonants</span><span class="p">(</span><span class="n">ef</span><span class="p">):</span>
                    <span class="n">ind_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Var</span><span class="p">)</span>
                <span class="c1"># calculate the reduced hessian</span>
                <span class="p">(</span>
                    <span class="n">solve_result</span><span class="p">,</span>
                    <span class="n">inv_red_hes</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">inverse_reduced_hessian</span><span class="o">.</span><span class="n">inv_reduced_hessian_barrier</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ef_instance</span><span class="p">,</span>
                    <span class="n">independent_variables</span><span class="o">=</span><span class="n">ind_vars</span><span class="p">,</span>
                    <span class="n">solver_options</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_options</span><span class="p">,</span>
                    <span class="n">tee</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tee</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">diagnostic_mode</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s1">&#39;    Solver termination condition = &#39;</span><span class="p">,</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">solve_result</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">termination_condition</span><span class="p">),</span>
                <span class="p">)</span>

            <span class="c1"># assume all first stage are thetas...</span>
            <span class="n">thetavals</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">ndname</span><span class="p">,</span> <span class="n">Var</span><span class="p">,</span> <span class="n">solval</span> <span class="ow">in</span> <span class="n">ef_nonants</span><span class="p">(</span><span class="n">ef</span><span class="p">):</span>
                <span class="c1"># process the name</span>
                <span class="c1"># the scenarios are blocks, so strip the scenario name</span>
                <span class="n">vname</span> <span class="o">=</span> <span class="n">Var</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">Var</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
                <span class="n">thetavals</span><span class="p">[</span><span class="n">vname</span><span class="p">]</span> <span class="o">=</span> <span class="n">solval</span>

            <span class="n">objval</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">ef</span><span class="o">.</span><span class="n">EF_Obj</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">calc_cov</span><span class="p">:</span>
                <span class="c1"># Calculate the covariance matrix</span>

                <span class="c1"># Number of data points considered</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">cov_n</span>

                <span class="c1"># Extract number of fitted parameters</span>
                <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">thetavals</span><span class="p">)</span>

                <span class="c1"># Assumption: Objective value is sum of squared errors</span>
                <span class="n">sse</span> <span class="o">=</span> <span class="n">objval</span>

                <span class="sd">&#39;&#39;&#39;Calculate covariance assuming experimental observation errors are</span>
<span class="sd">                independent and follow a Gaussian</span>
<span class="sd">                distribution with constant variance.</span>

<span class="sd">                The formula used in parmest was verified against equations (7-5-15) and</span>
<span class="sd">                (7-5-16) in &quot;Nonlinear Parameter Estimation&quot;, Y. Bard, 1974.</span>

<span class="sd">                This formula is also applicable if the objective is scaled by a constant;</span>
<span class="sd">                the constant cancels out. (was scaled by 1/n because it computes an</span>
<span class="sd">                expected value.)</span>
<span class="sd">                &#39;&#39;&#39;</span>
                <span class="n">cov</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sse</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_red_hes</span>
                <span class="n">cov</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="n">cov</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">thetavals</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">columns</span><span class="o">=</span><span class="n">thetavals</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="p">)</span>

            <span class="n">thetavals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">thetavals</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">var_values</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scen_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># multiple scenarios</span>
                    <span class="n">block_objects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ef_instance</span><span class="o">.</span><span class="n">component_objects</span><span class="p">(</span>
                        <span class="n">Block</span><span class="p">,</span> <span class="n">descend_into</span><span class="o">=</span><span class="kc">False</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># single scenario</span>
                    <span class="n">block_objects</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ef_instance</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">exp_i</span> <span class="ow">in</span> <span class="n">block_objects</span><span class="p">:</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">return_values</span><span class="p">:</span>
                        <span class="n">exp_i_var</span> <span class="o">=</span> <span class="n">exp_i</span><span class="o">.</span><span class="n">find_component</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="p">))</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">exp_i_var</span> <span class="ow">is</span> <span class="kc">None</span>
                        <span class="p">):</span>  <span class="c1"># we might have a block such as _mpisppy_data</span>
                            <span class="k">continue</span>
                        <span class="c1"># if value to return is ContinuousSet</span>
                        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">exp_i_var</span><span class="p">)</span> <span class="o">==</span> <span class="n">ContinuousSet</span><span class="p">:</span>
                            <span class="n">temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">exp_i_var</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">pyo</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">exp_i_var</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">vals</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">vals</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">var_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
                <span class="n">var_values</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">var_values</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">calc_cov</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">objval</span><span class="p">,</span> <span class="n">thetavals</span><span class="p">,</span> <span class="n">var_values</span><span class="p">,</span> <span class="n">cov</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">objval</span><span class="p">,</span> <span class="n">thetavals</span><span class="p">,</span> <span class="n">var_values</span>

            <span class="k">if</span> <span class="n">calc_cov</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">objval</span><span class="p">,</span> <span class="n">thetavals</span><span class="p">,</span> <span class="n">cov</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">objval</span><span class="p">,</span> <span class="n">thetavals</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unknown solver in Q_Opt=&quot;</span> <span class="o">+</span> <span class="n">solver</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_Q_at_theta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thetavals</span><span class="p">,</span> <span class="n">initialize_parmest_model</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the objective function value with fixed theta values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        thetavals: dict</span>
<span class="sd">            A dictionary of theta values.</span>

<span class="sd">        initialize_parmest_model: boolean</span>
<span class="sd">            If True: Solve square problem instance, build extensive form of the model for</span>
<span class="sd">            parameter estimation, and set flag model_initialized to True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        objectiveval: float</span>
<span class="sd">            The objective function value.</span>
<span class="sd">        thetavals: dict</span>
<span class="sd">            A dictionary of all values for theta that were input.</span>
<span class="sd">        solvertermination: Pyomo TerminationCondition</span>
<span class="sd">            Tries to return the &quot;worst&quot; solver status across the scenarios.</span>
<span class="sd">            pyo.TerminationCondition.optimal is the best and</span>
<span class="sd">            pyo.TerminationCondition.infeasible is the worst.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">SolverFactory</span><span class="p">(</span><span class="s1">&#39;ipopt&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">thetavals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dummy_cb</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;callback&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance_creation_callback</span><span class="p">,</span>
                <span class="s2">&quot;ThetaVals&quot;</span><span class="p">:</span> <span class="n">thetavals</span><span class="p">,</span>
                <span class="s2">&quot;theta_names&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_theta_names</span><span class="p">(),</span>
                <span class="s2">&quot;cb_data&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_data</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dummy_cb</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;callback&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance_creation_callback</span><span class="p">,</span>
                <span class="s2">&quot;theta_names&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_theta_names</span><span class="p">(),</span>
                <span class="s2">&quot;cb_data&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_data</span><span class="p">,</span>
            <span class="p">}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">diagnostic_mode</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">thetavals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    Compute objective at theta = &#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">thetavals</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    Compute objective at initial theta&#39;</span><span class="p">)</span>

        <span class="c1"># start block of code to deal with models with no constraints</span>
        <span class="c1"># (ipopt will crash or complain on such problems without special care)</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="n">_experiment_instance_creation_callback</span><span class="p">(</span><span class="s2">&quot;FOO0&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dummy_cb</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>  <span class="c1"># deal with special problems so Ipopt will not crash</span>
            <span class="n">first</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">component_objects</span><span class="p">(</span><span class="n">pyo</span><span class="o">.</span><span class="n">Constraint</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">active_constraints</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">active_constraints</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># end block of code to deal with models with no constraints</span>

        <span class="n">WorstStatus</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">TerminationCondition</span><span class="o">.</span><span class="n">optimal</span>
        <span class="n">totobj</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">scenario_numbers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_data</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">initialize_parmest_model</span><span class="p">:</span>
            <span class="c1"># create dictionary to store pyomo model instances (scenarios)</span>
            <span class="n">scen_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">snum</span> <span class="ow">in</span> <span class="n">scenario_numbers</span><span class="p">:</span>
            <span class="n">sname</span> <span class="o">=</span> <span class="s2">&quot;scenario_NODE&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">snum</span><span class="p">)</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="n">_experiment_instance_creation_callback</span><span class="p">(</span><span class="n">sname</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dummy_cb</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">initialize_parmest_model</span><span class="p">:</span>
                <span class="c1"># list to store fitted parameter names that will be unfixed</span>
                <span class="c1"># after initialization</span>
                <span class="n">theta_init_vals</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># use appropriate theta_names member</span>
                <span class="n">theta_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_theta_names</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">theta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">theta_ref</span><span class="p">):</span>
                    <span class="c1"># Use parser in ComponentUID to locate the component</span>
                    <span class="n">var_cuid</span> <span class="o">=</span> <span class="n">ComponentUID</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                    <span class="n">var_validate</span> <span class="o">=</span> <span class="n">var_cuid</span><span class="o">.</span><span class="n">find_component_on</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">var_validate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="s2">&quot;theta_name </span><span class="si">%s</span><span class="s2"> was not found on the model&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">thetavals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">var_validate</span><span class="o">.</span><span class="n">fix</span><span class="p">()</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">var_validate</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="n">thetavals</span><span class="p">[</span><span class="n">theta</span><span class="p">])</span>
                            <span class="n">theta_init_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_validate</span><span class="p">)</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                                <span class="s1">&#39;Unable to fix model parameter value for </span><span class="si">%s</span><span class="s1"> (not a Pyomo model Var)&#39;</span><span class="p">,</span>
                                <span class="p">(</span><span class="n">theta</span><span class="p">),</span>
                            <span class="p">)</span>

            <span class="k">if</span> <span class="n">active_constraints</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">diagnostic_mode</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;      Experiment = &#39;</span><span class="p">,</span> <span class="n">snum</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;     First solve with special diagnostics wrapper&#39;</span><span class="p">)</span>
                    <span class="p">(</span>
                        <span class="n">status_obj</span><span class="p">,</span>
                        <span class="n">solved</span><span class="p">,</span>
                        <span class="n">iters</span><span class="p">,</span>
                        <span class="n">time</span><span class="p">,</span>
                        <span class="n">regu</span><span class="p">,</span>
                    <span class="p">)</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">ipopt_solve_with_stats</span><span class="p">(</span>
                        <span class="n">instance</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">max_cpu_time</span><span class="o">=</span><span class="mi">120</span>
                    <span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;   status_obj, solved, iters, time, regularization_stat = &quot;</span><span class="p">,</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">status_obj</span><span class="p">),</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">solved</span><span class="p">),</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">iters</span><span class="p">),</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="p">),</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">regu</span><span class="p">),</span>
                    <span class="p">)</span>

                <span class="n">results</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">diagnostic_mode</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s1">&#39;standard solve solver termination condition=&#39;</span><span class="p">,</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">termination_condition</span><span class="p">),</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">termination_condition</span>
                    <span class="o">!=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">TerminationCondition</span><span class="o">.</span><span class="n">optimal</span>
                <span class="p">):</span>
                    <span class="c1"># DLW: Aug2018: not distinguishing &quot;middlish&quot; conditions</span>
                    <span class="k">if</span> <span class="n">WorstStatus</span> <span class="o">!=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">TerminationCondition</span><span class="o">.</span><span class="n">infeasible</span><span class="p">:</span>
                        <span class="n">WorstStatus</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">termination_condition</span>
                    <span class="k">if</span> <span class="n">initialize_parmest_model</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">diagnostic_mode</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="s2">&quot;Scenario </span><span class="si">{:d}</span><span class="s2"> infeasible with initialized parameter values&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">snum</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">initialize_parmest_model</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">diagnostic_mode</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="s2">&quot;Scenario </span><span class="si">{:d}</span><span class="s2"> initialization successful with initial parameter values&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">snum</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                <span class="k">if</span> <span class="n">initialize_parmest_model</span><span class="p">:</span>
                    <span class="c1"># unfix parameters after initialization</span>
                    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">theta_init_vals</span><span class="p">:</span>
                        <span class="n">theta</span><span class="o">.</span><span class="n">unfix</span><span class="p">()</span>
                    <span class="n">scen_dict</span><span class="p">[</span><span class="n">sname</span><span class="p">]</span> <span class="o">=</span> <span class="n">instance</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">initialize_parmest_model</span><span class="p">:</span>
                    <span class="c1"># unfix parameters after initialization</span>
                    <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">theta_init_vals</span><span class="p">:</span>
                        <span class="n">theta</span><span class="o">.</span><span class="n">unfix</span><span class="p">()</span>
                    <span class="n">scen_dict</span><span class="p">[</span><span class="n">sname</span><span class="p">]</span> <span class="o">=</span> <span class="n">instance</span>

            <span class="n">objobject</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_second_stage_cost_exp</span><span class="p">)</span>
            <span class="n">objval</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">objobject</span><span class="p">)</span>
            <span class="n">totobj</span> <span class="o">+=</span> <span class="n">objval</span>

        <span class="n">retval</span> <span class="o">=</span> <span class="n">totobj</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">scenario_numbers</span><span class="p">)</span>  <span class="c1"># -1??</span>
        <span class="k">if</span> <span class="n">initialize_parmest_model</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ef_instance&#39;</span><span class="p">):</span>
            <span class="c1"># create extensive form of the model using scenario dictionary</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scen_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">scen</span> <span class="ow">in</span> <span class="n">scen_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">scen</span><span class="o">.</span><span class="n">_mpisppy_probability</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">scen_dict</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">use_mpisppy</span><span class="p">:</span>
                <span class="n">EF_instance</span> <span class="o">=</span> <span class="n">sputils</span><span class="o">.</span><span class="n">_create_EF_from_scen_dict</span><span class="p">(</span>
                    <span class="n">scen_dict</span><span class="p">,</span>
                    <span class="n">EF_name</span><span class="o">=</span><span class="s2">&quot;_Q_at_theta&quot;</span><span class="p">,</span>
                    <span class="c1"># suppress_warnings=True</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">EF_instance</span> <span class="o">=</span> <span class="n">local_ef</span><span class="o">.</span><span class="n">_create_EF_from_scen_dict</span><span class="p">(</span>
                    <span class="n">scen_dict</span><span class="p">,</span> <span class="n">EF_name</span><span class="o">=</span><span class="s2">&quot;_Q_at_theta&quot;</span><span class="p">,</span> <span class="n">nonant_for_fixed_vars</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">ef_instance</span> <span class="o">=</span> <span class="n">EF_instance</span>
            <span class="c1"># set self.model_initialized flag to True to skip extensive form model</span>
            <span class="c1"># creation using theta_est()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_initialized</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># return initialized theta values</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">thetavals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># use appropriate theta_names member</span>
                <span class="n">theta_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_theta_names</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">theta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">theta_ref</span><span class="p">):</span>
                    <span class="n">thetavals</span><span class="p">[</span><span class="n">theta</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta_init_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]()</span>

        <span class="k">return</span> <span class="n">retval</span><span class="p">,</span> <span class="n">thetavals</span><span class="p">,</span> <span class="n">WorstStatus</span>

    <span class="k">def</span> <span class="nf">_get_sample_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samplesize</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">replacement</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">samplelist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="n">scenario_numbers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_data</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># This could get very large</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">scenario_numbers</span><span class="p">,</span> <span class="n">samplesize</span><span class="p">)):</span>
                <span class="n">samplelist</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">l</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">):</span>
                <span class="n">attempts</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">unique_samples</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># check for duplicates in each sample</span>
                <span class="n">duplicate</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># check for duplicates between samples</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">unique_samples</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_return_theta_names</span><span class="p">()))</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="ow">not</span> <span class="n">duplicate</span>
                <span class="p">):</span>
                    <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                        <span class="n">scenario_numbers</span><span class="p">,</span> <span class="n">samplesize</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replacement</span>
                    <span class="p">)</span>
                    <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="n">unique_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sample</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">samplelist</span><span class="p">:</span>
                        <span class="n">duplicate</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="n">attempts</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">attempts</span> <span class="o">&gt;</span> <span class="n">num_samples</span><span class="p">:</span>  <span class="c1"># arbitrary timeout limit</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                            <span class="sd">&quot;&quot;&quot;Internal error: timeout constructing</span>
<span class="sd">                                           a sample, the dim of theta may be too</span>
<span class="sd">                                           close to the samplesize&quot;&quot;&quot;</span>
                        <span class="p">)</span>

                <span class="n">samplelist</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">sample</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">samplelist</span>

<div class="viewcode-block" id="Estimator.theta_est"><a class="viewcode-back" href="../../../../contributed_packages/parmest/api.html#pyomo.contrib.parmest.parmest.Estimator.theta_est">[docs]</a>    <span class="k">def</span> <span class="nf">theta_est</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s2">&quot;ef_ipopt&quot;</span><span class="p">,</span> <span class="n">return_values</span><span class="o">=</span><span class="p">[],</span> <span class="n">calc_cov</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cov_n</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameter estimation using all scenarios in the data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        solver: string, optional</span>
<span class="sd">            Currently only &quot;ef_ipopt&quot; is supported. Default is &quot;ef_ipopt&quot;.</span>
<span class="sd">        return_values: list, optional</span>
<span class="sd">            List of Variable names, used to return values from the model for data reconciliation</span>
<span class="sd">        calc_cov: boolean, optional</span>
<span class="sd">            If True, calculate and return the covariance matrix (only for &quot;ef_ipopt&quot; solver)</span>
<span class="sd">        cov_n: int, optional</span>
<span class="sd">            If calc_cov=True, then the user needs to supply the number of datapoints</span>
<span class="sd">            that are used in the objective function</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        objectiveval: float</span>
<span class="sd">            The objective function value</span>
<span class="sd">        thetavals: pd.Series</span>
<span class="sd">            Estimated values for theta</span>
<span class="sd">        variable values: pd.DataFrame</span>
<span class="sd">            Variable values for each variable name in return_values (only for solver=&#39;ef_ipopt&#39;)</span>
<span class="sd">        cov: pd.DataFrame</span>
<span class="sd">            Covariance matrix of the fitted parameters (only for solver=&#39;ef_ipopt&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_values</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">calc_cov</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">calc_cov</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">cov_n</span><span class="p">,</span> <span class="nb">int</span>
            <span class="p">),</span> <span class="s2">&quot;The number of datapoints that are used in the objective function is required to calculate the covariance matrix&quot;</span>
            <span class="k">assert</span> <span class="n">cov_n</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_return_theta_names</span><span class="p">()</span>
            <span class="p">),</span> <span class="s2">&quot;The number of datapoints must be greater than the number of parameters to estimate&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q_opt</span><span class="p">(</span>
            <span class="n">solver</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span>
            <span class="n">return_values</span><span class="o">=</span><span class="n">return_values</span><span class="p">,</span>
            <span class="n">bootlist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">calc_cov</span><span class="o">=</span><span class="n">calc_cov</span><span class="p">,</span>
            <span class="n">cov_n</span><span class="o">=</span><span class="n">cov_n</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Estimator.theta_est_bootstrap"><a class="viewcode-back" href="../../../../contributed_packages/parmest/api.html#pyomo.contrib.parmest.parmest.Estimator.theta_est_bootstrap">[docs]</a>    <span class="k">def</span> <span class="nf">theta_est_bootstrap</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bootstrap_samples</span><span class="p">,</span>
        <span class="n">samplesize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">replacement</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">return_samples</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameter estimation using bootstrap resampling of the data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bootstrap_samples: int</span>
<span class="sd">            Number of bootstrap samples to draw from the data</span>
<span class="sd">        samplesize: int or None, optional</span>
<span class="sd">            Size of each bootstrap sample. If samplesize=None, samplesize will be</span>
<span class="sd">            set to the number of samples in the data</span>
<span class="sd">        replacement: bool, optional</span>
<span class="sd">            Sample with or without replacement</span>
<span class="sd">        seed: int or None, optional</span>
<span class="sd">            Random seed</span>
<span class="sd">        return_samples: bool, optional</span>
<span class="sd">            Return a list of sample numbers used in each bootstrap estimation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bootstrap_theta: pd.DataFrame</span>
<span class="sd">            Theta values for each sample and (if return_samples = True)</span>
<span class="sd">            the sample numbers used in each estimation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bootstrap_samples</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samplesize</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">int</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">replacement</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">int</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_samples</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">samplesize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samplesize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="n">global_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sample_list</span><span class="p">(</span><span class="n">samplesize</span><span class="p">,</span> <span class="n">bootstrap_samples</span><span class="p">,</span> <span class="n">replacement</span><span class="p">)</span>

        <span class="n">task_mgr</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">ParallelTaskManager</span><span class="p">(</span><span class="n">bootstrap_samples</span><span class="p">)</span>
        <span class="n">local_list</span> <span class="o">=</span> <span class="n">task_mgr</span><span class="o">.</span><span class="n">global_to_local_data</span><span class="p">(</span><span class="n">global_list</span><span class="p">)</span>

        <span class="n">bootstrap_theta</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">local_list</span><span class="p">:</span>
            <span class="n">objval</span><span class="p">,</span> <span class="n">thetavals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q_opt</span><span class="p">(</span><span class="n">bootlist</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">sample</span><span class="p">))</span>
            <span class="n">thetavals</span><span class="p">[</span><span class="s1">&#39;samples&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample</span>
            <span class="n">bootstrap_theta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thetavals</span><span class="p">)</span>

        <span class="n">global_bootstrap_theta</span> <span class="o">=</span> <span class="n">task_mgr</span><span class="o">.</span><span class="n">allgather_global_data</span><span class="p">(</span><span class="n">bootstrap_theta</span><span class="p">)</span>
        <span class="n">bootstrap_theta</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">global_bootstrap_theta</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_samples</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">bootstrap_theta</span><span class="p">[</span><span class="s1">&#39;samples&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">bootstrap_theta</span></div>

<div class="viewcode-block" id="Estimator.theta_est_leaveNout"><a class="viewcode-back" href="../../../../contributed_packages/parmest/api.html#pyomo.contrib.parmest.parmest.Estimator.theta_est_leaveNout">[docs]</a>    <span class="k">def</span> <span class="nf">theta_est_leaveNout</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">lNo</span><span class="p">,</span> <span class="n">lNo_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_samples</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameter estimation where N data points are left out of each sample</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lNo: int</span>
<span class="sd">            Number of data points to leave out for parameter estimation</span>
<span class="sd">        lNo_samples: int</span>
<span class="sd">            Number of leave-N-out samples. If lNo_samples=None, the maximum</span>
<span class="sd">            number of combinations will be used</span>
<span class="sd">        seed: int or None, optional</span>
<span class="sd">            Random seed</span>
<span class="sd">        return_samples: bool, optional</span>
<span class="sd">            Return a list of sample numbers that were left out</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lNo_theta: pd.DataFrame</span>
<span class="sd">            Theta values for each sample and (if return_samples = True)</span>
<span class="sd">            the sample numbers left out of each estimation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lNo</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lNo_samples</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">int</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">int</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_samples</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

        <span class="n">samplesize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_data</span><span class="p">)</span> <span class="o">-</span> <span class="n">lNo</span>

        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="n">global_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sample_list</span><span class="p">(</span><span class="n">samplesize</span><span class="p">,</span> <span class="n">lNo_samples</span><span class="p">,</span> <span class="n">replacement</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">task_mgr</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">ParallelTaskManager</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">global_list</span><span class="p">))</span>
        <span class="n">local_list</span> <span class="o">=</span> <span class="n">task_mgr</span><span class="o">.</span><span class="n">global_to_local_data</span><span class="p">(</span><span class="n">global_list</span><span class="p">)</span>

        <span class="n">lNo_theta</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">local_list</span><span class="p">:</span>
            <span class="n">objval</span><span class="p">,</span> <span class="n">thetavals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q_opt</span><span class="p">(</span><span class="n">bootlist</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">sample</span><span class="p">))</span>
            <span class="n">lNo_s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_data</span><span class="p">)))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">sample</span><span class="p">))</span>
            <span class="n">thetavals</span><span class="p">[</span><span class="s1">&#39;lNo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">lNo_s</span><span class="p">)</span>
            <span class="n">lNo_theta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thetavals</span><span class="p">)</span>

        <span class="n">global_bootstrap_theta</span> <span class="o">=</span> <span class="n">task_mgr</span><span class="o">.</span><span class="n">allgather_global_data</span><span class="p">(</span><span class="n">lNo_theta</span><span class="p">)</span>
        <span class="n">lNo_theta</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">global_bootstrap_theta</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_samples</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">lNo_theta</span><span class="p">[</span><span class="s1">&#39;lNo&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">lNo_theta</span></div>

<div class="viewcode-block" id="Estimator.leaveNout_bootstrap_test"><a class="viewcode-back" href="../../../../contributed_packages/parmest/api.html#pyomo.contrib.parmest.parmest.Estimator.leaveNout_bootstrap_test">[docs]</a>    <span class="k">def</span> <span class="nf">leaveNout_bootstrap_test</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">lNo</span><span class="p">,</span> <span class="n">lNo_samples</span><span class="p">,</span> <span class="n">bootstrap_samples</span><span class="p">,</span> <span class="n">distribution</span><span class="p">,</span> <span class="n">alphas</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Leave-N-out bootstrap test to compare theta values where N data points are</span>
<span class="sd">        left out to a bootstrap analysis using the remaining data,</span>
<span class="sd">        results indicate if theta is within a confidence region</span>
<span class="sd">        determined by the bootstrap analysis</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lNo: int</span>
<span class="sd">            Number of data points to leave out for parameter estimation</span>
<span class="sd">        lNo_samples: int</span>
<span class="sd">            Leave-N-out sample size. If lNo_samples=None, the maximum number</span>
<span class="sd">            of combinations will be used</span>
<span class="sd">        bootstrap_samples: int:</span>
<span class="sd">            Bootstrap sample size</span>
<span class="sd">        distribution: string</span>
<span class="sd">            Statistical distribution used to define a confidence region,</span>
<span class="sd">            options = &#39;MVN&#39; for multivariate_normal, &#39;KDE&#39; for gaussian_kde,</span>
<span class="sd">            and &#39;Rect&#39; for rectangular.</span>
<span class="sd">        alphas: list</span>
<span class="sd">            List of alpha values used to determine if theta values are inside</span>
<span class="sd">            or outside the region.</span>
<span class="sd">        seed: int or None, optional</span>
<span class="sd">            Random seed</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        List of tuples with one entry per lNo_sample:</span>

<span class="sd">        * The first item in each tuple is the list of N samples that are left</span>
<span class="sd">          out.</span>
<span class="sd">        * The second item in each tuple is a DataFrame of theta estimated using</span>
<span class="sd">          the N samples.</span>
<span class="sd">        * The third item in each tuple is a DataFrame containing results from</span>
<span class="sd">          the bootstrap analysis using the remaining samples.</span>

<span class="sd">        For each DataFrame a column is added for each value of alpha which</span>
<span class="sd">        indicates if the theta estimate is in (True) or out (False) of the</span>
<span class="sd">        alpha region for a given distribution (based on the bootstrap results)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lNo</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lNo_samples</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">int</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bootstrap_samples</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">distribution</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Rect&#39;</span><span class="p">,</span> <span class="s1">&#39;MVN&#39;</span><span class="p">,</span> <span class="s1">&#39;KDE&#39;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alphas</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">int</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">global_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sample_list</span><span class="p">(</span><span class="n">lNo</span><span class="p">,</span> <span class="n">lNo_samples</span><span class="p">,</span> <span class="n">replacement</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">global_list</span><span class="p">:</span>
            <span class="c1"># Reset callback_data to only include the sample</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callback_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sample</span><span class="p">]</span>

            <span class="n">obj</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta_est</span><span class="p">()</span>

            <span class="c1"># Reset callback_data to include all scenarios except the sample</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callback_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sample</span><span class="p">]</span>

            <span class="n">bootstrap_theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta_est_bootstrap</span><span class="p">(</span><span class="n">bootstrap_samples</span><span class="p">)</span>

            <span class="n">training</span><span class="p">,</span> <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">confidence_region_test</span><span class="p">(</span>
                <span class="n">bootstrap_theta</span><span class="p">,</span>
                <span class="n">distribution</span><span class="o">=</span><span class="n">distribution</span><span class="p">,</span>
                <span class="n">alphas</span><span class="o">=</span><span class="n">alphas</span><span class="p">,</span>
                <span class="n">test_theta_values</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sample</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">training</span><span class="p">))</span>

        <span class="c1"># Reset callback_data (back to full data set)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback_data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Estimator.objective_at_theta"><a class="viewcode-back" href="../../../../contributed_packages/parmest/api.html#pyomo.contrib.parmest.parmest.Estimator.objective_at_theta">[docs]</a>    <span class="k">def</span> <span class="nf">objective_at_theta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initialize_parmest_model</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Objective value for each theta</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta_values: pd.DataFrame, columns=theta_names</span>
<span class="sd">            Values of theta used to compute the objective</span>

<span class="sd">        initialize_parmest_model: boolean</span>
<span class="sd">            If True: Solve square problem instance, build extensive form of the model for</span>
<span class="sd">            parameter estimation, and set flag model_initialized to True</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj_at_theta: pd.DataFrame</span>
<span class="sd">            Objective value for each theta (infeasible solutions are</span>
<span class="sd">            omitted).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;parmest_dummy_var&#39;</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># skip assertion if model has no fitted parameters</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># create a local instance of the pyomo model to access model variables and parameters</span>
            <span class="n">model_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_parmest_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">model_theta_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list to store indexed and non-indexed parameters</span>
            <span class="c1"># iterate over original theta_names</span>
            <span class="k">for</span> <span class="n">theta_i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta_names</span><span class="p">:</span>
                <span class="n">var_cuid</span> <span class="o">=</span> <span class="n">ComponentUID</span><span class="p">(</span><span class="n">theta_i</span><span class="p">)</span>
                <span class="n">var_validate</span> <span class="o">=</span> <span class="n">var_cuid</span><span class="o">.</span><span class="n">find_component_on</span><span class="p">(</span><span class="n">model_temp</span><span class="p">)</span>
                <span class="c1"># check if theta in theta_names are indexed</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># get component UID of Set over which theta is defined</span>
                    <span class="n">set_cuid</span> <span class="o">=</span> <span class="n">ComponentUID</span><span class="p">(</span><span class="n">var_validate</span><span class="o">.</span><span class="n">index_set</span><span class="p">())</span>
                    <span class="c1"># access and iterate over the Set to generate theta names as they appear</span>
                    <span class="c1"># in the pyomo model</span>
                    <span class="n">set_validate</span> <span class="o">=</span> <span class="n">set_cuid</span><span class="o">.</span><span class="n">find_component_on</span><span class="p">(</span><span class="n">model_temp</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">set_validate</span><span class="p">:</span>
                        <span class="n">self_theta_temp</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">var_cuid</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
                        <span class="c1"># generate list of theta names</span>
                        <span class="n">model_theta_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">self_theta_temp</span><span class="p">)</span>
                <span class="c1"># if theta is not indexed, copy theta name to list as-is</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">self_theta_temp</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">var_cuid</span><span class="p">)</span>
                    <span class="n">model_theta_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">self_theta_temp</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span>
            <span class="c1"># if self.theta_names is not the same as temp model_theta_list,</span>
            <span class="c1"># create self.theta_names_updated</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">model_theta_list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">theta_names</span>
            <span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">model_theta_list</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">theta_names_updated</span> <span class="o">=</span> <span class="n">model_theta_list</span>

        <span class="k">if</span> <span class="n">theta_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">all_thetas</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># dictionary to store fitted variables</span>
            <span class="c1"># use appropriate theta names member</span>
            <span class="n">theta_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_theta_names</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">theta_values</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span>
            <span class="c1"># for parallel code we need to use lists and dicts in the loop</span>
            <span class="n">theta_names</span> <span class="o">=</span> <span class="n">theta_values</span><span class="o">.</span><span class="n">columns</span>
            <span class="c1"># # check if theta_names are in model</span>
            <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">theta_names</span><span class="p">):</span>
                <span class="n">theta_temp</span> <span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>  <span class="c1"># cleaning quotes from theta_names</span>

                <span class="k">assert</span> <span class="n">theta_temp</span> <span class="ow">in</span> <span class="p">[</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">model_theta_list</span>
                <span class="p">],</span> <span class="s2">&quot;Theta name </span><span class="si">{}</span><span class="s2"> in &#39;theta_values&#39; not in &#39;theta_names&#39; </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">theta_temp</span><span class="p">,</span> <span class="n">model_theta_list</span>
                <span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">theta_names</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_theta_list</span><span class="p">)</span>

            <span class="n">all_thetas</span> <span class="o">=</span> <span class="n">theta_values</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="s1">&#39;records&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">all_thetas</span><span class="p">:</span>
            <span class="n">task_mgr</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">ParallelTaskManager</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_thetas</span><span class="p">))</span>
            <span class="n">local_thetas</span> <span class="o">=</span> <span class="n">task_mgr</span><span class="o">.</span><span class="n">global_to_local_data</span><span class="p">(</span><span class="n">all_thetas</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">initialize_parmest_model</span><span class="p">:</span>
                <span class="n">task_mgr</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">ParallelTaskManager</span><span class="p">(</span>
                    <span class="mi">1</span>
                <span class="p">)</span>  <span class="c1"># initialization performed using just 1 set of theta values</span>
        <span class="c1"># walk over the mesh, return objective function</span>
        <span class="n">all_obj</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_thetas</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">Theta</span> <span class="ow">in</span> <span class="n">local_thetas</span><span class="p">:</span>
                <span class="n">obj</span><span class="p">,</span> <span class="n">thetvals</span><span class="p">,</span> <span class="n">worststatus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q_at_theta</span><span class="p">(</span>
                    <span class="n">Theta</span><span class="p">,</span> <span class="n">initialize_parmest_model</span><span class="o">=</span><span class="n">initialize_parmest_model</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">worststatus</span> <span class="o">!=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">TerminationCondition</span><span class="o">.</span><span class="n">infeasible</span><span class="p">:</span>
                    <span class="n">all_obj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">Theta</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="p">[</span><span class="n">obj</span><span class="p">])</span>
                <span class="c1"># DLW, Aug2018: should we also store the worst solver status?</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span><span class="p">,</span> <span class="n">thetvals</span><span class="p">,</span> <span class="n">worststatus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Q_at_theta</span><span class="p">(</span>
                <span class="n">thetavals</span><span class="o">=</span><span class="p">{},</span> <span class="n">initialize_parmest_model</span><span class="o">=</span><span class="n">initialize_parmest_model</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">worststatus</span> <span class="o">!=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">TerminationCondition</span><span class="o">.</span><span class="n">infeasible</span><span class="p">:</span>
                <span class="n">all_obj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">thetvals</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="p">[</span><span class="n">obj</span><span class="p">])</span>

        <span class="n">global_all_obj</span> <span class="o">=</span> <span class="n">task_mgr</span><span class="o">.</span><span class="n">allgather_global_data</span><span class="p">(</span><span class="n">all_obj</span><span class="p">)</span>
        <span class="n">dfcols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">theta_names</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;obj&#39;</span><span class="p">]</span>
        <span class="n">obj_at_theta</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">global_all_obj</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">dfcols</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj_at_theta</span></div>

<div class="viewcode-block" id="Estimator.likelihood_ratio_test"><a class="viewcode-back" href="../../../../contributed_packages/parmest/api.html#pyomo.contrib.parmest.parmest.Estimator.likelihood_ratio_test">[docs]</a>    <span class="k">def</span> <span class="nf">likelihood_ratio_test</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">obj_at_theta</span><span class="p">,</span> <span class="n">obj_value</span><span class="p">,</span> <span class="n">alphas</span><span class="p">,</span> <span class="n">return_thresholds</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Likelihood ratio test to identify theta values within a confidence</span>
<span class="sd">        region using the :math:`\chi^2` distribution</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obj_at_theta: pd.DataFrame, columns = theta_names + &#39;obj&#39;</span>
<span class="sd">            Objective values for each theta value (returned by</span>
<span class="sd">            objective_at_theta)</span>
<span class="sd">        obj_value: int or float</span>
<span class="sd">            Objective value from parameter estimation using all data</span>
<span class="sd">        alphas: list</span>
<span class="sd">            List of alpha values to use in the chi2 test</span>
<span class="sd">        return_thresholds: bool, optional</span>
<span class="sd">            Return the threshold value for each alpha</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        LR: pd.DataFrame</span>
<span class="sd">            Objective values for each theta value along with True or False for</span>
<span class="sd">            each alpha</span>
<span class="sd">        thresholds: pd.Series</span>
<span class="sd">            If return_threshold = True, the thresholds are also returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj_at_theta</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj_value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alphas</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_thresholds</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

        <span class="n">LR</span> <span class="o">=</span> <span class="n">obj_at_theta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">S</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_data</span><span class="p">)</span>
        <span class="n">thresholds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">alphas</span><span class="p">:</span>
            <span class="n">chi2_val</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">thresholds</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj_value</span> <span class="o">*</span> <span class="p">((</span><span class="n">chi2_val</span> <span class="o">/</span> <span class="p">(</span><span class="n">S</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">LR</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">LR</span><span class="p">[</span><span class="s1">&#39;obj&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>

        <span class="n">thresholds</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">thresholds</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_thresholds</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">LR</span><span class="p">,</span> <span class="n">thresholds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">LR</span></div>

<div class="viewcode-block" id="Estimator.confidence_region_test"><a class="viewcode-back" href="../../../../contributed_packages/parmest/api.html#pyomo.contrib.parmest.parmest.Estimator.confidence_region_test">[docs]</a>    <span class="k">def</span> <span class="nf">confidence_region_test</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">theta_values</span><span class="p">,</span> <span class="n">distribution</span><span class="p">,</span> <span class="n">alphas</span><span class="p">,</span> <span class="n">test_theta_values</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Confidence region test to determine if theta values are within a</span>
<span class="sd">        rectangular, multivariate normal, or Gaussian kernel density distribution</span>
<span class="sd">        for a range of alpha values</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta_values: pd.DataFrame, columns = theta_names</span>
<span class="sd">            Theta values used to generate a confidence region</span>
<span class="sd">            (generally returned by theta_est_bootstrap)</span>
<span class="sd">        distribution: string</span>
<span class="sd">            Statistical distribution used to define a confidence region,</span>
<span class="sd">            options = &#39;MVN&#39; for multivariate_normal, &#39;KDE&#39; for gaussian_kde,</span>
<span class="sd">            and &#39;Rect&#39; for rectangular.</span>
<span class="sd">        alphas: list</span>
<span class="sd">            List of alpha values used to determine if theta values are inside</span>
<span class="sd">            or outside the region.</span>
<span class="sd">        test_theta_values: pd.Series or pd.DataFrame, keys/columns = theta_names, optional</span>
<span class="sd">            Additional theta values that are compared to the confidence region</span>
<span class="sd">            to determine if they are inside or outside.</span>

<span class="sd">        Returns</span>
<span class="sd">        training_results: pd.DataFrame</span>
<span class="sd">            Theta value used to generate the confidence region along with True</span>
<span class="sd">            (inside) or False (outside) for each alpha</span>
<span class="sd">        test_results: pd.DataFrame</span>
<span class="sd">            If test_theta_values is not None, returns test theta value along</span>
<span class="sd">            with True (inside) or False (outside) for each alpha</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">theta_values</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">distribution</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Rect&#39;</span><span class="p">,</span> <span class="s1">&#39;MVN&#39;</span><span class="p">,</span> <span class="s1">&#39;KDE&#39;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alphas</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">test_theta_values</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">test_theta_values</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)):</span>
            <span class="n">test_theta_values</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">test_theta_values</span><span class="p">)</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="n">training_results</span> <span class="o">=</span> <span class="n">theta_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">test_theta_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">test_result</span> <span class="o">=</span> <span class="n">test_theta_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">alphas</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;Rect&#39;</span><span class="p">:</span>
                <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">graphics</span><span class="o">.</span><span class="n">fit_rect_dist</span><span class="p">(</span><span class="n">theta_values</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                <span class="n">training_results</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">theta_values</span> <span class="o">&gt;</span> <span class="n">lb</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span>
                    <span class="n">theta_values</span> <span class="o">&lt;</span> <span class="n">ub</span>
                <span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">test_theta_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># use upper and lower bound from the training set</span>
                    <span class="n">test_result</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">test_theta_values</span> <span class="o">&gt;</span> <span class="n">lb</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span>
                        <span class="n">test_theta_values</span> <span class="o">&lt;</span> <span class="n">ub</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;MVN&#39;</span><span class="p">:</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">graphics</span><span class="o">.</span><span class="n">fit_mvn_dist</span><span class="p">(</span><span class="n">theta_values</span><span class="p">)</span>
                <span class="n">Z</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">theta_values</span><span class="p">)</span>
                <span class="n">score</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">scoreatpercentile</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
                <span class="n">training_results</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">&gt;=</span> <span class="n">score</span>

                <span class="k">if</span> <span class="n">test_theta_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># use score from the training set</span>
                    <span class="n">Z</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">test_theta_values</span><span class="p">)</span>
                    <span class="n">test_result</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">&gt;=</span> <span class="n">score</span>

            <span class="k">elif</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;KDE&#39;</span><span class="p">:</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">graphics</span><span class="o">.</span><span class="n">fit_kde_dist</span><span class="p">(</span><span class="n">theta_values</span><span class="p">)</span>
                <span class="n">Z</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">theta_values</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
                <span class="n">score</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">scoreatpercentile</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
                <span class="n">training_results</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">&gt;=</span> <span class="n">score</span>

                <span class="k">if</span> <span class="n">test_theta_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># use score from the training set</span>
                    <span class="n">Z</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">test_theta_values</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
                    <span class="n">test_result</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">&gt;=</span> <span class="n">score</span>

        <span class="k">if</span> <span class="n">test_theta_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">training_results</span><span class="p">,</span> <span class="n">test_result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">training_results</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2008-2023, Sandia National Laboratories.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>