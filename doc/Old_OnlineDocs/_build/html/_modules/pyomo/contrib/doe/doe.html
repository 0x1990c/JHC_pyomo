

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>pyomo.contrib.doe.doe &mdash; Pyomo 6.5.1.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/theme_overrides.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/clipboard.min.js"></script>
        <script src="../../../../_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> Pyomo
          

          
          </a>

          
            
            
              <div class="version">
                6.5.1.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../citing_pyomo.html">Citing Pyomo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pyomo_overview/index.html">Pyomo Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pyomo_modeling_components/index.html">Pyomo Modeling Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../solving_pyomo_models.html">Solving Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_models.html">Working with Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_abstractmodels/index.html">Working with Abstract Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_transformations/index.html">Model Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modeling_extensions/index.html">Modeling Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial_examples.html">Pyomo Tutorial Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_debugging/index.html">Debugging Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../advanced_topics/index.html">Advanced Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../errors.html">Common Warnings/Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_reference/index.html">Developer Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../library_reference/index.html">Library Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contribution_guide.html">Contributing to Pyomo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributed_packages/index.html">Third-Party Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../related_packages.html">Related Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Pyomo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>pyomo.contrib.doe.doe</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyomo.contrib.doe.doe</h1><div class="highlight"><pre>
<span></span><span class="c1">#  ___________________________________________________________________________</span>
<span class="c1">#</span>
<span class="c1">#  Pyomo: Python Optimization Modeling Objects</span>
<span class="c1">#  Copyright (c) 2008-2022</span>
<span class="c1">#  National Technology and Engineering Solutions of Sandia, LLC</span>
<span class="c1">#  Under the terms of Contract DE-NA0003525 with National Technology and</span>
<span class="c1">#  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain</span>
<span class="c1">#  rights in this software.</span>
<span class="c1">#  This software is distributed under the 3-clause BSD License.</span>
<span class="c1">#</span>
<span class="c1">#  Pyomo.DoE was produced under the Department of Energy Carbon Capture Simulation</span>
<span class="c1">#  Initiative (CCSI), and is copyright (c) 2022 by the software owners:</span>
<span class="c1">#  TRIAD National Security, LLC., Lawrence Livermore National Security, LLC.,</span>
<span class="c1">#  Lawrence Berkeley National Laboratory, Pacific Northwest National Laboratory,</span>
<span class="c1">#  Battelle Memorial Institute, University of Notre Dame,</span>
<span class="c1">#  The University of Pittsburgh, The University of Texas at Austin,</span>
<span class="c1">#  University of Toledo, West Virginia University, et al. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1">#  NOTICE. This Software was developed under funding from the</span>
<span class="c1">#  U.S. Department of Energy and the U.S. Government consequently retains</span>
<span class="c1">#  certain rights. As such, the U.S. Government has been granted for itself</span>
<span class="c1">#  and others acting on its behalf a paid-up, nonexclusive, irrevocable,</span>
<span class="c1">#  worldwide license in the Software to reproduce, distribute copies to the</span>
<span class="c1">#  public, prepare derivative works, and perform publicly and display</span>
<span class="c1">#  publicly, and to permit other to do so.</span>
<span class="c1">#  ___________________________________________________________________________</span>


<span class="kn">from</span> <span class="nn">pyomo.common.dependencies</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span><span class="p">,</span> <span class="n">numpy_available</span>

<span class="kn">import</span> <span class="nn">pyomo.environ</span> <span class="k">as</span> <span class="nn">pyo</span>
<span class="kn">from</span> <span class="nn">pyomo.opt</span> <span class="kn">import</span> <span class="n">SolverFactory</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">permutations</span><span class="p">,</span> <span class="n">product</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">from</span> <span class="nn">pyomo.common.timing</span> <span class="kn">import</span> <span class="n">TicTocTimer</span>
<span class="kn">from</span> <span class="nn">pyomo.contrib.sensitivity_toolbox.sens</span> <span class="kn">import</span> <span class="n">get_dsdp</span>
<span class="kn">from</span> <span class="nn">pyomo.contrib.doe.scenario</span> <span class="kn">import</span> <span class="n">ScenarioGenerator</span><span class="p">,</span> <span class="n">FiniteDifferenceStep</span>
<span class="kn">from</span> <span class="nn">pyomo.contrib.doe.result</span> <span class="kn">import</span> <span class="n">FisherResults</span><span class="p">,</span> <span class="n">GridSearchResult</span>


<span class="k">class</span> <span class="nc">CalculationMode</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">sequential_finite</span> <span class="o">=</span> <span class="s2">&quot;sequential_finite&quot;</span>
    <span class="n">direct_kaug</span> <span class="o">=</span> <span class="s2">&quot;direct_kaug&quot;</span>


<span class="k">class</span> <span class="nc">ObjectiveLib</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">det</span> <span class="o">=</span> <span class="s2">&quot;det&quot;</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="s2">&quot;trace&quot;</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="s2">&quot;zero&quot;</span>


<span class="k">class</span> <span class="nc">ModelOptionLib</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">parmest</span> <span class="o">=</span> <span class="s2">&quot;parmest&quot;</span>
    <span class="n">stage1</span> <span class="o">=</span> <span class="s2">&quot;stage1&quot;</span>
    <span class="n">stage2</span> <span class="o">=</span> <span class="s2">&quot;stage2&quot;</span>


<div class="viewcode-block" id="DesignOfExperiments"><a class="viewcode-back" href="../../../../contributed_packages/doe/doe.html#pyomo.contrib.doe.doe.DesignOfExperiments">[docs]</a><span class="k">class</span> <span class="nc">DesignOfExperiments</span><span class="p">:</span>
<div class="viewcode-block" id="DesignOfExperiments.__init__"><a class="viewcode-back" href="../../../../contributed_packages/doe/doe.html#pyomo.contrib.doe.doe.DesignOfExperiments.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">param_init</span><span class="p">,</span>
        <span class="n">design_vars</span><span class="p">,</span>
        <span class="n">measurement_vars</span><span class="p">,</span>
        <span class="n">create_model</span><span class="p">,</span>
        <span class="n">solver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">prior_FIM</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">discretize_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This package enables model-based design of experiments analysis with Pyomo.</span>
<span class="sd">        Both direct optimization and enumeration modes are supported.</span>
<span class="sd">        NLP sensitivity tools, e.g.,  sipopt and k_aug, are supported to accelerate analysis via enumeration.</span>
<span class="sd">        It can be applied to dynamic models, where design variables are controlled throughout the experiment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        param_init:</span>
<span class="sd">            A  ``dictionary`` of parameter names and values.</span>
<span class="sd">            If they defined as indexed Pyomo variable, put the variable name and index, such as &#39;theta[&quot;A1&quot;]&#39;.</span>
<span class="sd">        design_vars:</span>
<span class="sd">            A ``DesignVariables`` which contains the Pyomo variable names and their corresponding indices</span>
<span class="sd">            and bounds for experiment degrees of freedom</span>
<span class="sd">        measurement_vars:</span>
<span class="sd">            A ``MeasurementVariables`` which contains the Pyomo variable names and their corresponding indices and</span>
<span class="sd">            bounds for experimental measurements</span>
<span class="sd">        create_model:</span>
<span class="sd">            A Python ``function`` that returns a Concrete Pyomo model, similar to the interface for ``parmest``</span>
<span class="sd">        solver:</span>
<span class="sd">            A ``solver`` object that User specified, default=None.</span>
<span class="sd">            If not specified, default solver is IPOPT MA57.</span>
<span class="sd">        prior_FIM:</span>
<span class="sd">            A 2D numpy array containing Fisher information matrix (FIM) for prior experiments.</span>
<span class="sd">            The default None means there is no prior information.</span>
<span class="sd">        discretize_model:</span>
<span class="sd">            A user-specified ``function`` that discretizes the model. Only use with Pyomo.DAE, default=None</span>
<span class="sd">        args:</span>
<span class="sd">            Additional arguments for the create_model function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span> <span class="o">=</span> <span class="n">param_init</span>
        <span class="c1"># design variable name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">design_name</span> <span class="o">=</span> <span class="n">design_vars</span><span class="o">.</span><span class="n">variable_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">design_vars</span> <span class="o">=</span> <span class="n">design_vars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_model</span> <span class="o">=</span> <span class="n">create_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>

        <span class="c1"># create the measurement information object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">measurement_vars</span> <span class="o">=</span> <span class="n">measurement_vars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">measure_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_vars</span><span class="o">.</span><span class="n">variable_names</span>

        <span class="c1"># check if user-defined solver is given</span>
        <span class="k">if</span> <span class="n">solver</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">solver</span>
        <span class="c1"># if not given, use default solver</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_default_ipopt_solver</span><span class="p">()</span>

        <span class="c1"># check if discretization is needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discretize_model</span> <span class="o">=</span> <span class="n">discretize_model</span>

        <span class="c1"># check if there is prior info</span>
        <span class="k">if</span> <span class="n">prior_FIM</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prior_FIM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prior_FIM</span> <span class="o">=</span> <span class="n">prior_FIM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_inputs</span><span class="p">()</span>

        <span class="c1"># if print statements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_check_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the prior FIM is N*N matrix, where N is the number of parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prior_FIM</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prior_FIM</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prior_FIM</span><span class="p">)[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Found wrong prior information matrix shape.&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prior_FIM</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Found wrong prior information matrix shape.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="DesignOfExperiments.stochastic_program"><a class="viewcode-back" href="../../../../contributed_packages/doe/doe.html#pyomo.contrib.doe.doe.DesignOfExperiments.stochastic_program">[docs]</a>    <span class="k">def</span> <span class="nf">stochastic_program</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">if_optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">objective_option</span><span class="o">=</span><span class="s2">&quot;det&quot;</span><span class="p">,</span>
        <span class="n">scale_nominal_param_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">scale_constant_value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">optimize_opt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">if_Cholesky</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">L_LB</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span>
        <span class="n">L_initial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">jac_initial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fim_initial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">formula</span><span class="o">=</span><span class="s2">&quot;central&quot;</span><span class="p">,</span>
        <span class="n">step</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
        <span class="n">tee_opt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimize DOE problem with design variables being the decisions.</span>
<span class="sd">        The DOE model is formed invasively and all scenarios are computed simultaneously.</span>
<span class="sd">        The function will first run a square problem with design variable being fixed at</span>
<span class="sd">        the given initial points (Objective function being 0), then a square problem with</span>
<span class="sd">        design variables being fixed at the given initial points (Objective function being Design optimality),</span>
<span class="sd">        and then unfix the design variable and do the optimization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        if_optimize:</span>
<span class="sd">            if true, continue to do optimization. else, just run square problem with given design variable values</span>
<span class="sd">        objective_option:</span>
<span class="sd">            choose from the ObjectiveLib enum,</span>
<span class="sd">            &quot;det&quot;: maximizing the determinant with ObjectiveLib.det,</span>
<span class="sd">            &quot;trace&quot;: or the trace of the FIM with ObjectiveLib.trace</span>
<span class="sd">        scale_nominal_param_value:</span>
<span class="sd">            if True, the parameters are scaled by its own nominal value in param_init</span>
<span class="sd">        scale_constant_value:</span>
<span class="sd">            scale all elements in Jacobian matrix, default is 1.</span>
<span class="sd">        optimize_opt:</span>
<span class="sd">            A dictionary, keys are design variables, values are True or False deciding if this design variable will be optimized as DOF or not</span>
<span class="sd">        if_Cholesky:</span>
<span class="sd">            if True, Cholesky decomposition is used for Objective function for D-optimality.</span>
<span class="sd">        L_LB:</span>
<span class="sd">            L is the Cholesky decomposition matrix for FIM, i.e. FIM = L*L.T.</span>
<span class="sd">            L_LB is the lower bound for every element in L.</span>
<span class="sd">            if FIM is positive definite, the diagonal element should be positive, so we can set a LB like 1E-10</span>
<span class="sd">        L_initial:</span>
<span class="sd">            initialize the L</span>
<span class="sd">        jac_initial:</span>
<span class="sd">            a matrix used to initialize jacobian matrix</span>
<span class="sd">        fim_initial:</span>
<span class="sd">            a matrix used to initialize FIM matrix</span>
<span class="sd">        formula:</span>
<span class="sd">            choose from &quot;central&quot;, &quot;forward&quot;, &quot;backward&quot;,</span>
<span class="sd">            which refers to the Enum FiniteDifferenceStep.central, .forward, or .backward</span>
<span class="sd">        step:</span>
<span class="sd">            Sensitivity perturbation step size, a fraction between [0,1]. default is 0.001</span>
<span class="sd">        tee_opt:</span>
<span class="sd">            if True, IPOPT console output is printed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        analysis_square: result summary of the square problem solved at the initial point</span>
<span class="sd">        analysis_optimize: result summary of the optimization problem solved</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># store inputs in object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">design_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">design_vars</span><span class="o">.</span><span class="n">variable_names_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span> <span class="o">=</span> <span class="n">if_optimize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objective_option</span> <span class="o">=</span> <span class="n">ObjectiveLib</span><span class="p">(</span><span class="n">objective_option</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_nominal_param_value</span> <span class="o">=</span> <span class="n">scale_nominal_param_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_constant_value</span> <span class="o">=</span> <span class="n">scale_constant_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Cholesky_option</span> <span class="o">=</span> <span class="n">if_Cholesky</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L_LB</span> <span class="o">=</span> <span class="n">L_LB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L_initial</span> <span class="o">=</span> <span class="n">L_initial</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jac_initial</span> <span class="o">=</span> <span class="n">jac_initial</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fim_initial</span> <span class="o">=</span> <span class="n">fim_initial</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">formula</span> <span class="o">=</span> <span class="n">FiniteDifferenceStep</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="o">=</span> <span class="n">step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tee_opt</span> <span class="o">=</span> <span class="n">tee_opt</span>

        <span class="c1"># calculate how much the FIM element is scaled by a constant number</span>
        <span class="c1"># FIM = Jacobian.T@Jacobian, the FIM is scaled by squared value the Jacobian is scaled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fim_scale_constant_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_constant_value</span><span class="o">**</span><span class="mi">2</span>

        <span class="n">sp_timer</span> <span class="o">=</span> <span class="n">TicTocTimer</span><span class="p">()</span>
        <span class="n">sp_timer</span><span class="o">.</span><span class="n">tic</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># build the large DOE pyomo model</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_doe_model</span><span class="p">(</span><span class="n">no_obj</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># solve model, achieve results for square problem, and results for optimization problem</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">analysis_square</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_stochastic_program</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">optimize_opt</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">:</span>
            <span class="n">analysis_optimize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_stochastic_program</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">dT</span> <span class="o">=</span> <span class="n">sp_timer</span><span class="o">.</span><span class="n">toc</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;elapsed time: </span><span class="si">%0.1f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">dT</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">analysis_square</span><span class="p">,</span> <span class="n">analysis_optimize</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">dT</span> <span class="o">=</span> <span class="n">sp_timer</span><span class="o">.</span><span class="n">toc</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;elapsed time: </span><span class="si">%0.1f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">dT</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">analysis_square</span></div>

    <span class="k">def</span> <span class="nf">_compute_stochastic_program</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">optimize_option</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solve the stochastic program problem as a square problem.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Solve square problem first</span>
        <span class="c1"># result_square: solver result</span>
        <span class="n">result_square</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_doe</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">fix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">opt_option</span><span class="o">=</span><span class="n">optimize_option</span><span class="p">)</span>

        <span class="c1"># extract Jac</span>
        <span class="n">jac_square</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_jac</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="c1"># create result object</span>
        <span class="n">analysis_square</span> <span class="o">=</span> <span class="n">FisherResults</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">measurement_vars</span><span class="p">,</span>
            <span class="n">jacobian_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">all_jacobian_info</span><span class="o">=</span><span class="n">jac_square</span><span class="p">,</span>
            <span class="n">prior_FIM</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prior_FIM</span><span class="p">,</span>
            <span class="n">scale_constant_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_constant_value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># for simultaneous mode, FIM and Jacobian are extracted with extract_FIM()</span>
        <span class="n">analysis_square</span><span class="o">.</span><span class="n">result_analysis</span><span class="p">(</span><span class="n">result</span><span class="o">=</span><span class="n">result_square</span><span class="p">)</span>

        <span class="n">analysis_square</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">m</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_square</span> <span class="o">=</span> <span class="n">analysis_square</span>
        <span class="k">return</span> <span class="n">m</span><span class="p">,</span> <span class="n">analysis_square</span>

    <span class="k">def</span> <span class="nf">_optimize_stochastic_program</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solve the stochastic program problem as an optimization problem.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_objective</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="n">result_doe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_doe</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">fix</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># extract Jac</span>
        <span class="n">jac_optimize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_jac</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="c1"># create result object</span>
        <span class="n">analysis_optimize</span> <span class="o">=</span> <span class="n">FisherResults</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">measurement_vars</span><span class="p">,</span>
            <span class="n">jacobian_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">all_jacobian_info</span><span class="o">=</span><span class="n">jac_optimize</span><span class="p">,</span>
            <span class="n">prior_FIM</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prior_FIM</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># for simultaneous mode, FIM and Jacobian are extracted with extract_FIM()</span>
        <span class="n">analysis_optimize</span><span class="o">.</span><span class="n">result_analysis</span><span class="p">(</span><span class="n">result</span><span class="o">=</span><span class="n">result_doe</span><span class="p">)</span>
        <span class="n">analysis_optimize</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">m</span>

        <span class="k">return</span> <span class="n">analysis_optimize</span>

<div class="viewcode-block" id="DesignOfExperiments.compute_FIM"><a class="viewcode-back" href="../../../../contributed_packages/doe/doe.html#pyomo.contrib.doe.doe.DesignOfExperiments.compute_FIM">[docs]</a>    <span class="k">def</span> <span class="nf">compute_FIM</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;direct_kaug&quot;</span><span class="p">,</span>
        <span class="n">FIM_store_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">specified_prior</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tee_opt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">scale_nominal_param_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">scale_constant_value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">store_output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">read_output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">extract_single_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">formula</span><span class="o">=</span><span class="s2">&quot;central&quot;</span><span class="p">,</span>
        <span class="n">step</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function calculates the Fisher information matrix (FIM) using sensitivity information obtained</span>
<span class="sd">        from two possible modes (defined by the CalculationMode Enum):</span>

<span class="sd">            1.  sequential_finite: sequentially solve square problems and use finite difference approximation</span>
<span class="sd">            2.  direct_kaug: solve a single square problem then extract derivatives using NLP sensitivity theory</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode:</span>
<span class="sd">            supports CalculationMode.sequential_finite or CalculationMode.direct_kaug</span>
<span class="sd">        FIM_store_name:</span>
<span class="sd">            if storing the FIM in a .csv or .txt, give the file name here as a string.</span>
<span class="sd">        specified_prior:</span>
<span class="sd">            a 2D numpy array providing alternate prior matrix, default is no prior.</span>
<span class="sd">        tee_opt:</span>
<span class="sd">            if True, IPOPT console output is printed</span>
<span class="sd">        scale_nominal_param_value:</span>
<span class="sd">            if True, the parameters are scaled by its own nominal value in param_init</span>
<span class="sd">        scale_constant_value:</span>
<span class="sd">            scale all elements in Jacobian matrix, default is 1.</span>
<span class="sd">        store_output:</span>
<span class="sd">            if storing the output (value stored in Var &#39;output_record&#39;) as a pickle file, give the file name here as a string.</span>
<span class="sd">        read_output:</span>
<span class="sd">            if reading the output (value for Var &#39;output_record&#39;) as a pickle file, give the file name here as a string.</span>
<span class="sd">        extract_single_model:</span>
<span class="sd">            if True, the solved model outputs for each scenario are all recorded as a .csv file.</span>
<span class="sd">            The output file uses the name AB.csv, where string A is store_output input, B is the index of scenario.</span>
<span class="sd">            scenario index is the number of the scenario outputs which is stored.</span>
<span class="sd">        formula:</span>
<span class="sd">            choose from the Enum FiniteDifferenceStep.central, .forward, or .backward.</span>
<span class="sd">            This option is only used for CalculationMode.sequential_finite mode.</span>
<span class="sd">        step:</span>
<span class="sd">            Sensitivity perturbation step size, a fraction between [0,1]. default is 0.001</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        FIM_analysis: result summary object of this solve</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># save inputs in object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">design_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">design_vars</span><span class="o">.</span><span class="n">variable_names_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_nominal_param_value</span> <span class="o">=</span> <span class="n">scale_nominal_param_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_constant_value</span> <span class="o">=</span> <span class="n">scale_constant_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">formula</span> <span class="o">=</span> <span class="n">FiniteDifferenceStep</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">CalculationMode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="o">=</span> <span class="n">step</span>

        <span class="c1"># This method only solves square problem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Set the Objective Function to 0 helps solve square problem quickly</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objective_option</span> <span class="o">=</span> <span class="n">ObjectiveLib</span><span class="o">.</span><span class="n">zero</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tee_opt</span> <span class="o">=</span> <span class="n">tee_opt</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">FIM_store_name</span> <span class="o">=</span> <span class="n">FIM_store_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">specified_prior</span> <span class="o">=</span> <span class="n">specified_prior</span>

        <span class="c1"># calculate how much the FIM element is scaled by a constant number</span>
        <span class="c1"># As FIM~Jacobian.T@Jacobian, FIM is scaled twice the number the Q is scaled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fim_scale_constant_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_constant_value</span><span class="o">**</span><span class="mi">2</span>

        <span class="n">square_timer</span> <span class="o">=</span> <span class="n">TicTocTimer</span><span class="p">()</span>
        <span class="n">square_timer</span><span class="o">.</span><span class="n">tic</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">CalculationMode</span><span class="o">.</span><span class="n">sequential_finite</span><span class="p">:</span>
            <span class="n">FIM_analysis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sequential_finite</span><span class="p">(</span>
                <span class="n">read_output</span><span class="p">,</span> <span class="n">extract_single_model</span><span class="p">,</span> <span class="n">store_output</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">CalculationMode</span><span class="o">.</span><span class="n">direct_kaug</span><span class="p">:</span>
            <span class="n">FIM_analysis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_direct_kaug</span><span class="p">()</span>

        <span class="n">dT</span> <span class="o">=</span> <span class="n">square_timer</span><span class="o">.</span><span class="n">toc</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;elapsed time: </span><span class="si">%0.1f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">dT</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">FIM_analysis</span></div>

    <span class="k">def</span> <span class="nf">_sequential_finite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">read_output</span><span class="p">,</span> <span class="n">extract_single_model</span><span class="p">,</span> <span class="n">store_output</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sequential_finite mode uses Pyomo Block to evaluate the sensitivity information.&quot;&quot;&quot;</span>

        <span class="c1"># if measurements are provided</span>
        <span class="k">if</span> <span class="n">read_output</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">read_output</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">output_record</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finite_calculation</span><span class="p">(</span><span class="n">output_record</span><span class="p">)</span>

        <span class="c1"># if measurements are not provided</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_block</span><span class="p">()</span>

            <span class="c1"># dict for storing model outputs</span>
            <span class="n">output_record</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># solve model</span>
            <span class="n">square_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_doe</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">fix</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">extract_single_model</span><span class="p">:</span>
                <span class="n">mod_name</span> <span class="o">=</span> <span class="n">store_output</span> <span class="o">+</span> <span class="s1">&#39;.csv&#39;</span>
                <span class="n">dataframe</span> <span class="o">=</span> <span class="n">extract_single_model</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">square_result</span><span class="p">)</span>
                <span class="n">dataframe</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">mod_name</span><span class="p">)</span>

            <span class="c1"># loop over blocks for results</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scenario_list</span><span class="p">)):</span>
                <span class="c1"># loop over measurement item and time to store model measurements</span>
                <span class="n">output_iter</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># extract variable values</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_name</span><span class="p">:</span>
                    <span class="n">cuid</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">ComponentUID</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">var_up</span> <span class="o">=</span> <span class="n">cuid</span><span class="o">.</span><span class="n">find_component_on</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;measurement </span><span class="si">{</span><span class="n">r</span><span class="si">}</span><span class="s2"> cannot be found in the model.&quot;</span>
                        <span class="p">)</span>
                    <span class="n">output_iter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pyo</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">var_up</span><span class="p">))</span>

                <span class="n">output_record</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_iter</span>

                <span class="n">output_record</span><span class="p">[</span><span class="s1">&#39;design&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">design_values</span>

                <span class="k">if</span> <span class="n">store_output</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">store_output</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
                    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">output_record</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="c1"># calculate jacobian</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finite_calculation</span><span class="p">(</span><span class="n">output_record</span><span class="p">)</span>

            <span class="c1"># return all models formed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">mod</span>

            <span class="c1"># Store the Jacobian information for access by users, not necessarily call result object to achieve jacobian information</span>
            <span class="c1"># It is the overall set of Jacobian information,</span>
            <span class="c1"># while in the result object the jacobian can be cut to achieve part of the FIM information</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jac</span> <span class="o">=</span> <span class="n">jac</span>

        <span class="c1"># Assemble and analyze results</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">specified_prior</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prior_in_use</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior_FIM</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prior_in_use</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specified_prior</span>

        <span class="n">FIM_analysis</span> <span class="o">=</span> <span class="n">FisherResults</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">measurement_vars</span><span class="p">,</span>
            <span class="n">jacobian_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">all_jacobian_info</span><span class="o">=</span><span class="n">jac</span><span class="p">,</span>
            <span class="n">prior_FIM</span><span class="o">=</span><span class="n">prior_in_use</span><span class="p">,</span>
            <span class="n">store_FIM</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">FIM_store_name</span><span class="p">,</span>
            <span class="n">scale_constant_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_constant_value</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">FIM_analysis</span>

    <span class="k">def</span> <span class="nf">_direct_kaug</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># create model</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_model</span><span class="p">(</span><span class="n">model_option</span><span class="o">=</span><span class="n">ModelOptionLib</span><span class="o">.</span><span class="n">parmest</span><span class="p">)</span>

        <span class="c1"># discretize if needed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">discretize_model</span><span class="p">:</span>
            <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discretize_model</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># add objective function</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">Obj</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Objective</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sense</span><span class="o">=</span><span class="n">pyo</span><span class="o">.</span><span class="n">minimize</span><span class="p">)</span>

        <span class="c1"># set ub and lb to parameters</span>
        <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">cuid</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">ComponentUID</span><span class="p">(</span><span class="n">par</span><span class="p">)</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">cuid</span><span class="o">.</span><span class="n">find_component_on</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>
            <span class="n">var</span><span class="o">.</span><span class="n">setlb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="n">par</span><span class="p">])</span>
            <span class="n">var</span><span class="o">.</span><span class="n">setub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="n">par</span><span class="p">])</span>

        <span class="c1"># generate parameter name list and value dictionary with index</span>
        <span class="n">var_name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># call k_aug get_dsdp function</span>
        <span class="n">square_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_doe</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">fix</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">dsdp_re</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">get_dsdp</span><span class="p">(</span>
            <span class="n">mod</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">,</span> <span class="n">tee</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tee_opt</span>
        <span class="p">)</span>

        <span class="c1"># analyze result</span>
        <span class="n">dsdp_array</span> <span class="o">=</span> <span class="n">dsdp_re</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dsdp</span> <span class="o">=</span> <span class="n">dsdp_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dsdp</span> <span class="o">=</span> <span class="n">col</span>
        <span class="c1"># store dsdp returned</span>
        <span class="n">dsdp_extract</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># get right lines from results</span>
        <span class="n">measurement_index</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># loop over measurement variables and their time points</span>
        <span class="k">for</span> <span class="n">mname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_name</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">kaug_no</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">mname</span><span class="p">)</span>
                <span class="n">measurement_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kaug_no</span><span class="p">)</span>
                <span class="c1"># get right line of dsdp</span>
                <span class="n">dsdp_extract</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dsdp_array</span><span class="p">[</span><span class="n">kaug_no</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># k_aug does not provide value for fixed variables</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;The variable is fixed:  </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">mname</span><span class="p">)</span>
                <span class="c1"># produce the sensitivity for fixed variables</span>
                <span class="n">zero_sens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">))</span>
                <span class="c1"># for fixed variables, the sensitivity are a zero vector</span>
                <span class="n">dsdp_extract</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zero_sens</span><span class="p">)</span>

        <span class="c1"># Extract and calculate sensitivity if scaled by constants or parameters.</span>
        <span class="c1"># Convert sensitivity to a dictionary</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">jac</span><span class="p">[</span><span class="n">par</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dsdp_extract</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">par</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="c1"># if scaled by parameter value or constant value</span>
                <span class="n">sensi</span> <span class="o">=</span> <span class="n">dsdp_extract</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_constant_value</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_nominal_param_value</span><span class="p">:</span>
                    <span class="n">sensi</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="n">par</span><span class="p">]</span>
                <span class="n">jac</span><span class="p">[</span><span class="n">par</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sensi</span><span class="p">)</span>

        <span class="c1"># check if another prior experiment FIM is provided other than the user-specified one</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">specified_prior</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prior_in_use</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior_FIM</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prior_in_use</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specified_prior</span>

        <span class="c1"># Assemble and analyze results</span>
        <span class="n">FIM_analysis</span> <span class="o">=</span> <span class="n">FisherResults</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">measurement_vars</span><span class="p">,</span>
            <span class="n">jacobian_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">all_jacobian_info</span><span class="o">=</span><span class="n">jac</span><span class="p">,</span>
            <span class="n">prior_FIM</span><span class="o">=</span><span class="n">prior_in_use</span><span class="p">,</span>
            <span class="n">store_FIM</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">FIM_store_name</span><span class="p">,</span>
            <span class="n">scale_constant_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_constant_value</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">jac</span> <span class="o">=</span> <span class="n">jac</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mod</span> <span class="o">=</span> <span class="n">mod</span>

        <span class="k">return</span> <span class="n">FIM_analysis</span>

    <span class="k">def</span> <span class="nf">_create_block</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a pyomo Concrete model and add blocks with different parameter perturbation scenarios.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># create scenario information for block scenarios</span>
        <span class="n">scena_gen</span> <span class="o">=</span> <span class="n">ScenarioGenerator</span><span class="p">(</span>
            <span class="n">parameter_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">,</span> <span class="n">formula</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">formula</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">scenario_data</span> <span class="o">=</span> <span class="n">scena_gen</span><span class="o">.</span><span class="n">ScenarioData</span>

        <span class="c1"># a list of dictionary, each one is a parameter dictionary with perturbed parameter values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scenario_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenario_data</span><span class="o">.</span><span class="n">scenario</span>
        <span class="c1"># dictionary, keys are parameter name, values are a list of scenario index where this parameter is perturbed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scenario_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenario_data</span><span class="o">.</span><span class="n">scena_num</span>
        <span class="c1"># dictionary, keys are parameter name, values are the perturbation step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps_abs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenario_data</span><span class="o">.</span><span class="n">eps_abs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scena_gen</span> <span class="o">=</span> <span class="n">scena_gen</span>

        <span class="c1"># Create a global model</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">ConcreteModel</span><span class="p">()</span>

        <span class="c1"># Set for block/scenarios</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">scenario</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scenario_data</span><span class="o">.</span><span class="n">scenario_indices</span><span class="p">)</span>

        <span class="c1"># Allow user to self-define complex design variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_model</span><span class="p">(</span><span class="n">mod</span><span class="o">=</span><span class="n">mod</span><span class="p">,</span> <span class="n">model_option</span><span class="o">=</span><span class="n">ModelOptionLib</span><span class="o">.</span><span class="n">stage1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">block_build</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
            <span class="c1"># create block scenarios</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create_model</span><span class="p">(</span><span class="n">mod</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">model_option</span><span class="o">=</span><span class="n">ModelOptionLib</span><span class="o">.</span><span class="n">stage2</span><span class="p">)</span>

            <span class="c1"># fix parameter values to perturbed values</span>
            <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">:</span>
                <span class="n">cuid</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">ComponentUID</span><span class="p">(</span><span class="n">par</span><span class="p">)</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">cuid</span><span class="o">.</span><span class="n">find_component_on</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="n">var</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scenario_data</span><span class="o">.</span><span class="n">scenario</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">par</span><span class="p">])</span>

        <span class="n">mod</span><span class="o">.</span><span class="n">block</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Block</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">scenario</span><span class="p">,</span> <span class="n">rule</span><span class="o">=</span><span class="n">block_build</span><span class="p">)</span>

        <span class="c1"># discretize the model</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">discretize_model</span><span class="p">:</span>
            <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discretize_model</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>

        <span class="c1"># force design variables in blocks to be equal to global design values</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">design_name</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">fix1</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
                <span class="n">cuid</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">ComponentUID</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="n">design_var_global</span> <span class="o">=</span> <span class="n">cuid</span><span class="o">.</span><span class="n">find_component_on</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>
                <span class="n">design_var</span> <span class="o">=</span> <span class="n">cuid</span><span class="o">.</span><span class="n">find_component_on</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">design_var</span> <span class="o">==</span> <span class="n">design_var_global</span>

            <span class="n">con_name</span> <span class="o">=</span> <span class="s2">&quot;con&quot;</span> <span class="o">+</span> <span class="n">name</span>
            <span class="n">mod</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="n">con_name</span><span class="p">,</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">scenario</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">fix1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">mod</span>

    <span class="k">def</span> <span class="nf">_finite_calculation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_record</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate Jacobian for sequential_finite mode</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        output_record: a dict of outputs, keys are scenario names, values are a list of measurements values</span>
<span class="sd">        scena_gen: an object generated by Scenario_creator class</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        jac: Jacobian matrix, a dictionary, keys are parameter names, values are a list of jacobian values with respect to this parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># dictionary form of jacobian</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># After collecting outputs from all scenarios, calculate sensitivity</span>
        <span class="k">for</span> <span class="n">para</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># extract involved scenario No. for each parameter from scenario class</span>
            <span class="n">involved_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenario_data</span><span class="o">.</span><span class="n">scena_num</span><span class="p">[</span><span class="n">para</span><span class="p">]</span>

            <span class="c1"># each parameter has two involved scenarios</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="n">involved_s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># positive perturbation</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="n">involved_s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># negative perturbation</span>
            <span class="n">list_jac</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">output_record</span><span class="p">[</span><span class="n">s1</span><span class="p">])):</span>
                <span class="n">sensi</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">output_record</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">output_record</span><span class="p">[</span><span class="n">s2</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                    <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenario_data</span><span class="o">.</span><span class="n">eps_abs</span><span class="p">[</span><span class="n">para</span><span class="p">]</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_constant_value</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_nominal_param_value</span><span class="p">:</span>
                    <span class="n">sensi</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="n">para</span><span class="p">]</span>
                <span class="n">list_jac</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sensi</span><span class="p">)</span>
            <span class="c1"># get Jacobian dict, keys are parameter name, values are sensitivity info</span>
            <span class="n">jac</span><span class="p">[</span><span class="n">para</span><span class="p">]</span> <span class="o">=</span> <span class="n">list_jac</span>

        <span class="k">return</span> <span class="n">jac</span>

    <span class="k">def</span> <span class="nf">_extract_jac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract jacobian from the stochastic program</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m: solved stochastic program model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        JAC: the overall jacobian as a dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># dictionary form of jacobian</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># loop over parameters</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">jac_para</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">measured_variables</span><span class="p">:</span>
                <span class="n">jac_para</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pyo</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">sensitivity_jacobian</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">res</span><span class="p">]))</span>
            <span class="n">jac</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">jac_para</span>
        <span class="k">return</span> <span class="n">jac</span>

<div class="viewcode-block" id="DesignOfExperiments.run_grid_search"><a class="viewcode-back" href="../../../../contributed_packages/doe/doe.html#pyomo.contrib.doe.doe.DesignOfExperiments.run_grid_search">[docs]</a>    <span class="k">def</span> <span class="nf">run_grid_search</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">design_ranges</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;sequential_finite&quot;</span><span class="p">,</span>
        <span class="n">tee_option</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">scale_nominal_param_value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">scale_constant_value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">store_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">read_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">store_optimality_as_csv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">formula</span><span class="o">=</span><span class="s2">&quot;central&quot;</span><span class="p">,</span>
        <span class="n">step</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enumerate through full grid search for any number of design variables;</span>
<span class="sd">        solve square problems sequentially to compute FIMs.</span>
<span class="sd">        It calculates FIM with sensitivity information from two modes:</span>

<span class="sd">            1. sequential_finite: Calculates a one scenario model multiple times for multiple scenarios.</span>
<span class="sd">               Sensitivity info estimated by finite difference</span>
<span class="sd">            2. direct_kaug: calculate sensitivity by k_aug with direct sensitivity</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        design_ranges:</span>
<span class="sd">            a ``dict``, keys are design variable names,</span>
<span class="sd">            values are a list of design variable values to go over</span>
<span class="sd">        mode:</span>
<span class="sd">            choose from CalculationMode.sequential_finite, .direct_kaug.</span>
<span class="sd">        tee_option:</span>
<span class="sd">            if solver console output is made</span>
<span class="sd">        scale_nominal_param_value:</span>
<span class="sd">            if True, the parameters are scaled by its own nominal value in param_init</span>
<span class="sd">        scale_constant_value:</span>
<span class="sd">            scale all elements in Jacobian matrix, default is 1.</span>
<span class="sd">        store_name:</span>
<span class="sd">            a string of file name. If not None, store results with this name.</span>
<span class="sd">            It is a pickle file containing all measurement information after solving the</span>
<span class="sd">            model with perturbations.</span>
<span class="sd">            Since there are multiple experiments, results are numbered with a scalar number,</span>
<span class="sd">            and the result for one grid is &#39;store_name(count).csv&#39; (count is the number of count).</span>
<span class="sd">        read_name:</span>
<span class="sd">            a string of file name. If not None, read result files.</span>
<span class="sd">            It should be a pickle file previously generated by store_name option.</span>
<span class="sd">            Since there are multiple experiments, this string should be the common part of all files;</span>
<span class="sd">            Real name of the file is &quot;read_name(count)&quot;, where count is the number of the experiment.</span>
<span class="sd">        store_optimality_as_csv:</span>
<span class="sd">            if True, the design criterion values of grid search results stored with this file name as a csv</span>
<span class="sd">        formula:</span>
<span class="sd">            choose from FiniteDifferenceStep.central, .forward, or .backward.</span>
<span class="sd">            This option is only used for CalculationMode.sequential_finite.</span>
<span class="sd">        step:</span>
<span class="sd">            Sensitivity perturbation step size, a fraction between [0,1]. default is 0.001</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        figure_draw_object: a combined result object of class Grid_search_result</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set the Objective Function to 0 helps solve square problem quickly</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objective_option</span> <span class="o">=</span> <span class="n">ObjectiveLib</span><span class="o">.</span><span class="n">zero</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_optimality_as_csv</span> <span class="o">=</span> <span class="n">store_optimality_as_csv</span>

        <span class="c1"># calculate how much the FIM element is scaled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fim_scale_constant_value</span> <span class="o">=</span> <span class="n">scale_constant_value</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1"># to store all FIM results</span>
        <span class="n">result_combine</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># all lists of values of each design variable to go over</span>
        <span class="n">design_ranges_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">design_ranges</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="c1"># design variable names to go over</span>
        <span class="n">design_dimension_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">design_ranges</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># iteration 0</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">failed_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># how many sets of design variables will be run</span>
        <span class="n">total_count</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">rng</span> <span class="ow">in</span> <span class="n">design_ranges_list</span><span class="p">:</span>
            <span class="n">total_count</span> <span class="o">*=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>

        <span class="n">time_set</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># record time for every iteration</span>

        <span class="c1"># generate combinations of design variable values to go over</span>
        <span class="n">search_design_set</span> <span class="o">=</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">design_ranges_list</span><span class="p">)</span>

        <span class="c1"># loop over design value combinations</span>
        <span class="k">for</span> <span class="n">design_set_iter</span> <span class="ow">in</span> <span class="n">search_design_set</span><span class="p">:</span>
            <span class="c1"># generate the design variable dictionary needed for running compute_FIM</span>
            <span class="c1"># first copy value from design_values</span>
            <span class="n">design_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">design_vars</span><span class="o">.</span><span class="n">variable_names_value</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># update the controlled value of certain time points for certain design variables</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">names</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">design_dimension_names</span><span class="p">):</span>
                <span class="c1"># names = design_dimension_names[i]</span>
                <span class="c1"># if the element is a list, all design variables in this list share the same values</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                        <span class="n">design_iter</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">design_set_iter</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">design_iter</span><span class="p">[</span><span class="n">names</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">design_set_iter</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">design_vars</span><span class="o">.</span><span class="n">variable_names_value</span> <span class="o">=</span> <span class="n">design_iter</span>
            <span class="n">iter_timer</span> <span class="o">=</span> <span class="n">TicTocTimer</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;=======Iteration Number: </span><span class="si">%s</span><span class="s1"> =====&#39;</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s1">&#39;Design variable values of this iteration: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">design_iter</span>
            <span class="p">)</span>
            <span class="n">iter_timer</span><span class="o">.</span><span class="n">tic</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="c1"># generate store name</span>
            <span class="k">if</span> <span class="n">store_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">store_output_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">store_output_name</span> <span class="o">=</span> <span class="n">store_name</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">read_name</span><span class="p">:</span>
                <span class="n">read_input_name</span> <span class="o">=</span> <span class="n">read_name</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">read_input_name</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># call compute_FIM to get FIM</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_FIM</span><span class="p">(</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                    <span class="n">tee_opt</span><span class="o">=</span><span class="n">tee_option</span><span class="p">,</span>
                    <span class="n">scale_nominal_param_value</span><span class="o">=</span><span class="n">scale_nominal_param_value</span><span class="p">,</span>
                    <span class="n">scale_constant_value</span><span class="o">=</span><span class="n">scale_constant_value</span><span class="p">,</span>
                    <span class="n">store_output</span><span class="o">=</span><span class="n">store_output_name</span><span class="p">,</span>
                    <span class="n">read_output</span><span class="o">=</span><span class="n">read_input_name</span><span class="p">,</span>
                    <span class="n">formula</span><span class="o">=</span><span class="n">formula</span><span class="p">,</span>
                    <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">result_iter</span><span class="o">.</span><span class="n">result_analysis</span><span class="p">()</span>

                <span class="c1"># iteration time</span>
                <span class="n">iter_t</span> <span class="o">=</span> <span class="n">iter_timer</span><span class="o">.</span><span class="n">toc</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">time_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iter_t</span><span class="p">)</span>

                <span class="c1"># give run information at each iteration</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s1">&#39;This is the  </span><span class="si">%s</span><span class="s1"> run out of  </span><span class="si">%s</span><span class="s1"> run.&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">total_count</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;The code has run  </span><span class="si">%s</span><span class="s1"> seconds.&#39;</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">time_set</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s1">&#39;Estimated remaining time:  </span><span class="si">%s</span><span class="s1"> seconds&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">time_set</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">total_count</span> <span class="o">-</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
                <span class="p">)</span>

                <span class="c1"># the combined result object are organized as a dictionary, keys are a tuple of the design variable values, values are a result object</span>
                <span class="n">result_combine</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">design_set_iter</span><span class="p">)]</span> <span class="o">=</span> <span class="n">result_iter</span>

            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s1">&#39;:::::::::::Warning: Cannot converge this run.::::::::::::&#39;</span>
                <span class="p">)</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">failed_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;failed count:&#39;</span><span class="p">,</span> <span class="n">failed_count</span><span class="p">)</span>
                <span class="n">result_combine</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">design_set_iter</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># For user&#39;s access</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_fim</span> <span class="o">=</span> <span class="n">result_combine</span>

        <span class="c1"># Create figure drawing object</span>
        <span class="n">figure_draw_object</span> <span class="o">=</span> <span class="n">GridSearchResult</span><span class="p">(</span>
            <span class="n">design_ranges_list</span><span class="p">,</span>
            <span class="n">design_dimension_names</span><span class="p">,</span>
            <span class="n">result_combine</span><span class="p">,</span>
            <span class="n">store_optimality_name</span><span class="o">=</span><span class="n">store_optimality_as_csv</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Overall wall clock time [s]:  </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">time_set</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">figure_draw_object</span></div>

    <span class="k">def</span> <span class="nf">_create_doe_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">no_obj</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add equations to compute sensitivities, FIM, and objective.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        no_obj: if True, objective function is 0.</span>

<span class="sd">        Return</span>
<span class="sd">        -------</span>
<span class="sd">        m: the DOE model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_block</span><span class="p">()</span>

        <span class="c1"># variables for jacobian and FIM</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">measured_variables</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">measure_name</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">identity_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

        <span class="n">mod</span><span class="o">.</span><span class="n">sensitivity_jacobian</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Var</span><span class="p">(</span>
            <span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">,</span> <span class="n">mod</span><span class="o">.</span><span class="n">measured_variables</span><span class="p">,</span> <span class="n">initialize</span><span class="o">=</span><span class="mf">0.1</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fim_initial</span><span class="p">:</span>
            <span class="n">dict_fim_initialize</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bu</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">un</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">):</span>
                    <span class="n">dict_fim_initialize</span><span class="p">[(</span><span class="n">bu</span><span class="p">,</span> <span class="n">un</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fim_initial</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">initialize_fim</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">dict_fim_initialize</span><span class="p">[(</span><span class="n">j</span><span class="p">,</span> <span class="n">d</span><span class="p">)]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fim_initial</span><span class="p">:</span>
            <span class="n">mod</span><span class="o">.</span><span class="n">fim</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Var</span><span class="p">(</span>
                <span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">,</span>
                <span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">,</span>
                <span class="n">initialize</span><span class="o">=</span><span class="n">initialize_fim</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mod</span><span class="o">.</span><span class="n">fim</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Var</span><span class="p">(</span>
                <span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">,</span>
                <span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">,</span>
                <span class="n">initialize</span><span class="o">=</span><span class="n">identity_matrix</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># move the L matrix initial point to a dictionary</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L_initial</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">dict_cho</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bu</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">un</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">):</span>
                    <span class="n">dict_cho</span><span class="p">[(</span><span class="n">bu</span><span class="p">,</span> <span class="n">un</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L_initial</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

        <span class="c1"># use the L dictionary to initialize L matrix</span>
        <span class="k">def</span> <span class="nf">init_cho</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">dict_cho</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span>

        <span class="c1"># if cholesky, define L elements as variables</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cholesky_option</span><span class="p">:</span>
            <span class="c1"># Define elements of Cholesky decomposition matrix as Pyomo variables and either</span>
            <span class="c1"># Initialize with L in L_initial</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L_initial</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">mod</span><span class="o">.</span><span class="n">L_ele</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Var</span><span class="p">(</span>
                    <span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">,</span>
                    <span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">,</span>
                    <span class="n">initialize</span><span class="o">=</span><span class="n">init_cho</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="c1"># or initialize with the identity matrix</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mod</span><span class="o">.</span><span class="n">L_ele</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Var</span><span class="p">(</span>
                    <span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">,</span>
                    <span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">,</span>
                    <span class="n">initialize</span><span class="o">=</span><span class="n">identity_matrix</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># loop over parameter name</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">):</span>
                    <span class="c1"># fix the 0 half of L matrix to be 0.0</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">mod</span><span class="o">.</span><span class="n">L_ele</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
                    <span class="c1"># Give LB to the diagonal entries</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">L_LB</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">d</span><span class="p">:</span>
                            <span class="n">mod</span><span class="o">.</span><span class="n">L_ele</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">setlb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L_LB</span><span class="p">)</span>

        <span class="c1"># jacobian rule</span>
        <span class="k">def</span> <span class="nf">jacobian_rule</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            p: parameter</span>
<span class="sd">            n: response</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">cuid</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">ComponentUID</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">var_up</span> <span class="o">=</span> <span class="n">cuid</span><span class="o">.</span><span class="n">find_component_on</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">scenario_num</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">var_lo</span> <span class="o">=</span> <span class="n">cuid</span><span class="o">.</span><span class="n">find_component_on</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">scenario_num</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_nominal_param_value</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">sensitivity_jacobian</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span>
                    <span class="o">==</span> <span class="p">(</span><span class="n">var_up</span> <span class="o">-</span> <span class="n">var_lo</span><span class="p">)</span>
                    <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_abs</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_constant_value</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">sensitivity_jacobian</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span>
                    <span class="o">==</span> <span class="p">(</span><span class="n">var_up</span> <span class="o">-</span> <span class="n">var_lo</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_abs</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_constant_value</span>
                <span class="p">)</span>

        <span class="c1"># A constraint to calculate elements in Hessian matrix</span>
        <span class="c1"># transfer prior FIM to be Expressions</span>
        <span class="n">fim_initial_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bu</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">un</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">):</span>
                <span class="n">fim_initial_dict</span><span class="p">[(</span><span class="n">bu</span><span class="p">,</span> <span class="n">un</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior_FIM</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">read_prior</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">fim_initial_dict</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span>

        <span class="n">mod</span><span class="o">.</span><span class="n">priorFIM</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Expression</span><span class="p">(</span>
            <span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">,</span> <span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">,</span> <span class="n">rule</span><span class="o">=</span><span class="n">read_prior</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">fim_rule</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            p: parameter</span>
<span class="sd">            q: parameter</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">m</span><span class="o">.</span><span class="n">fim</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>
                <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span>
                    <span class="mi">1</span>
                    <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_vars</span><span class="o">.</span><span class="n">variance</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                    <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">sensitivity_jacobian</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span>
                    <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">sensitivity_jacobian</span><span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mod</span><span class="o">.</span><span class="n">measured_variables</span>
                <span class="p">)</span>
                <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">priorFIM</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fim_scale_constant_value</span>
            <span class="p">)</span>

        <span class="n">mod</span><span class="o">.</span><span class="n">jacobian_constraint</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span>
            <span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">,</span> <span class="n">mod</span><span class="o">.</span><span class="n">measured_variables</span><span class="p">,</span> <span class="n">rule</span><span class="o">=</span><span class="n">jacobian_rule</span>
        <span class="p">)</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">fim_constraint</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span>
            <span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">,</span> <span class="n">mod</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">,</span> <span class="n">rule</span><span class="o">=</span><span class="n">fim_rule</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">mod</span>

    <span class="k">def</span> <span class="nf">_add_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">cholesky_imp</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculate Cholesky L matrix using algebraic constraints</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># If it is the left bottom half of L</span>
            <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">fim</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">L_ele</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="n">k</span><span class="p">]]</span>
                    <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">L_ele</span><span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="n">k</span><span class="p">]]</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This is the empty half of L above the diagonal</span>
                <span class="k">return</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Constraint</span><span class="o">.</span><span class="n">Skip</span>

        <span class="k">def</span> <span class="nf">trace_calc</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculate FIM elements. Can scale each element with 1000 for performance</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">trace</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">fim</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">det_general</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Calculate determinant. Can be applied to FIM of any size.</span>
<span class="sd">            det(A) = sum_{\sigma \in \S_n} (sgn(\sigma) * \Prod_{i=1}^n a_{i,\sigma_i})</span>
<span class="sd">            Use permutation() to get permutations, sgn() to get signature</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">r_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">)))</span>
            <span class="c1"># get all permutations</span>
            <span class="n">object_p</span> <span class="o">=</span> <span class="n">permutations</span><span class="p">(</span><span class="n">r_list</span><span class="p">)</span>
            <span class="n">list_p</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">object_p</span><span class="p">)</span>

            <span class="c1"># generate a name_order to iterate \sigma_i</span>
            <span class="n">det_perm</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_p</span><span class="p">)):</span>
                <span class="n">name_order</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">x_order</span> <span class="o">=</span> <span class="n">list_p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="c1"># sigma_i is the value in the i-th position after the reordering \sigma</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_order</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">x_order</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
                            <span class="n">name_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

            <span class="c1"># det(A) = sum_{\sigma \in \S_n} (sgn(\sigma) * \Prod_{i=1}^n a_{i,\sigma_i})</span>
            <span class="n">det_perm</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sgn</span><span class="p">(</span><span class="n">list_p</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
                <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">fim</span><span class="p">[</span><span class="n">each</span><span class="p">,</span> <span class="n">name_order</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
                    <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">each</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_p</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">det</span> <span class="o">==</span> <span class="n">det_perm</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cholesky_option</span><span class="p">:</span>
            <span class="n">m</span><span class="o">.</span><span class="n">cholesky_cons</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span>
                <span class="n">m</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">,</span> <span class="n">rule</span><span class="o">=</span><span class="n">cholesky_imp</span>
            <span class="p">)</span>
            <span class="n">m</span><span class="o">.</span><span class="n">Obj</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Objective</span><span class="p">(</span>
                <span class="n">expr</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pyo</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">L_ele</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">regression_parameters</span><span class="p">),</span>
                <span class="n">sense</span><span class="o">=</span><span class="n">pyo</span><span class="o">.</span><span class="n">maximize</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># if not cholesky but determinant, calculating det and evaluate the OBJ with det</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective_option</span> <span class="o">==</span> <span class="n">ObjectiveLib</span><span class="o">.</span><span class="n">det</span><span class="p">:</span>
            <span class="n">m</span><span class="o">.</span><span class="n">det_rule</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="n">rule</span><span class="o">=</span><span class="n">det_general</span><span class="p">)</span>
            <span class="n">m</span><span class="o">.</span><span class="n">Obj</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Objective</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">pyo</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">det</span><span class="p">),</span> <span class="n">sense</span><span class="o">=</span><span class="n">pyo</span><span class="o">.</span><span class="n">maximize</span><span class="p">)</span>
        <span class="c1"># if not determinant or cholesky, calculating the OBJ with trace</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective_option</span> <span class="o">==</span> <span class="n">ObjectiveLib</span><span class="o">.</span><span class="n">trace</span><span class="p">:</span>
            <span class="n">m</span><span class="o">.</span><span class="n">trace_rule</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="n">rule</span><span class="o">=</span><span class="n">trace_calc</span><span class="p">)</span>
            <span class="n">m</span><span class="o">.</span><span class="n">Obj</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Objective</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">pyo</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">trace</span><span class="p">),</span> <span class="n">sense</span><span class="o">=</span><span class="n">pyo</span><span class="o">.</span><span class="n">maximize</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective_option</span> <span class="o">==</span> <span class="n">ObjectiveLib</span><span class="o">.</span><span class="n">zero</span><span class="p">:</span>
            <span class="n">m</span><span class="o">.</span><span class="n">Obj</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">Objective</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">m</span>

    <span class="k">def</span> <span class="nf">_fix_design</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">design_val</span><span class="p">,</span> <span class="n">fix_opt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optimize_option</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fix design variable</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m: model</span>
<span class="sd">        design_val: design variable values dict</span>
<span class="sd">        fix_opt: if True, fix. Else, unfix</span>
<span class="sd">        optimize: a dictionary, keys are design variable name, values are True or False, deciding if this design variable is optimized as DOF this time</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        m: model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">design_name</span><span class="p">:</span>
            <span class="n">cuid</span> <span class="o">=</span> <span class="n">pyo</span><span class="o">.</span><span class="n">ComponentUID</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">cuid</span><span class="o">.</span><span class="n">find_component_on</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fix_opt</span><span class="p">:</span>
                <span class="n">var</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="n">design_val</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">optimize_option</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">var</span><span class="o">.</span><span class="n">unfix</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">optimize_option</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span>
                        <span class="n">var</span><span class="o">.</span><span class="n">unfix</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">m</span>

    <span class="k">def</span> <span class="nf">_get_default_ipopt_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Default solver&quot;&quot;&quot;</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="n">SolverFactory</span><span class="p">(</span><span class="s1">&#39;ipopt&#39;</span><span class="p">)</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;linear_solver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;ma57&#39;</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;halt_on_ampl_error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;yes&#39;</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;max_iter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3000</span>
        <span class="k">return</span> <span class="n">solver</span>

    <span class="k">def</span> <span class="nf">_solve_doe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">fix</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">opt_option</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solve DOE model.</span>
<span class="sd">        If it&#39;s a square problem, fix design variable and solve.</span>
<span class="sd">        Else, fix design variable and solve square problem firstly, then unfix them and solve the optimization problem</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m:model</span>
<span class="sd">        fix: if true, solve two times (square first). Else, just solve the square problem</span>
<span class="sd">        opt_option: a dictionary, keys are design variable name, values are True or False,</span>
<span class="sd">            deciding if this design variable is optimized as DOF this time.</span>
<span class="sd">            If None, all design variables are optimized as DOF this time.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        solver_results: solver results</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">### Solve square problem</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fix_design</span><span class="p">(</span>
            <span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">design_values</span><span class="p">,</span> <span class="n">fix_opt</span><span class="o">=</span><span class="n">fix</span><span class="p">,</span> <span class="n">optimize_option</span><span class="o">=</span><span class="n">opt_option</span>
        <span class="p">)</span>

        <span class="c1"># if user gives solver, use this solver. if not, use default IPOPT solver</span>
        <span class="n">solver_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">tee</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tee_opt</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">solver_result</span>

    <span class="k">def</span> <span class="nf">_sgn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a helper function for stochastic_program function to compute the determinant formula.</span>
<span class="sd">        Give the signature of a permutation</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        p: the permutation (a list)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        1 if the number of exchange is an even number</span>
<span class="sd">        -1 if the number is an odd number</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">trans</span> <span class="o">=</span> <span class="n">trans</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">trans</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2008-2023, Sandia National Laboratories.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>