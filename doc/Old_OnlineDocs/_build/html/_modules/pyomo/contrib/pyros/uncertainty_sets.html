

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>pyomo.contrib.pyros.uncertainty_sets &mdash; Pyomo 6.5.1.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/theme_overrides.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/clipboard.min.js"></script>
        <script src="../../../../_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> Pyomo
          

          
          </a>

          
            
            
              <div class="version">
                6.5.1.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../citing_pyomo.html">Citing Pyomo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pyomo_overview/index.html">Pyomo Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pyomo_modeling_components/index.html">Pyomo Modeling Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../solving_pyomo_models.html">Solving Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_models.html">Working with Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_abstractmodels/index.html">Working with Abstract Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_transformations/index.html">Model Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modeling_extensions/index.html">Modeling Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial_examples.html">Pyomo Tutorial Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_debugging/index.html">Debugging Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../advanced_topics/index.html">Advanced Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../errors.html">Common Warnings/Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_reference/index.html">Developer Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../library_reference/index.html">Library Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contribution_guide.html">Contributing to Pyomo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributed_packages/index.html">Third-Party Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../related_packages.html">Related Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Pyomo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>pyomo.contrib.pyros.uncertainty_sets</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyomo.contrib.pyros.uncertainty_sets</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Abstract and pre-defined classes for representing uncertainty sets (or</span>
<span class="sd">uncertain parameter spaces) of two-stage nonlinear robust optimization</span>
<span class="sd">models.</span>

<span class="sd">Along with a ``ConcreteModel`` object representing a deterministic model</span>
<span class="sd">formulation, an uncertainty set object may be passed to the PyROS solver</span>
<span class="sd">to obtain a solution to the model&#39;s two-stage robust optimization</span>
<span class="sd">counterpart.</span>

<span class="sd">Classes</span>
<span class="sd">-------</span>
<span class="sd">``UncertaintySet``</span>
<span class="sd">    Abstract base class for a generic uncertainty set. All other set</span>
<span class="sd">    types defined in this module are subclasses.  A user may implement</span>
<span class="sd">    their own uncertainty set type as a custom-written subclass.</span>

<span class="sd">``EllipsoidalSet``</span>
<span class="sd">    A hyperellipsoid.</span>

<span class="sd">``AxisAlignedEllipsoidalSet``</span>
<span class="sd">    An axis-aligned hyperellipsoid.</span>

<span class="sd">``PolyhedralSet``</span>
<span class="sd">    A bounded convex polyhedron/polytope.</span>

<span class="sd">``BoxSet``</span>
<span class="sd">    A hyperrectangle.</span>

<span class="sd">``BudgetSet``</span>
<span class="sd">    A budget set.</span>

<span class="sd">``CardinalitySet``</span>
<span class="sd">    A cardinality set (or gamma set).</span>

<span class="sd">``DiscreteScenarioSet``</span>
<span class="sd">    A discrete set of finitely many points.</span>

<span class="sd">``FactorModelSet``</span>
<span class="sd">    A factor model set (or net-alpha model set).</span>

<span class="sd">``IntersectionSet``</span>
<span class="sd">    An intersection of two or more sets, each represented by an</span>
<span class="sd">    ``UncertaintySet`` object.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">MutableSequence</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>

<span class="kn">from</span> <span class="nn">pyomo.common.dependencies</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span><span class="p">,</span> <span class="n">scipy</span> <span class="k">as</span> <span class="n">sp</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base</span> <span class="kn">import</span> <span class="n">ConcreteModel</span><span class="p">,</span> <span class="n">Objective</span><span class="p">,</span> <span class="n">maximize</span><span class="p">,</span> <span class="n">minimize</span><span class="p">,</span> <span class="n">Block</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.constraint</span> <span class="kn">import</span> <span class="n">ConstraintList</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.var</span> <span class="kn">import</span> <span class="n">Var</span><span class="p">,</span> <span class="n">IndexedVar</span>
<span class="kn">from</span> <span class="nn">pyomo.core.expr.numvalue</span> <span class="kn">import</span> <span class="n">value</span><span class="p">,</span> <span class="n">native_numeric_types</span>
<span class="kn">from</span> <span class="nn">pyomo.opt.results</span> <span class="kn">import</span> <span class="n">check_optimal_termination</span>
<span class="kn">from</span> <span class="nn">pyomo.contrib.pyros.util</span> <span class="kn">import</span> <span class="n">add_bounds_for_uncertain_parameters</span>


<span class="n">valid_num_types</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">native_numeric_types</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">validate_arg_type</span><span class="p">(</span>
    <span class="n">arg_name</span><span class="p">,</span>
    <span class="n">arg_val</span><span class="p">,</span>
    <span class="n">valid_types</span><span class="p">,</span>
    <span class="n">valid_type_desc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">is_entry_of_arg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">check_numeric_type_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform type validation of an argument to a function/method.</span>
<span class="sd">    If type is not valid, raise a TypeError with an appropriate</span>
<span class="sd">    message.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arg_name : str</span>
<span class="sd">        Name of argument to be displayed in exception message.</span>
<span class="sd">    arg_val : object</span>
<span class="sd">        Value of argument to be checked.</span>
<span class="sd">    valid_types : type or tuple of types</span>
<span class="sd">        Valid types for the argument value.</span>
<span class="sd">    valid_type_desc : str or None, optional</span>
<span class="sd">        Description of valid types for the argument value;</span>
<span class="sd">        this description is included in the exception message.</span>
<span class="sd">    is_entry_of_arg : bool, optional</span>
<span class="sd">        Is the argument value passed an entry of the argument</span>
<span class="sd">        described by `arg_name` (such as entry of an array or list).</span>
<span class="sd">        This will be indicated in the exception message.</span>
<span class="sd">        The default is `False`.</span>
<span class="sd">    check_numeric_type_finite : bool, optional</span>
<span class="sd">        If the valid types comprise a sequence of numeric types,</span>
<span class="sd">        check that the argument value is finite (and also not NaN),</span>
<span class="sd">        as well. The default is `True`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the argument value is not a valid type.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the finiteness check on a numerical value returns</span>
<span class="sd">        a negative result.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg_val</span><span class="p">,</span> <span class="n">valid_types</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">valid_type_desc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">type_phrase</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;not </span><span class="si">{</span><span class="n">valid_type_desc</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">valid_types</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">valid_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">valid_types</span><span class="p">]</span>
            <span class="n">valid_type_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">valid_types</span><span class="p">)</span>
            <span class="n">type_phrase</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;not of any of the valid types (</span><span class="si">{</span><span class="n">valid_type_str</span><span class="si">}</span><span class="s2">)&quot;</span>

        <span class="k">if</span> <span class="n">is_entry_of_arg</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Entry &#39;</span><span class="si">{</span><span class="n">arg_val</span><span class="si">}</span><span class="s2">&#39; of the argument `</span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">` &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;is </span><span class="si">{</span><span class="n">type_phrase</span><span class="si">}</span><span class="s2"> (provided type &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">arg_val</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;)&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Argument `</span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">` is </span><span class="si">{</span><span class="n">type_phrase</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(provided type &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">arg_val</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;)&quot;</span>
            <span class="p">)</span>

    <span class="c1"># check for finiteness, if desired</span>
    <span class="k">if</span> <span class="n">check_numeric_type_finite</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">valid_types</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="n">numeric_types_required</span> <span class="o">=</span> <span class="n">valid_types</span> <span class="ow">in</span> <span class="n">valid_num_types</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numeric_types_required</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">valid_types</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">valid_num_types</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numeric_types_required</span> <span class="ow">and</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">arg_val</span><span class="p">)</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">arg_val</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">is_entry_of_arg</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Entry &#39;</span><span class="si">{</span><span class="n">arg_val</span><span class="si">}</span><span class="s2">&#39; of the argument `</span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">` &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;is not a finite numeric value&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Argument `</span><span class="si">{</span><span class="n">arg_name</span><span class="si">}</span><span class="s2">` is not a finite numeric value &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(provided value &#39;</span><span class="si">{</span><span class="n">arg_val</span><span class="si">}</span><span class="s2">&#39;)&quot;</span>
                <span class="p">)</span>


<span class="k">def</span> <span class="nf">is_ragged</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr_types</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine whether an array-like (such as a list or Numpy ndarray)</span>
<span class="sd">    is ragged.</span>

<span class="sd">    NOTE: if Numpy ndarrays are considered to be arr types,</span>
<span class="sd">    then zero-dimensional arrays are not considered to be as such.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">if</span> <span class="n">arr_types</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">arr_types</span>

    <span class="n">is_zero_dim_arr</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr_types</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_zero_dim_arr</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">entries_are_seqs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="ow">in</span> <span class="n">arr_types</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># account for 0-D arrays (treat as non-arrays)</span>
            <span class="n">entries_are_seqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">entries_are_seqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">arr_types</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">entries_are_seqs</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">entries_are_seqs</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="n">entries_ragged</span> <span class="o">=</span> <span class="p">[</span><span class="n">is_ragged</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">entries_ragged</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">validate_dimensions</span><span class="p">(</span><span class="n">arr_name</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">display_value</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate dimension of an array-like object.</span>
<span class="sd">    Raise Exception if validation fails.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_ragged</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Argument `</span><span class="si">{</span><span class="n">arr_name</span><span class="si">}</span><span class="s2">` should not be a ragged array-like &quot;</span>
            <span class="s2">&quot;(nested sequence of lists, tuples, arrays of different shape)&quot;</span>
        <span class="p">)</span>

    <span class="c1"># check dimensions matched</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
        <span class="n">val_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; from provided value </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">display_value</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Argument `</span><span class="si">{</span><span class="n">arr_name</span><span class="si">}</span><span class="s2">` must be a &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">-dimensional array-like &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;(detected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s2"> dimensions</span><span class="si">{</span><span class="n">val_str</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Last dimension of argument `</span><span class="si">{</span><span class="n">arr_name</span><span class="si">}</span><span class="s2">` must be non-empty &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;(detected shape </span><span class="si">{</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">validate_array</span><span class="p">(</span>
    <span class="n">arr</span><span class="p">,</span> <span class="n">arr_name</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">valid_types</span><span class="p">,</span> <span class="n">valid_type_desc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">required_shape</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate shape and entry types of an array-like object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        Object to validate.</span>
<span class="sd">    arr_name : str</span>
<span class="sd">        A name/descriptor of the object to validate.</span>
<span class="sd">        Usually, this is the name of an object attribute</span>
<span class="sd">        to which the array is meant to be set.</span>
<span class="sd">    dim : int</span>
<span class="sd">        Required dimension of the array-like object.</span>
<span class="sd">    valid_types : set[type]</span>
<span class="sd">        Allowable type(s) for each entry of the array.</span>
<span class="sd">    valid_type_desc : str or None, optional</span>
<span class="sd">        Descriptor for the allowable types.</span>
<span class="sd">    required_shape : list or None, optional</span>
<span class="sd">        Specification of the length of the array in each dimension.</span>
<span class="sd">        If `None` is provided, no specifications are imposed.</span>
<span class="sd">        If a `list` is provided, then each entry of the list must be</span>
<span class="sd">        an `int` specifying the required length in the dimension</span>
<span class="sd">        corresponding to the position of the entry</span>
<span class="sd">        or `None` (meaning no requirement for the length in the</span>
<span class="sd">        corresponding dimension).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">np_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">validate_dimensions</span><span class="p">(</span><span class="n">arr_name</span><span class="p">,</span> <span class="n">np_arr</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">display_value</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">generate_shape_str</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">required_shape</span><span class="p">):</span>
        <span class="n">shape_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">required_shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">sval</span><span class="p">,</span> <span class="n">rsval</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">required_shape</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">rsval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">shape_str</span> <span class="o">+=</span> <span class="s2">&quot;...&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shape_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sval</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">shape_str</span> <span class="o">+=</span> <span class="s2">&quot;,&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="n">shape_str</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>

    <span class="c1"># validate shape requirements</span>
    <span class="k">if</span> <span class="n">required_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">required_shape</span><span class="p">)</span> <span class="o">==</span> <span class="n">dim</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">required_shape</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">size</span> <span class="o">!=</span> <span class="n">np_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                <span class="n">req_shape_str</span> <span class="o">=</span> <span class="n">generate_shape_str</span><span class="p">(</span><span class="n">required_shape</span><span class="p">,</span> <span class="n">required_shape</span><span class="p">)</span>
                <span class="n">actual_shape_str</span> <span class="o">=</span> <span class="n">generate_shape_str</span><span class="p">(</span><span class="n">np_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">required_shape</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Attribute &#39;</span><span class="si">{</span><span class="n">arr_name</span><span class="si">}</span><span class="s2">&#39; should be of shape &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">req_shape_str</span><span class="si">}</span><span class="s2">, but detected shape &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">actual_shape_str</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">np_arr</span><span class="o">.</span><span class="n">flat</span><span class="p">:</span>
        <span class="n">validate_arg_type</span><span class="p">(</span>
            <span class="n">arr_name</span><span class="p">,</span>
            <span class="n">val</span><span class="p">,</span>
            <span class="n">valid_types</span><span class="p">,</span>
            <span class="n">valid_type_desc</span><span class="o">=</span><span class="n">valid_type_desc</span><span class="p">,</span>
            <span class="n">is_entry_of_arg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">uncertainty_sets</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">UncertaintySet</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Expected an UncertaintySet object, instead received </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">obj</span><span class="p">,)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span>


<span class="k">def</span> <span class="nf">column</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="c1"># Get column i of a given multi-dimensional list</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">matrix</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">Geometry</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Geometry classifications for PyROS uncertainty set objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">LINEAR</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">CONVEX_NONLINEAR</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">GENERAL_NONLINEAR</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">DISCRETE_SCENARIOS</span> <span class="o">=</span> <span class="mi">4</span>


<div class="viewcode-block" id="UncertaintySet"><a class="viewcode-back" href="../../../../contributed_packages/pyros.html#pyomo.contrib.pyros.uncertainty_sets.UncertaintySet">[docs]</a><span class="k">class</span> <span class="nc">UncertaintySet</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An object representing an uncertainty set to be passed to the</span>
<span class="sd">    PyROS solver.</span>

<span class="sd">    An `UncertaintySet` object should be viewed as merely a container</span>
<span class="sd">    for data needed to parameterize the set it represents,</span>
<span class="sd">    such that the object&#39;s attributes do not reference the</span>
<span class="sd">    components of a Pyomo modeling object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dimension of the uncertainty set (number of uncertain</span>
<span class="sd">        parameters in a corresponding optimization model of interest).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Geometry of the uncertainty set. See the `Geometry` class</span>
<span class="sd">        documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">parameter_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bounds for the value of each uncertain parameter constrained</span>
<span class="sd">        by the set (i.e. bounds for each set dimension).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">bounding_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make uncertain parameter value bounding problems (optimize</span>
<span class="sd">        value of each uncertain parameter subject to constraints on the</span>
<span class="sd">        uncertain parameters).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        config : None or ConfigDict, optional</span>
<span class="sd">            If a ConfigDict is provided, then it contains</span>
<span class="sd">            arguments passed to the PyROS solver.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        model : ConcreteModel</span>
<span class="sd">            Bounding problem, with all Objectives deactivated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">ConcreteModel</span><span class="p">()</span>
        <span class="n">model</span><span class="o">.</span><span class="n">util</span> <span class="o">=</span> <span class="n">Block</span><span class="p">()</span>

        <span class="c1"># construct param vars, initialize to nominal point</span>
        <span class="n">model</span><span class="o">.</span><span class="n">param_vars</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>

        <span class="c1"># add constraints</span>
        <span class="n">model</span><span class="o">.</span><span class="n">cons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_as_constraint</span><span class="p">(</span>
            <span class="n">uncertain_params</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">param_vars</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span>
        <span class="p">)</span>

        <span class="nd">@model</span><span class="o">.</span><span class="n">Objective</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">def</span> <span class="nf">param_var_objectives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">model</span><span class="o">.</span><span class="n">param_vars</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># deactivate all objectives</span>
        <span class="n">model</span><span class="o">.</span><span class="n">param_var_objectives</span><span class="o">.</span><span class="n">deactivate</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">model</span>

    <span class="k">def</span> <span class="nf">is_bounded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether the uncertainty set is bounded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        config : ConfigDict</span>
<span class="sd">            PyROS solver configuration.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : bool</span>
<span class="sd">            True if the uncertainty set is certified to be bounded,</span>
<span class="sd">            and False otherwise.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This check is carried out by solving a sequence of maximization</span>
<span class="sd">        and minimization problems (in which the objective for each</span>
<span class="sd">        problem is the value of a single uncertain parameter). If any of</span>
<span class="sd">        the optimization models cannot be solved successfully to</span>
<span class="sd">        optimality, then False is returned.</span>

<span class="sd">        This method is invoked during the validation step of a PyROS</span>
<span class="sd">        solver call.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounding_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_model</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">global_solver</span>

        <span class="c1"># initialize uncertain parameter variables</span>
        <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">param_var</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">config</span><span class="o">.</span><span class="n">uncertain_params</span><span class="p">,</span> <span class="n">bounding_model</span><span class="o">.</span><span class="n">param_vars</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="n">param_var</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">skip_validation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">bounding_model</span><span class="o">.</span><span class="n">param_var_objectives</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># activate objective for corresponding dimension</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">activate</span><span class="p">()</span>

            <span class="c1"># solve for lower bound, then upper bound</span>
            <span class="k">for</span> <span class="n">sense</span> <span class="ow">in</span> <span class="p">(</span><span class="n">minimize</span><span class="p">,</span> <span class="n">maximize</span><span class="p">):</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">sense</span> <span class="o">=</span> <span class="n">sense</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">bounding_model</span><span class="p">,</span> <span class="n">load_solutions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tee</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">check_optimal_termination</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># ensure sense is minimize when done, deactivate</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">sense</span> <span class="o">=</span> <span class="n">minimize</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">deactivate</span><span class="p">()</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">is_nonempty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the uncertainty set is nonempty, else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bounded</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the uncertainty set is bounded and non-empty,</span>
<span class="sd">        else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_nonempty</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bounded</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">set_as_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a (sequence of) mathematical constraint(s)</span>
<span class="sd">        (represented by Pyomo `Constraint` objects) on the uncertain</span>
<span class="sd">        parameters to represent the uncertainty set for use in a</span>
<span class="sd">        two-stage robust optimization problem or subproblem (such as a</span>
<span class="sd">        PyROS separation subproblem).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Keyword arguments containing, at the very least, a sequence</span>
<span class="sd">            of `Param` or `Var` objects representing the uncertain</span>
<span class="sd">            parameters of interest, and any additional information</span>
<span class="sd">            needed to generate the constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="UncertaintySet.point_in_set"><a class="viewcode-back" href="../../../../contributed_packages/pyros.html#pyomo.contrib.pyros.uncertainty_sets.UncertaintySet.point_in_set">[docs]</a>    <span class="k">def</span> <span class="nf">point_in_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether a given point lies in the uncertainty set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point : (N,) array-like</span>
<span class="sd">            Point (parameter value) of interest.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_in_set : bool</span>
<span class="sd">            True if the point lies in the uncertainty set,</span>
<span class="sd">            False otherwise.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is invoked at the outset of a PyROS solver call to</span>
<span class="sd">        determine whether a user-specified nominal parameter realization</span>
<span class="sd">        lies in the uncertainty set.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># === Ensure point is of correct dimensionality as the uncertain parameters</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;Point must have same dimensions as uncertain parameters.&quot;</span>
            <span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">ConcreteModel</span><span class="p">()</span>
        <span class="n">the_params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">m</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="s2">&quot;x_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">Var</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="n">point</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">the_params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s2">&quot;x_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">))</span>

        <span class="c1"># === Generate constraint for set</span>
        <span class="n">set_constraint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_as_constraint</span><span class="p">(</span><span class="n">uncertain_params</span><span class="o">=</span><span class="n">the_params</span><span class="p">)</span>

        <span class="c1"># === value() returns True if the constraint is satisfied, False else.</span>
        <span class="n">is_in_set</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">value</span><span class="p">(</span><span class="n">con</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="k">for</span> <span class="n">con</span> <span class="ow">in</span> <span class="n">set_constraint</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">is_in_set</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">add_bounds_on_uncertain_parameters</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Specify the numerical bounds for the uncertain parameters</span>
<span class="sd">        restricted by the set. Each uncertain parameter is represented</span>
<span class="sd">        by a Pyomo `Var` object in a model passed to this method,</span>
<span class="sd">        and the numerical bounds are specified by setting the</span>
<span class="sd">        `.lb()` and `.ub()` attributes of the `Var` object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Keyword arguments consisting of a Pyomo `ConfigDict` and a</span>
<span class="sd">            Pyomo `ConcreteModel` object, representing a PyROS solver</span>
<span class="sd">            configuration and the optimization model of interest.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is invoked in advance of a PyROS separation</span>
<span class="sd">        subproblem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;model&#39;</span><span class="p">)</span>
        <span class="n">_set</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">uncertainty_set</span>
        <span class="n">parameter_bounds</span> <span class="o">=</span> <span class="n">_set</span><span class="o">.</span><span class="n">parameter_bounds</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">uncertain_param_vars</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">p</span><span class="o">.</span><span class="n">setlb</span><span class="p">(</span><span class="n">parameter_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">p</span><span class="o">.</span><span class="n">setub</span><span class="p">(</span><span class="n">parameter_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span></div>


<span class="k">class</span> <span class="nc">UncertaintySetList</span><span class="p">(</span><span class="n">MutableSequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper around a list of uncertainty sets, all of which have</span>
<span class="sd">    an immutable common dimension.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    uncertainty_sets : iterable, optional</span>
<span class="sd">        Sequence of uncertainty sets.</span>
<span class="sd">    name : str or None, optional</span>
<span class="sd">        Name of the uncertainty set list.</span>
<span class="sd">    min_length : int or None, optional</span>
<span class="sd">        Minimum required length of the sequence. If `None` is</span>
<span class="sd">        provided, then the minimum required length is set to 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uncertainty_sets</span><span class="o">=</span><span class="p">[],</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize self (see class docstring).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_length</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">min_length</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">min_length</span>

        <span class="c1"># check minimum length requirement satisfied</span>
        <span class="n">initlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">uncertainty_sets</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">initlist</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Attempting to initialize uncertainty set list &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;of minimum required length </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_min_length</span><span class="si">}</span><span class="s2"> with an &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;iterable of length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">initlist</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># validate first entry of initial list.</span>
        <span class="c1"># The common dimension is set to that of the first entry</span>
        <span class="c1"># if validation is successful</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">initlist</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">initlist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># now initialize the list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">initlist</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Length of the list contained in self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_list</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return repr(self).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_list</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return self[idx].&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set self[idx] = value.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_is_valid</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="c1"># perform validation and length check only if</span>
            <span class="c1"># index is valid, so that exceptions due to</span>
            <span class="c1"># index referencing (wrong type, out of range)</span>
            <span class="c1"># are raised in update attempt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_length_update</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform del self[idx].&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_is_valid</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_length_update</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all items from the list.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_length_update</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_list</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert an object before index denoted by idx.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="c1"># index should be valid. Validate value before</span>
            <span class="c1"># inserting</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">single_item</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_list</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_index_is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">allow_int_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Object to be used as list index is within range of</span>
<span class="sd">        list contained within self.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        idx : object</span>
<span class="sd">            List index. Usually an integer type or slice.</span>
<span class="sd">        allow_int_only : bool, optional</span>
<span class="sd">            Being an integral type is a necessary condition</span>
<span class="sd">            for validity. The default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : bool</span>
<span class="sd">            True if index is valid, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="n">slice_valid</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slice_valid</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># if only integer types allowed, then must be an integer type</span>
        <span class="n">int_req_satisfied</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">allow_int_only</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">slice_valid</span> <span class="ow">and</span> <span class="n">int_req_satisfied</span>

    <span class="k">def</span> <span class="nf">_check_length_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether the update ``self[idx] = value`` reduces the</span>
<span class="sd">        length of self to a value smaller than the minimum length.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If minimum length requirement is violated by the update.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">slice_len</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slice_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_list</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>

        <span class="n">val_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">new_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="n">val_len</span> <span class="o">-</span> <span class="n">slice_len</span>
        <span class="k">if</span> <span class="n">new_len</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Length of uncertainty set list </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">!r}</span><span class="s2"> must &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;be at least </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_min_length</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">single_item</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate item or sequence of items to be inserted into self.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : object</span>
<span class="sd">            Object to validate.</span>
<span class="sd">        single_item : bool, optional</span>
<span class="sd">            Do not allow validation of iterables of objects</span>
<span class="sd">            (e.g. a list of ``UncertaintySet`` objects).</span>
<span class="sd">            The default is `False`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If object passed is not of the appropriate type</span>
<span class="sd">            (``UncertaintySet``, or an iterable thereof).</span>
<span class="sd">        ValueError</span>
<span class="sd">            If object passed is (or contains) an ``UncertaintySet``</span>
<span class="sd">            whose dimension does not match that of other uncertainty</span>
<span class="sd">            sets in self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">single_item</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">single_item</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">validate_arg_type</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span>
                <span class="n">value</span><span class="p">,</span>
                <span class="n">UncertaintySet</span><span class="p">,</span>
                <span class="s2">&quot;An `UncertaintySet` object&quot;</span><span class="p">,</span>
                <span class="n">is_entry_of_arg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># common dimension is now set</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">dim</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># ensure set added matches common dimension</span>
                <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Uncertainty set list with name </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">!r}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;contains UncertaintySet objects of dimension &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim</span><span class="si">}</span><span class="s2">, but attempting to add set of dimension &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dimension of all uncertainty sets contained in self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span>


<div class="viewcode-block" id="BoxSet"><a class="viewcode-back" href="../../../../contributed_packages/pyros.html#pyomo.contrib.pyros.uncertainty_sets.BoxSet">[docs]</a><span class="k">class</span> <span class="nc">BoxSet</span><span class="p">(</span><span class="n">UncertaintySet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A hyper-rectangle (a.k.a. &quot;box&quot;).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bounds : (N, 2) array_like</span>
<span class="sd">        Lower and upper bounds for each dimension of the set.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    1D box set (interval):</span>

<span class="sd">    &gt;&gt;&gt; from pyomo.contrib.pyros import BoxSet</span>
<span class="sd">    &gt;&gt;&gt; interval = BoxSet(bounds=[(1, 2)])</span>
<span class="sd">    &gt;&gt;&gt; interval.bounds</span>
<span class="sd">    array([[1, 2]])</span>

<span class="sd">    2D box set:</span>

<span class="sd">    &gt;&gt;&gt; box_set = BoxSet(bounds=[[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; box_set.bounds</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4]])</span>

<span class="sd">    5D hypercube with bounds 0 and 1 in each dimension:</span>

<span class="sd">    &gt;&gt;&gt; hypercube_5d = BoxSet(bounds=[[0, 1] for idx in range(5)])</span>
<span class="sd">    &gt;&gt;&gt; hypercube_5d.bounds</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [0, 1],</span>
<span class="sd">           [0, 1],</span>
<span class="sd">           [0, 1],</span>
<span class="sd">           [0, 1]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize self (see class docstring).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        str : Brief description of the type of the uncertainty set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;box&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (N, 2) numpy.ndarray : Lower and upper bounds for each dimension</span>
<span class="sd">        of the set.</span>

<span class="sd">        The bounds of a `BoxSet` instance can be changed, such that</span>
<span class="sd">        the dimension of the set remains unchanged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span>

    <span class="nd">@bounds</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">validate_array</span><span class="p">(</span>
            <span class="n">arr</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
            <span class="n">arr_name</span><span class="o">=</span><span class="s2">&quot;bounds&quot;</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">valid_types</span><span class="o">=</span><span class="n">valid_num_types</span><span class="p">,</span>
            <span class="n">valid_type_desc</span><span class="o">=</span><span class="s2">&quot;a valid numeric type&quot;</span><span class="p">,</span>
            <span class="n">required_shape</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">bounds_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="ow">in</span> <span class="n">bounds_arr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lb</span> <span class="o">&gt;</span> <span class="n">ub</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Lower bound </span><span class="si">{</span><span class="n">lb</span><span class="si">}</span><span class="s2"> exceeds upper bound </span><span class="si">{</span><span class="n">ub</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># box set dimension is immutable</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_bounds&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">bounds_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Attempting to set bounds of a box set of dimension &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2"> to a value of dimension </span><span class="si">{</span><span class="n">bounds_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        int : Dimension `N` of the box set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Geometry of the box set.</span>
<span class="sd">        See the `Geometry` class documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">LINEAR</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameter_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bounds in each dimension of the box set.</span>
<span class="sd">        This is numerically equivalent to the `bounds` attribute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : list of tuples</span>
<span class="sd">            List, length `N`, of 2-tuples. Each tuple</span>
<span class="sd">            specifies the bounds in its corresponding</span>
<span class="sd">            dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">bound</span><span class="p">)</span> <span class="k">for</span> <span class="n">bound</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set_as_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uncertain_params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a list of box constraints on a given sequence</span>
<span class="sd">        of uncertain parameter objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uncertain_params : list of Param or list of Var</span>
<span class="sd">            Uncertain parameter objects upon which the constraints</span>
<span class="sd">            are imposed.</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Additional arguments. These arguments are currently</span>
<span class="sd">            ignored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        conlist : ConstraintList</span>
<span class="sd">            The constraints on the uncertain parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conlist</span> <span class="o">=</span> <span class="n">ConstraintList</span><span class="p">()</span>
        <span class="n">conlist</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>

        <span class="n">set_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">set_i</span><span class="p">:</span>
            <span class="n">conlist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">conlist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">conlist</span></div>


<div class="viewcode-block" id="CardinalitySet"><a class="viewcode-back" href="../../../../contributed_packages/pyros.html#pyomo.contrib.pyros.uncertainty_sets.CardinalitySet">[docs]</a><span class="k">class</span> <span class="nc">CardinalitySet</span><span class="p">(</span><span class="n">UncertaintySet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A cardinality-constrained (a.k.a. &quot;gamma&quot;) set.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    origin : (N,) array_like</span>
<span class="sd">        Origin of the set (e.g., nominal uncertain parameter values).</span>
<span class="sd">    positive_deviation : (N,) array_like</span>
<span class="sd">        Maximal non-negative coordinate deviation from the origin</span>
<span class="sd">        in each dimension.</span>
<span class="sd">    gamma : numeric type</span>
<span class="sd">        Upper bound for the number of uncertain parameters which</span>
<span class="sd">        may realize their maximal deviations from the origin</span>
<span class="sd">        simultaneously.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    A 3D cardinality set:</span>

<span class="sd">    &gt;&gt;&gt; from pyomo.contrib.pyros import CardinalitySet</span>
<span class="sd">    &gt;&gt;&gt; gamma_set = CardinalitySet(</span>
<span class="sd">    ...     origin=[0, 0, 0],</span>
<span class="sd">    ...     positive_deviation=[1.0, 2.0, 1.5],</span>
<span class="sd">    ...     gamma=1,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; gamma_set.origin</span>
<span class="sd">    array([0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; gamma_set.positive_deviation</span>
<span class="sd">    array([1. , 2. , 1.5])</span>
<span class="sd">    &gt;&gt;&gt; gamma_set.gamma</span>
<span class="sd">    1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">positive_deviation</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize self (see class docstring).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">positive_deviation</span> <span class="o">=</span> <span class="n">positive_deviation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        str : Brief description of the type of the uncertainty set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;cardinality&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (N,) numpy.ndarray : Origin of the cardinality set</span>
<span class="sd">        (e.g. nominal parameter values).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span>

    <span class="nd">@origin</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">validate_array</span><span class="p">(</span>
            <span class="n">arr</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
            <span class="n">arr_name</span><span class="o">=</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">valid_types</span><span class="o">=</span><span class="n">valid_num_types</span><span class="p">,</span>
            <span class="n">valid_type_desc</span><span class="o">=</span><span class="s2">&quot;a valid numeric type&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># dimension of the set is immutable</span>
        <span class="n">val_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_origin&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">val_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Attempting to set attribute &#39;origin&#39; of cardinality &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;set of dimension </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;to value of dimension </span><span class="si">{</span><span class="n">val_arr</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span> <span class="o">=</span> <span class="n">val_arr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">positive_deviation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (N,) numpy.ndarray : Maximal coordinate deviations from the</span>
<span class="sd">        origin in each dimension. All entries are nonnegative.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positive_deviation</span>

    <span class="nd">@positive_deviation</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">positive_deviation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">validate_array</span><span class="p">(</span>
            <span class="n">arr</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
            <span class="n">arr_name</span><span class="o">=</span><span class="s2">&quot;positive_deviation&quot;</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">valid_types</span><span class="o">=</span><span class="n">valid_num_types</span><span class="p">,</span>
            <span class="n">valid_type_desc</span><span class="o">=</span><span class="s2">&quot;a valid numeric type&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">dev_val</span> <span class="ow">in</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dev_val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Entry </span><span class="si">{</span><span class="n">dev_val</span><span class="si">}</span><span class="s2"> of attribute &#39;positive_deviation&#39; &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;is negative value&quot;</span>
                <span class="p">)</span>

        <span class="n">val_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># dimension of the set is immutable</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_origin&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">val_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Attempting to set attribute &#39;positive_deviation&#39; of &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;cardinality set of dimension </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;to value of dimension </span><span class="si">{</span><span class="n">val_arr</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_positive_deviation</span> <span class="o">=</span> <span class="n">val_arr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        numeric type : Upper bound for the number of uncertain</span>
<span class="sd">        parameters which may maximally deviate from their respective</span>
<span class="sd">        origin values simultaneously. Must be a numerical value ranging</span>
<span class="sd">        from 0 to the set dimension `N`.</span>

<span class="sd">        Note that, mathematically, setting `gamma` to 0 reduces the set</span>
<span class="sd">        to a singleton containing the center, while setting `gamma` to</span>
<span class="sd">        the set dimension `N` makes the set mathematically equivalent</span>
<span class="sd">        to a `BoxSet` with bounds</span>
<span class="sd">        ``numpy.array([origin, origin + positive_deviation]).T``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gamma</span>

    <span class="nd">@gamma</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">validate_arg_type</span><span class="p">(</span><span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">valid_num_types</span><span class="p">,</span> <span class="s2">&quot;a valid numeric type&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cardinality set attribute &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;gamma&#39; must be a real number between 0 and dimension &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(provided value </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_gamma</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        int : Dimension `N` of the cardinality set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Geometry of the cardinality set.</span>
<span class="sd">        See the `Geometry` class documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">LINEAR</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameter_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bounds in each dimension of the cardinality set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : list of tuples</span>
<span class="sd">            List, length `N`, of 2-tuples. Each tuple</span>
<span class="sd">            specifies the bounds in its corresponding</span>
<span class="sd">            dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nom_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span>
        <span class="n">deviation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">positive_deviation</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span>
        <span class="n">parameter_bounds</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">nom_val</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nom_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">deviation</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nom_val</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">parameter_bounds</span>

    <span class="k">def</span> <span class="nf">set_as_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uncertain_params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a list of cardinality set constraints on</span>
<span class="sd">        a sequence of uncertain parameter objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uncertain_params : list of Param or list of Var</span>
<span class="sd">            Uncertain parameter objects upon which the constraints</span>
<span class="sd">            are imposed.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional arguments. This dictionary should consist</span>
<span class="sd">            of a `model` entry, which maps to a `ConcreteModel`</span>
<span class="sd">            object representing the model of interest (parent model</span>
<span class="sd">            of the uncertain parameter objects).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        conlist : ConstraintList</span>
<span class="sd">            The constraints on the uncertain parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># === Ensure dimensions</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;Dimensions of origin and uncertain_param lists must be equal.&quot;</span>
            <span class="p">)</span>

        <span class="n">model</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;model&#39;</span><span class="p">]</span>
        <span class="n">set_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">)))</span>
        <span class="n">model</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">cassi</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">set_i</span><span class="p">,</span> <span class="n">initialize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Make n equality constraints</span>
        <span class="n">conlist</span> <span class="o">=</span> <span class="n">ConstraintList</span><span class="p">()</span>
        <span class="n">conlist</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">set_i</span><span class="p">:</span>
            <span class="n">conlist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">positive_deviation</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">model</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">cassi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="o">==</span> <span class="n">uncertain_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="n">conlist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">cassi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">set_i</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">conlist</span>

<div class="viewcode-block" id="CardinalitySet.point_in_set"><a class="viewcode-back" href="../../../../contributed_packages/pyros.html#pyomo.contrib.pyros.uncertainty_sets.CardinalitySet.point_in_set">[docs]</a>    <span class="k">def</span> <span class="nf">point_in_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether a given point lies in the cardinality set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point : (N,) array-like</span>
<span class="sd">            Point (parameter value) of interest.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : bool</span>
<span class="sd">            True if the point lies in the set, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cassis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">positive_deviation</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cassis</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">positive_deviation</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cassi</span> <span class="k">for</span> <span class="n">cassi</span> <span class="ow">in</span> <span class="n">cassis</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">cassi</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">cassi</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">cassi</span> <span class="ow">in</span> <span class="n">cassis</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div></div>


<div class="viewcode-block" id="PolyhedralSet"><a class="viewcode-back" href="../../../../contributed_packages/pyros.html#pyomo.contrib.pyros.uncertainty_sets.PolyhedralSet">[docs]</a><span class="k">class</span> <span class="nc">PolyhedralSet</span><span class="p">(</span><span class="n">UncertaintySet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A bounded convex polyhedron or polytope.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs_coefficients_mat : (M, N) array_like</span>
<span class="sd">        Left-hand side coefficients for the linear</span>
<span class="sd">        inequality constraints defining the polyhedral set.</span>
<span class="sd">    rhs_vec : (M,) array_like</span>
<span class="sd">        Right-hand side values for the linear inequality</span>
<span class="sd">        constraints defining the polyhedral set.</span>
<span class="sd">        Each entry is an upper bound for the quantity</span>
<span class="sd">        ``lhs_coefficients_mat @ x``, where `x` is an (N,)</span>
<span class="sd">        array representing any point in the polyhedral set.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    2D polyhedral set with 4 defining inequalities:</span>

<span class="sd">    &gt;&gt;&gt; from pyomo.contrib.pyros import PolyhedralSet</span>
<span class="sd">    &gt;&gt;&gt; pset = PolyhedralSet(</span>
<span class="sd">    ...     lhs_coefficients_mat=[[-1, 0], [0, -1], [-1, 1], [1, 0]],</span>
<span class="sd">    ...     rhs_vec=[0, 0, 0, 1],</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; pset.coefficients_mat</span>
<span class="sd">    array([[-1,  0],</span>
<span class="sd">           [ 0, -1],</span>
<span class="sd">           [-1,  1],</span>
<span class="sd">           [ 1,  0]])</span>
<span class="sd">    &gt;&gt;&gt; pset.rhs_vec</span>
<span class="sd">    array([0, 0, 0, 1])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lhs_coefficients_mat</span><span class="p">,</span> <span class="n">rhs_vec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize self (see class docstring).&quot;&quot;&quot;</span>
        <span class="c1"># set attributes to copies of the originals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coefficients_mat</span> <span class="o">=</span> <span class="n">lhs_coefficients_mat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rhs_vec</span> <span class="o">=</span> <span class="n">rhs_vec</span>

        <span class="c1"># validate nonemptiness and boundedness here.</span>
        <span class="c1"># This check is only performed at construction.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check polyhedral set attributes are such that set is nonempty</span>
<span class="sd">        (solve a feasibility problem).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If set is empty, or the check was not</span>
<span class="sd">            successfully completed due to numerical issues.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># solve LP</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">linprog</span><span class="p">(</span>
            <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">A_ub</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients_mat</span><span class="p">,</span>
            <span class="n">b_ub</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rhs_vec</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;simplex&quot;</span><span class="p">,</span>
            <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># check termination</span>
        <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">res</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Could not verify nonemptiness of the &quot;</span>
                <span class="s2">&quot;polyhedral set (`scipy.optimize.linprog(method=simplex)` &quot;</span>
                <span class="sa">f</span><span class="s2">&quot; status </span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">status</span><span class="si">}</span><span class="s2">) &quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">res</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;PolyhedralSet defined by &#39;coefficients_mat&#39; and &quot;</span>
                <span class="s2">&quot;&#39;rhs_vec&#39; is empty. Check arguments&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        str : Brief description of the type of the uncertainty set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;polyhedral&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coefficients_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (M, N) numpy.ndarray : Coefficient matrix for the (linear)</span>
<span class="sd">        inequality constraints defining the polyhedral set.</span>

<span class="sd">        In tandem with the `rhs_vec` attribute, this matrix should</span>
<span class="sd">        be such that the polyhedral set is nonempty and bounded.</span>
<span class="sd">        Such a check is performed only at instance construction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coefficients_mat</span>

    <span class="nd">@coefficients_mat</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">coefficients_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">validate_array</span><span class="p">(</span>
            <span class="n">arr</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
            <span class="n">arr_name</span><span class="o">=</span><span class="s2">&quot;coefficients_mat&quot;</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">valid_types</span><span class="o">=</span><span class="n">valid_num_types</span><span class="p">,</span>
            <span class="n">valid_type_desc</span><span class="o">=</span><span class="s2">&quot;a valid numeric type&quot;</span><span class="p">,</span>
            <span class="n">required_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">lhs_coeffs_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># check no change in set dimension</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_coefficients_mat&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lhs_coeffs_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Polyhedral set attribute &#39;coefficients_mat&#39; must have &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2"> columns to match set dimension &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(provided matrix with </span><span class="si">{</span><span class="n">lhs_coeffs_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> columns)&quot;</span>
                <span class="p">)</span>

        <span class="c1"># check shape match with rhs vector</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_rhs_vec&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lhs_coeffs_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhs_vec</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;PolyhedralSet attribute &#39;coefficients_mat&#39; &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;must have </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rhs_vec</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2"> rows &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;to match shape of attribute &#39;rhs_vec&#39; &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(provided </span><span class="si">{</span><span class="n">lhs_coeffs_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> rows)&quot;</span>
                <span class="p">)</span>

        <span class="c1"># check no column is all zeros. otherwise, set is unbounded</span>
        <span class="n">cols_with_all_zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">col</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">lhs_coeffs_arr</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cols_with_all_zeros</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">col_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">cols_with_all_zeros</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Attempting to set attribute &#39;coefficients_mat&#39; to value &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;with all entries zero in columns at indexes: </span><span class="si">{</span><span class="n">col_str</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;Ensure column has at least one nonzero entry&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_coefficients_mat</span> <span class="o">=</span> <span class="n">lhs_coeffs_arr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rhs_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (M,) numpy.ndarray : Right-hand side values (upper bounds) for</span>
<span class="sd">        the (linear) inequality constraints defining the polyhedral set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs_vec</span>

    <span class="nd">@rhs_vec</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">rhs_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">validate_array</span><span class="p">(</span>
            <span class="n">arr</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
            <span class="n">arr_name</span><span class="o">=</span><span class="s2">&quot;rhs_vec&quot;</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">valid_types</span><span class="o">=</span><span class="n">valid_num_types</span><span class="p">,</span>
            <span class="n">valid_type_desc</span><span class="o">=</span><span class="s2">&quot;a valid numeric type&quot;</span><span class="p">,</span>
            <span class="n">required_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">rhs_vec_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># ensure shape of coefficients matrix</span>
        <span class="c1"># and rhs vec match</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_coefficients_mat&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;PolyhedralSet attribute &#39;rhs_vec&#39; &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;must have </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> entries &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;to match shape of attribute &#39;coefficients_mat&#39; &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(provided </span><span class="si">{</span><span class="n">rhs_vec_arr</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2"> entries)&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_rhs_vec</span> <span class="o">=</span> <span class="n">rhs_vec_arr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        int : Dimension `N` of the polyhedral set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Geometry of the polyhedral set.</span>
<span class="sd">        See the `Geometry` class documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">LINEAR</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameter_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bounds in each dimension of the polyhedral set.</span>

<span class="sd">        Currently, an empty `list` is returned, as the bounds cannot, in</span>
<span class="sd">        general, be computed without access to an optimization solver.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">set_as_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uncertain_params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a list of polyhedral constraints on a given sequence</span>
<span class="sd">        of uncertain parameter objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uncertain_params : list of Param or list of Var</span>
<span class="sd">            Uncertain parameter objects upon which the constraints</span>
<span class="sd">            are imposed.</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Additional arguments. These arguments are currently</span>
<span class="sd">            ignored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        conlist : ConstraintList</span>
<span class="sd">            The constraints on the uncertain parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># === Ensure valid dimensions of lhs and rhs w.r.t uncertain_params</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients_mat</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;Columns of coefficients_mat matrix &quot;</span>
                <span class="s2">&quot;must equal length of uncertain parameters list.&quot;</span>
            <span class="p">)</span>

        <span class="n">set_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients_mat</span><span class="p">)))</span>

        <span class="n">conlist</span> <span class="o">=</span> <span class="n">ConstraintList</span><span class="p">()</span>
        <span class="n">conlist</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">set_i</span><span class="p">:</span>
            <span class="n">constraint</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">)):</span>
                <span class="n">constraint</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients_mat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="n">uncertain_params</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">conlist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">constraint</span> <span class="o">&lt;=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rhs_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">conlist</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">add_bounds_on_uncertain_parameters</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Specify the numerical bounds for each of a sequence of uncertain</span>
<span class="sd">        parameters, represented by Pyomo `Var` objects, in a modeling</span>
<span class="sd">        object. The numerical bounds are specified through the `.lb()`</span>
<span class="sd">        and `.ub()` attributes of the `Var` objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : ConcreteModel</span>
<span class="sd">            Model of interest (parent model of the uncertain parameter</span>
<span class="sd">            objects for which to specify bounds).</span>
<span class="sd">        config : ConfigDict</span>
<span class="sd">            PyROS solver config.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is invoked in advance of a PyROS separation</span>
<span class="sd">        subproblem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">add_bounds_for_uncertain_parameters</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)</span></div>


<div class="viewcode-block" id="BudgetSet"><a class="viewcode-back" href="../../../../contributed_packages/pyros.html#pyomo.contrib.pyros.uncertainty_sets.BudgetSet">[docs]</a><span class="k">class</span> <span class="nc">BudgetSet</span><span class="p">(</span><span class="n">UncertaintySet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A budget set.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    budget_membership_mat : (L, N) array_like</span>
<span class="sd">        Incidence matrix of the budget constraints.</span>
<span class="sd">        Each row corresponds to a single budget constraint,</span>
<span class="sd">        and defines which uncertain parameters</span>
<span class="sd">        (which dimensions) participate in that row&#39;s constraint.</span>
<span class="sd">    rhs_vec : (L,) array_like</span>
<span class="sd">        Budget limits (upper bounds) with respect to</span>
<span class="sd">        the origin of the set.</span>
<span class="sd">    origin : (N,) array_like or None, optional</span>
<span class="sd">        Origin of the budget set. If `None` is provided, then</span>
<span class="sd">        the origin is set to the zero vector.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    3D budget set with one budget constraint and</span>
<span class="sd">    no origin chosen (hence origin defaults to 3D zero vector):</span>

<span class="sd">    &gt;&gt;&gt; from pyomo.contrib.pyros import BudgetSet</span>
<span class="sd">    &gt;&gt;&gt; budget_set = BudgetSet(</span>
<span class="sd">    ...     budget_membership_mat=[[1, 1, 1]],</span>
<span class="sd">    ...     rhs_vec=[2],</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; budget_set.budget_membership_mat</span>
<span class="sd">    array([[1, 1, 1]])</span>
<span class="sd">    &gt;&gt;&gt; budget_set.budget_rhs_vec</span>
<span class="sd">    array([2])</span>
<span class="sd">    &gt;&gt;&gt; budget_set.origin</span>
<span class="sd">    array([0., 0., 0.])</span>

<span class="sd">    3D budget set with two budget constraints and custom origin:</span>

<span class="sd">    &gt;&gt;&gt; budget_custom = BudgetSet(</span>
<span class="sd">    ...     budget_membership_mat=[[1, 0, 1], [0, 1, 0]],</span>
<span class="sd">    ...     rhs_vec=[1, 1],</span>
<span class="sd">    ...     origin=[2, 2, 2],</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; budget_custom.budget_membership_mat</span>
<span class="sd">    array([[1, 0, 1],</span>
<span class="sd">           [0, 1, 0]])</span>
<span class="sd">    &gt;&gt;&gt; budget_custom.budget_rhs_vec</span>
<span class="sd">    array([1, 1])</span>
<span class="sd">    &gt;&gt;&gt; budget_custom.origin</span>
<span class="sd">    array([2, 2, 2])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">budget_membership_mat</span><span class="p">,</span> <span class="n">rhs_vec</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize self (see class docstring).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">budget_membership_mat</span> <span class="o">=</span> <span class="n">budget_membership_mat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">budget_rhs_vec</span> <span class="o">=</span> <span class="n">rhs_vec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span> <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">origin</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        str : Brief description of the type of the uncertainty set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;budget&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coefficients_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (L + N, N) numpy.ndarray : Coefficient matrix of all polyhedral</span>
<span class="sd">        constraints defining the budget set. Composed from the incidence</span>
<span class="sd">        matrix used for defining the budget constraints and a</span>
<span class="sd">        coefficient matrix for individual uncertain parameter</span>
<span class="sd">        nonnegativity constraints.</span>

<span class="sd">        This attribute cannot be set. The budget constraint</span>
<span class="sd">        incidence matrix may be altered through the</span>
<span class="sd">        `budget_membership_mat` attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">budget_membership_mat</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rhs_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (L + N,) numpy.ndarray : Right-hand side vector for polyhedral</span>
<span class="sd">        constraints defining the budget set. This also includes entries</span>
<span class="sd">        for nonnegativity constraints on the uncertain parameters.</span>

<span class="sd">        This attribute cannot be set, and is automatically determined</span>
<span class="sd">        given other attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">budget_rhs_vec</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">budget_membership_mat</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">budget_membership_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (L, N) numpy.ndarray : Incidence matrix of the budget</span>
<span class="sd">        constraints.  Each row corresponds to a single budget</span>
<span class="sd">        constraint and defines which uncertain parameters</span>
<span class="sd">        participate in that row&#39;s constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_budget_membership_mat</span>

    <span class="nd">@budget_membership_mat</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">budget_membership_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">validate_array</span><span class="p">(</span>
            <span class="n">arr</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
            <span class="n">arr_name</span><span class="o">=</span><span class="s2">&quot;budget_membership_mat&quot;</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">valid_types</span><span class="o">=</span><span class="n">valid_num_types</span><span class="p">,</span>
            <span class="n">valid_type_desc</span><span class="o">=</span><span class="s2">&quot;a valid numeric type&quot;</span><span class="p">,</span>
            <span class="n">required_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">lhs_coeffs_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># check dimension match</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_budget_membership_mat&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lhs_coeffs_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;BudgetSet attribute &#39;budget_membership_mat&#39; &quot;</span>
                    <span class="s2">&quot;must have &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2"> columns to match set dimension &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(provided matrix with </span><span class="si">{</span><span class="n">lhs_coeffs_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> columns)&quot;</span>
                <span class="p">)</span>

        <span class="c1"># check shape match with rhs vector</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_budget_rhs_vec&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lhs_coeffs_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">budget_rhs_vec</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;BudgetSet attribute &#39;budget_membership_mat&#39; &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;must have </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">budget_rhs_vec</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2"> rows &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;to match shape of attribute &#39;budget_rhs_vec&#39; &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(provided </span><span class="si">{</span><span class="n">lhs_coeffs_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> rows)&quot;</span>
                <span class="p">)</span>

        <span class="c1"># ensure all entries are 0-1 values</span>
        <span class="n">uniq_entries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">lhs_coeffs_arr</span><span class="p">)</span>
        <span class="n">non_bool_entries</span> <span class="o">=</span> <span class="n">uniq_entries</span><span class="p">[(</span><span class="n">uniq_entries</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">uniq_entries</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">non_bool_entries</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Attempting to set attribute `budget_membership_mat` to value &quot;</span>
                <span class="s2">&quot;containing entries that are not 0-1 values &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(example: </span><span class="si">{</span><span class="n">non_bool_entries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">). &quot;</span>
                <span class="s2">&quot;Ensure all entries are of value 0 or 1&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check no row is all zeros</span>
        <span class="n">rows_with_zero_sums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">lhs_coeffs_arr</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rows_with_zero_sums</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">row_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">rows_with_zero_sums</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Attempting to set attribute `budget_membership_mat` to value &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;with all entries zero in rows at indexes: </span><span class="si">{</span><span class="n">row_str</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;Ensure each row and column has at least one nonzero entry&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check no column is all zeros</span>
        <span class="n">cols_with_zero_sums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">lhs_coeffs_arr</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cols_with_zero_sums</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">col_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">cols_with_zero_sums</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Attempting to set attribute `budget_membership_mat` to value &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;with all entries zero in columns at indexes: </span><span class="si">{</span><span class="n">col_str</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;Ensure each row and column has at least one nonzero entry&quot;</span>
            <span class="p">)</span>

        <span class="c1"># matrix is valid; update</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_budget_membership_mat</span> <span class="o">=</span> <span class="n">lhs_coeffs_arr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">budget_rhs_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (L,) numpy.ndarray : Budget limits (upper bounds)</span>
<span class="sd">        with respect to the origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_budget_rhs_vec</span>

    <span class="nd">@budget_rhs_vec</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">budget_rhs_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">validate_array</span><span class="p">(</span>
            <span class="n">arr</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
            <span class="n">arr_name</span><span class="o">=</span><span class="s2">&quot;budget_rhs_vec&quot;</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">valid_types</span><span class="o">=</span><span class="n">valid_num_types</span><span class="p">,</span>
            <span class="n">valid_type_desc</span><span class="o">=</span><span class="s2">&quot;a valid numeric type&quot;</span><span class="p">,</span>
            <span class="n">required_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">rhs_vec_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># ensure shape of coefficients matrix</span>
        <span class="c1"># and rhs vec match</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_budget_membership_mat&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">budget_membership_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Budget set attribute &#39;budget_rhs_vec&#39; &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;must have </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">budget_membership_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> entries &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;to match shape of attribute &#39;budget_membership_mat&#39; &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(provided </span><span class="si">{</span><span class="n">rhs_vec_arr</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2"> entries)&quot;</span>
                <span class="p">)</span>

        <span class="c1"># ensure all entries are nonnegative</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">rhs_vec_arr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">entry</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Entry </span><span class="si">{</span><span class="n">entry</span><span class="si">}</span><span class="s2"> of attribute &#39;budget_rhs_vec&#39; is &quot;</span>
                    <span class="s2">&quot;negative. Ensure all entries are nonnegative&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_budget_rhs_vec</span> <span class="o">=</span> <span class="n">rhs_vec_arr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (N,) numpy.ndarray : Origin of the budget set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span>

    <span class="nd">@origin</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">validate_array</span><span class="p">(</span>
            <span class="n">arr</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
            <span class="n">arr_name</span><span class="o">=</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">valid_types</span><span class="o">=</span><span class="n">valid_num_types</span><span class="p">,</span>
            <span class="n">valid_type_desc</span><span class="o">=</span><span class="s2">&quot;a valid numeric type&quot;</span><span class="p">,</span>
            <span class="n">required_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">origin_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># ensure shape of coefficients matrix</span>
        <span class="c1"># and rhs vec match</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Budget set attribute &#39;origin&#39; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;must have </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2"> entries &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;to match set dimension &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(provided </span><span class="si">{</span><span class="n">origin_arr</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2"> entries)&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span> <span class="o">=</span> <span class="n">origin_arr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        int : Dimension `N` of the budget set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">budget_membership_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Geometry of the budget set.</span>
<span class="sd">        See the `Geometry` class documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">LINEAR</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameter_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bounds in each dimension of the budget set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : list of tuples</span>
<span class="sd">            List, length `N`, of 2-tuples. Each tuple</span>
<span class="sd">            specifies the bounds in its corresponding</span>
<span class="sd">            dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">orig_val</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">budget_membership_mat</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="n">orig_val</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="n">orig_val</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">budget_rhs_vec</span><span class="p">[</span><span class="n">col</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">bounds</span>

    <span class="k">def</span> <span class="nf">set_as_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uncertain_params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a list of the constraints defining the budget</span>
<span class="sd">        set on a given sequence of uncertain parameter objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uncertain_params : list of Param or list of Var</span>
<span class="sd">            Uncertain parameter objects upon which the constraints</span>
<span class="sd">            are imposed.</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Additional arguments. These arguments are currently</span>
<span class="sd">            ignored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        conlist : ConstraintList</span>
<span class="sd">            The constraints on the uncertain parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># === Ensure matrix cols == len uncertain params</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Argument &#39;uncertain_params&#39; must contain </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="s2">&quot;Param objects to match BudgetSet dimension&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(provided </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects)&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">PolyhedralSet</span><span class="o">.</span><span class="n">set_as_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uncertain_params</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">add_bounds_on_uncertain_parameters</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Specify the numerical bounds for each of a sequence of uncertain</span>
<span class="sd">        parameters, represented by Pyomo `Var` objects, in a modeling</span>
<span class="sd">        object. The numerical bounds are specified through the `.lb()`</span>
<span class="sd">        and `.ub()` attributes of the `Var` objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : ConcreteModel</span>
<span class="sd">            Model of interest (parent model of the uncertain parameter</span>
<span class="sd">            objects for which to specify bounds).</span>
<span class="sd">        config : ConfigDict</span>
<span class="sd">            PyROS solver config.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is invoked in advance of a PyROS separation</span>
<span class="sd">        subproblem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># In this case, we use the UncertaintySet class method</span>
        <span class="c1"># because we have numerical parameter_bounds</span>
        <span class="n">UncertaintySet</span><span class="o">.</span><span class="n">add_bounds_on_uncertain_parameters</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)</span></div>


<div class="viewcode-block" id="FactorModelSet"><a class="viewcode-back" href="../../../../contributed_packages/pyros.html#pyomo.contrib.pyros.uncertainty_sets.FactorModelSet">[docs]</a><span class="k">class</span> <span class="nc">FactorModelSet</span><span class="p">(</span><span class="n">UncertaintySet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A factor model (a.k.a. &quot;net-alpha&quot; model) set.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    origin : (N,) array_like</span>
<span class="sd">        Uncertain parameter values around which deviations are</span>
<span class="sd">        restrained.</span>
<span class="sd">    number_of_factors : int</span>
<span class="sd">        Natural number representing the dimensionality of the</span>
<span class="sd">        space to which the set projects.</span>
<span class="sd">    psi_mat : (N, F) array_like</span>
<span class="sd">        Matrix designating each uncertain parameter&#39;s contribution to</span>
<span class="sd">        each factor.  Each row is associated with a separate uncertain</span>
<span class="sd">        parameter.  Each column is associated with a separate factor.</span>
<span class="sd">        Number of columns `F` of `psi_mat` should be equal to</span>
<span class="sd">        `number_of_factors`.</span>
<span class="sd">    beta : numeric type</span>
<span class="sd">        Real value between 0 and 1 specifying the fraction of the</span>
<span class="sd">        independent factors that can simultaneously attain</span>
<span class="sd">        their extreme values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    A 4D factor model set with a 2D factor space:</span>

<span class="sd">    &gt;&gt;&gt; from pyomo.contrib.pyros import FactorModelSet</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; fset = FactorModelSet(</span>
<span class="sd">    ...     origin=np.zeros(4),</span>
<span class="sd">    ...     number_of_factors=2,</span>
<span class="sd">    ...     psi_mat=np.full(shape=(4, 2), fill_value=0.1),</span>
<span class="sd">    ...     beta=0.5,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; fset.origin</span>
<span class="sd">    array([0., 0., 0., 0.])</span>
<span class="sd">    &gt;&gt;&gt; fset.number_of_factors</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; fset.psi_mat</span>
<span class="sd">    array([[0.1, 0.1],</span>
<span class="sd">           [0.1, 0.1],</span>
<span class="sd">           [0.1, 0.1],</span>
<span class="sd">           [0.1, 0.1]])</span>
<span class="sd">    &gt;&gt;&gt; fset.beta</span>
<span class="sd">    0.5</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">number_of_factors</span><span class="p">,</span> <span class="n">psi_mat</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize self (see class docstring).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_factors</span> <span class="o">=</span> <span class="n">number_of_factors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi_mat</span> <span class="o">=</span> <span class="n">psi_mat</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        str : Brief description of the type of the uncertainty set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;factor_model&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (N,) numpy.ndarray : Uncertain parameter values around which</span>
<span class="sd">        deviations are restrained.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span>

    <span class="nd">@origin</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">validate_array</span><span class="p">(</span>
            <span class="n">arr</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
            <span class="n">arr_name</span><span class="o">=</span><span class="s2">&quot;origin&quot;</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">valid_types</span><span class="o">=</span><span class="n">valid_num_types</span><span class="p">,</span>
            <span class="n">valid_type_desc</span><span class="o">=</span><span class="s2">&quot;a valid numeric type&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># dimension of the set is immutable</span>
        <span class="n">val_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_origin&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">val_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Attempting to set attribute &#39;origin&#39; of factor model &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;set of dimension </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;to value of dimension </span><span class="si">{</span><span class="n">val_arr</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span> <span class="o">=</span> <span class="n">val_arr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">number_of_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        int : Natural number representing the dimensionality `F`</span>
<span class="sd">        of the space to which the set projects.</span>

<span class="sd">        This attribute is immutable, and may only be set at</span>
<span class="sd">        object construction. Typically, the number of factors</span>
<span class="sd">        is significantly less than the set dimension, but no</span>
<span class="sd">        restriction to that end is imposed here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_factors</span>

    <span class="nd">@number_of_factors</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">number_of_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_number_of_factors&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Attribute &#39;number_of_factors&#39; is immutable&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># validate type and value</span>
            <span class="n">validate_arg_type</span><span class="p">(</span><span class="s2">&quot;number_of_factors&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Attribute &#39;number_of_factors&#39; must be a positive int &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(provided value </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_number_of_factors</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">psi_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (N, F) numpy.ndarray : Matrix designating each</span>
<span class="sd">        uncertain parameter&#39;s contribution to each factor. Each row is</span>
<span class="sd">        associated with a separate uncertain parameter. Each column with</span>
<span class="sd">        a separate factor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psi_mat</span>

    <span class="nd">@psi_mat</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">psi_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">validate_array</span><span class="p">(</span>
            <span class="n">arr</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
            <span class="n">arr_name</span><span class="o">=</span><span class="s2">&quot;psi_mat&quot;</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">valid_types</span><span class="o">=</span><span class="n">valid_num_types</span><span class="p">,</span>
            <span class="n">valid_type_desc</span><span class="o">=</span><span class="s2">&quot;a valid numeric type&quot;</span><span class="p">,</span>
            <span class="n">required_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">psi_mat_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># validate shape (check it matches set dimensions)</span>
        <span class="c1"># origin and number of factors already set</span>
        <span class="k">if</span> <span class="n">psi_mat_arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_factors</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Psi matrix for factor model set &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;should be of shape </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_factors</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;to match the set and factor model space dimensions &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(provided shape </span><span class="si">{</span><span class="n">psi_mat_arr</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check values acceptable</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">psi_mat_arr</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Each column of attribute &#39;psi_mat&#39; should have at least &quot;</span>
                    <span class="s2">&quot;one nonzero entry&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_psi_mat</span> <span class="o">=</span> <span class="n">psi_mat_arr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">beta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        numeric type : Real number ranging from 0 to 1 representing the</span>
<span class="sd">        fraction of the independent factors that can simultaneously</span>
<span class="sd">        attain their extreme values.</span>

<span class="sd">        Note that, mathematically, setting ``beta = 0`` will enforce</span>
<span class="sd">        that as many factors will be above 0 as there will be below 0</span>
<span class="sd">        (i.e., &quot;zero-net-alpha&quot; model). If ``beta = 1``,</span>
<span class="sd">        then the set is numerically equivalent to a `BoxSet` with bounds</span>
<span class="sd">        ``[origin - psi @ np.ones(F), origin + psi @ np.ones(F)].T``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span>

    <span class="nd">@beta</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">beta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Beta parameter must be a real number between 0 &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;and 1 inclusive (provided value </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        int : Dimension `N` of the factor model set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Geometry of the factor model set.</span>
<span class="sd">        See the `Geometry` class documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">LINEAR</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameter_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bounds in each dimension of the factor model set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : list of tuples</span>
<span class="sd">            List, length `N`, of 2-tuples. Each tuple</span>
<span class="sd">            specifies the bounds in its corresponding</span>
<span class="sd">            dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_factors</span>
        <span class="n">psi_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_mat</span>

        <span class="c1"># evaluate some important quantities</span>
        <span class="n">beta_F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_factors</span>
        <span class="n">crit_pt_type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">beta_F</span> <span class="o">+</span> <span class="n">F</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">beta_F_fill_in</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta_F</span> <span class="o">+</span> <span class="n">F</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">crit_pt_type</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># argsort rows of psi_mat in descending order</span>
        <span class="n">row_wise_args</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">psi_mat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">parameter_bounds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">orig_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">):</span>
            <span class="c1"># number nonnegative values in row</span>
            <span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psi_mat</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">psi_mat</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">])</span>

            <span class="c1"># argsort psi matrix row in descending order</span>
            <span class="n">sorted_psi_row_args</span> <span class="o">=</span> <span class="n">row_wise_args</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">sorted_psi_row</span> <span class="o">=</span> <span class="n">psi_mat</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">sorted_psi_row_args</span><span class="p">]</span>

            <span class="c1"># now evaluate max deviation from origin</span>
            <span class="c1"># (depends on number nonneg entries and critical point type)</span>
            <span class="k">if</span> <span class="n">M</span> <span class="o">&gt;</span> <span class="n">crit_pt_type</span><span class="p">:</span>
                <span class="n">max_deviation</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">sorted_psi_row</span><span class="p">[:</span><span class="n">crit_pt_type</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="o">+</span> <span class="n">beta_F_fill_in</span> <span class="o">*</span> <span class="n">sorted_psi_row</span><span class="p">[</span><span class="n">crit_pt_type</span><span class="p">]</span>
                    <span class="o">-</span> <span class="n">sorted_psi_row</span><span class="p">[</span><span class="n">crit_pt_type</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">M</span> <span class="o">&lt;</span> <span class="n">F</span> <span class="o">-</span> <span class="n">crit_pt_type</span><span class="p">:</span>
                <span class="n">max_deviation</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">sorted_psi_row</span><span class="p">[:</span> <span class="n">F</span> <span class="o">-</span> <span class="n">crit_pt_type</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="o">-</span> <span class="n">beta_F_fill_in</span> <span class="o">*</span> <span class="n">sorted_psi_row</span><span class="p">[</span><span class="n">F</span> <span class="o">-</span> <span class="n">crit_pt_type</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="o">-</span> <span class="n">sorted_psi_row</span><span class="p">[</span><span class="n">F</span> <span class="o">-</span> <span class="n">crit_pt_type</span> <span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_deviation</span> <span class="o">=</span> <span class="n">sorted_psi_row</span><span class="p">[:</span><span class="n">M</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">sorted_psi_row</span><span class="p">[</span><span class="n">M</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="c1"># finally, evaluate the bounds for this dimension</span>
            <span class="n">parameter_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span><span class="n">orig_val</span> <span class="o">-</span> <span class="n">max_deviation</span><span class="p">,</span> <span class="n">orig_val</span> <span class="o">+</span> <span class="n">max_deviation</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">parameter_bounds</span>

    <span class="k">def</span> <span class="nf">set_as_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uncertain_params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a list of factor model constraints on a given sequence</span>
<span class="sd">        of uncertain parameter objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uncertain_params : list of Param or list of Var</span>
<span class="sd">            Uncertain parameter objects upon which the constraints</span>
<span class="sd">            are imposed.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional arguments. This dictionary should consist</span>
<span class="sd">            of a `model` entry, which maps to a `ConcreteModel`</span>
<span class="sd">            object representing the model of interest (parent model</span>
<span class="sd">            of the uncertain parameter objects).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        conlist : ConstraintList</span>
<span class="sd">            The constraints on the uncertain parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;model&#39;</span><span class="p">]</span>

        <span class="c1"># === Ensure dimensions</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;Dimensions of origin and uncertain_param lists must be equal.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Make F-dim cassi variable</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_factors</span><span class="p">))</span>
        <span class="n">model</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">cassi</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">initialize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">conlist</span> <span class="o">=</span> <span class="n">ConstraintList</span><span class="p">()</span>
        <span class="n">conlist</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>

        <span class="n">disturbances</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_mat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">model</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">cassi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="c1"># Make n equality constraints</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">)):</span>
            <span class="n">conlist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">disturbances</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">uncertain_params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">conlist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
            <span class="nb">sum</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">cassi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_factors</span>
        <span class="p">)</span>
        <span class="n">conlist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
            <span class="nb">sum</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">cassi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_factors</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">conlist</span>

<div class="viewcode-block" id="FactorModelSet.point_in_set"><a class="viewcode-back" href="../../../../contributed_packages/pyros.html#pyomo.contrib.pyros.uncertainty_sets.FactorModelSet.point_in_set">[docs]</a>    <span class="k">def</span> <span class="nf">point_in_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether a given point lies in the factor model set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point : (N,) array-like</span>
<span class="sd">            Point (parameter value) of interest.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : bool</span>
<span class="sd">            True if the point lies in the set, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inv_psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_mat</span><span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">point</span><span class="p">))))</span>
        <span class="n">cassis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_psi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span>
            <span class="nb">sum</span><span class="p">(</span><span class="n">cassi</span> <span class="k">for</span> <span class="n">cassi</span> <span class="ow">in</span> <span class="n">cassis</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_factors</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">cassi</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">cassi</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">cassi</span> <span class="ow">in</span> <span class="n">cassis</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div></div>


<div class="viewcode-block" id="AxisAlignedEllipsoidalSet"><a class="viewcode-back" href="../../../../contributed_packages/pyros.html#pyomo.contrib.pyros.uncertainty_sets.AxisAlignedEllipsoidalSet">[docs]</a><span class="k">class</span> <span class="nc">AxisAlignedEllipsoidalSet</span><span class="p">(</span><span class="n">UncertaintySet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An axis-aligned ellipsoid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    center : (N,) array_like</span>
<span class="sd">        Center of the ellipsoid.</span>
<span class="sd">    half_lengths : (N,) array_like</span>
<span class="sd">        Semi-axis lengths of the ellipsoid.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    3D origin-centered unit hypersphere:</span>

<span class="sd">    &gt;&gt;&gt; from pyomo.contrib.pyros import AxisAlignedEllipsoidalSet</span>
<span class="sd">    &gt;&gt;&gt; sphere = AxisAlignedEllipsoidalSet(</span>
<span class="sd">    ...     center=[0, 0, 0],</span>
<span class="sd">    ...     half_lengths=[1, 1, 1]</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; sphere.center</span>
<span class="sd">    array([0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; sphere.half_lengths</span>
<span class="sd">    array([1, 1, 1])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">half_lengths</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize self (see class docstring).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">half_lengths</span> <span class="o">=</span> <span class="n">half_lengths</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        str : Brief description of the type of the uncertainty set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;ellipsoidal&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (N,) numpy.ndarray : Center of the ellipsoid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center</span>

    <span class="nd">@center</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">validate_array</span><span class="p">(</span>
            <span class="n">arr</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
            <span class="n">arr_name</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">valid_types</span><span class="o">=</span><span class="n">valid_num_types</span><span class="p">,</span>
            <span class="n">valid_type_desc</span><span class="o">=</span><span class="s2">&quot;a valid numeric type&quot;</span><span class="p">,</span>
            <span class="n">required_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">val_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># dimension of the set is immutable</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_center&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">val_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Attempting to set attribute &#39;center&#39; of &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;AxisAlignedEllipsoidalSet of dimension </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;to value of dimension </span><span class="si">{</span><span class="n">val_arr</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_center</span> <span class="o">=</span> <span class="n">val_arr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">half_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (N,) numpy.ndarray : Semi-axis lengths.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_half_lengths</span>

    <span class="nd">@half_lengths</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">half_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">validate_array</span><span class="p">(</span>
            <span class="n">arr</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
            <span class="n">arr_name</span><span class="o">=</span><span class="s2">&quot;half_lengths&quot;</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">valid_types</span><span class="o">=</span><span class="n">valid_num_types</span><span class="p">,</span>
            <span class="n">valid_type_desc</span><span class="o">=</span><span class="s2">&quot;a valid numeric type&quot;</span><span class="p">,</span>
            <span class="n">required_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">val_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># dimension of the set is immutable</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_center&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">val_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Attempting to set attribute &#39;half_lengths&#39; of &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;AxisAlignedEllipsoidalSet of dimension </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;to value of dimension </span><span class="si">{</span><span class="n">val_arr</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># ensure half-lengths are non-negative</span>
        <span class="k">for</span> <span class="n">half_len</span> <span class="ow">in</span> <span class="n">val_arr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">half_len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Entry </span><span class="si">{</span><span class="n">half_len</span><span class="si">}</span><span class="s2"> of &#39;half_lengths&#39; &quot;</span>
                    <span class="s2">&quot;is negative. All half-lengths must be nonnegative&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_half_lengths</span> <span class="o">=</span> <span class="n">val_arr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        int : Dimension `N` of the axis-aligned ellipsoidal set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Geometry of the axis-aligned ellipsoidal set.</span>
<span class="sd">        See the `Geometry` class documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">CONVEX_NONLINEAR</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameter_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bounds in each dimension of the axis-aligned ellipsoidal set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : list of tuples</span>
<span class="sd">            List, length `N`, of 2-tuples. Each tuple</span>
<span class="sd">            specifies the bounds in its corresponding</span>
<span class="sd">            dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nom_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span>
        <span class="n">half_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">half_lengths</span>
        <span class="n">parameter_bounds</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">nom_value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">half_length</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nom_value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">half_length</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nom_value</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">parameter_bounds</span>

    <span class="k">def</span> <span class="nf">set_as_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uncertain_params</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a list of ellipsoidal constraints on a given sequence</span>
<span class="sd">        of uncertain parameter objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uncertain_params : {IndexedParam, IndexedVar, list of Param/Var}</span>
<span class="sd">            Uncertain parameter objects upon which the constraints</span>
<span class="sd">            are imposed. Indexed parameters are accepted, and</span>
<span class="sd">            are unpacked for constraint generation.</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Additional arguments. These arguments are currently</span>
<span class="sd">            ignored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        conlist : ConstraintList</span>
<span class="sd">            The constraints on the uncertain parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># expand all uncertain parameters to a list.</span>
        <span class="c1"># this accounts for the cases in which `uncertain_params`</span>
        <span class="c1"># consists of indexed model components,</span>
        <span class="c1"># or is itself a single indexed component</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">uncertain_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">uncertain_params</span><span class="p">]</span>

        <span class="n">all_params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">uparam</span> <span class="ow">in</span> <span class="n">uncertain_params</span><span class="p">:</span>
            <span class="n">all_params</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">uparam</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_params</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Center of ellipsoid is of dimension </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">)</span><span class="si">}</span><span class="s2">,&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; but vector of uncertain parameters is of dimension&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_params</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">zip_all</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">all_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">half_lengths</span><span class="p">)</span>
        <span class="n">diffs_squared</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># now construct the constraints</span>
        <span class="n">conlist</span> <span class="o">=</span> <span class="n">ConstraintList</span><span class="p">()</span>
        <span class="n">conlist</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">ctr</span><span class="p">,</span> <span class="n">half_len</span> <span class="ow">in</span> <span class="n">zip_all</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">half_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">diffs_squared</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">param</span> <span class="o">-</span> <span class="n">ctr</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">half_len</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># equality constraints for parameters corresponding to</span>
                <span class="c1"># half-lengths of zero</span>
                <span class="n">conlist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">param</span> <span class="o">==</span> <span class="n">ctr</span><span class="p">)</span>

        <span class="n">conlist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">diffs_squared</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">conlist</span></div>


<div class="viewcode-block" id="EllipsoidalSet"><a class="viewcode-back" href="../../../../contributed_packages/pyros.html#pyomo.contrib.pyros.uncertainty_sets.EllipsoidalSet">[docs]</a><span class="k">class</span> <span class="nc">EllipsoidalSet</span><span class="p">(</span><span class="n">UncertaintySet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A general ellipsoid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    center : (N,) array-like</span>
<span class="sd">        Center of the ellipsoid.</span>
<span class="sd">    shape_matrix : (N, N) array-like</span>
<span class="sd">        A positive definite matrix characterizing the shape</span>
<span class="sd">        and orientation of the ellipsoid.</span>
<span class="sd">    scale : numeric type, optional</span>
<span class="sd">        Square of the factor by which to scale the semi-axes</span>
<span class="sd">        of the ellipsoid (i.e. the eigenvectors of the shape</span>
<span class="sd">        matrix). The default is `1`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    3D origin-centered unit hypersphere:</span>

<span class="sd">    &gt;&gt;&gt; from pyomo.contrib.pyros import EllipsoidalSet</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; hypersphere = EllipsoidalSet(</span>
<span class="sd">    ...     center=[0, 0, 0],</span>
<span class="sd">    ...     shape_matrix=np.eye(3),</span>
<span class="sd">    ...     scale=1,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; hypersphere.center</span>
<span class="sd">    array([0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; hypersphere.shape_matrix</span>
<span class="sd">    array([[1., 0., 0.],</span>
<span class="sd">           [0., 1., 0.],</span>
<span class="sd">           [0., 0., 1.]])</span>
<span class="sd">    &gt;&gt;&gt; hypersphere.scale</span>
<span class="sd">    1</span>

<span class="sd">    A 2D ellipsoid with custom rotation and scaling:</span>

<span class="sd">    &gt;&gt;&gt; rotated_ellipsoid = EllipsoidalSet(</span>
<span class="sd">    ...     center=[1, 1],</span>
<span class="sd">    ...     shape_matrix=[[4, 2], [2, 4]],</span>
<span class="sd">    ...     scale=0.5,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; rotated_ellipsoid.center</span>
<span class="sd">    array([1, 1])</span>
<span class="sd">    &gt;&gt;&gt; rotated_ellipsoid.shape_matrix</span>
<span class="sd">    array([[4, 2],</span>
<span class="sd">           [2, 4]])</span>
<span class="sd">    &gt;&gt;&gt; rotated_ellipsoid.scale</span>
<span class="sd">    0.5</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">shape_matrix</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize self (see class docstring).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape_matrix</span> <span class="o">=</span> <span class="n">shape_matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        str : Brief description of the type of the uncertainty set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;ellipsoidal&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (N,) numpy.ndarray : Center of the ellipsoid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center</span>

    <span class="nd">@center</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">validate_array</span><span class="p">(</span>
            <span class="n">arr</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
            <span class="n">arr_name</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">valid_types</span><span class="o">=</span><span class="n">valid_num_types</span><span class="p">,</span>
            <span class="n">valid_type_desc</span><span class="o">=</span><span class="s2">&quot;a valid numeric type&quot;</span><span class="p">,</span>
            <span class="n">required_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">val_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># dimension of the set is immutable</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_center&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">val_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Attempting to set attribute &#39;center&#39; of &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;AxisAlignedEllipsoidalSet of dimension </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;to value of dimension </span><span class="si">{</span><span class="n">val_arr</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_center</span> <span class="o">=</span> <span class="n">val_arr</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_verify_positive_definite</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that a given symmetric square matrix is positive</span>
<span class="sd">        definite. An exception is raised if the square matrix</span>
<span class="sd">        is not positive definite.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : (N, N) array_like</span>
<span class="sd">            Candidate matrix.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If matrix is not symmetric, not positive definite,</span>
<span class="sd">            or the square roots of the diagonal entries are</span>
<span class="sd">            not accessible.</span>
<span class="sd">        LinAlgError</span>
<span class="sd">            If matrix is not invertible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">matrix</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shape matrix must be symmetric.&quot;</span><span class="p">)</span>

        <span class="c1"># Numpy raises LinAlgError if not invertible</span>
        <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

        <span class="c1"># check positive semi-definite.</span>
        <span class="c1"># since also invertible, means positive definite</span>
        <span class="n">eigvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">eigvals</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Non positive-definite shape matrix &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(detected eigenvalues </span><span class="si">{</span><span class="n">eigvals</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check roots of diagonal entries accessible</span>
        <span class="c1"># (should theoretically be true if positive definite)</span>
        <span class="k">for</span> <span class="n">diag_entry</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">diag_entry</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot evaluate square root of the diagonal entry &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">diag_entry</span><span class="si">}</span><span class="s2"> of argument `shape_matrix`. &quot;</span>
                    <span class="s2">&quot;Check that this entry is nonnegative&quot;</span>
                <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (N, N) numpy.ndarray : A positive definite matrix characterizing</span>
<span class="sd">        the shape and orientation of the ellipsoid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape_matrix</span>

    <span class="nd">@shape_matrix</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">shape_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">validate_array</span><span class="p">(</span>
            <span class="n">arr</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
            <span class="n">arr_name</span><span class="o">=</span><span class="s2">&quot;shape_matrix&quot;</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">valid_types</span><span class="o">=</span><span class="n">valid_num_types</span><span class="p">,</span>
            <span class="n">valid_type_desc</span><span class="o">=</span><span class="s2">&quot;a valid numeric type&quot;</span><span class="p">,</span>
            <span class="n">required_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">shape_mat_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># check matrix shape matches set dimension</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_center&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">shape_mat_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;EllipsoidalSet attribute &#39;shape_matrix&#39; &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;must be a square matrix of size &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2"> to match set dimension &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(provided matrix with shape </span><span class="si">{</span><span class="n">shape_mat_arr</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_verify_positive_definite</span><span class="p">(</span><span class="n">shape_mat_arr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape_matrix</span> <span class="o">=</span> <span class="n">shape_mat_arr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        numeric type : Square of the factor by which to scale the</span>
<span class="sd">        semi-axes of the ellipsoid (i.e. the eigenvectors of the shape</span>
<span class="sd">        matrix).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

    <span class="nd">@scale</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">validate_arg_type</span><span class="p">(</span><span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">valid_num_types</span><span class="p">,</span> <span class="s2">&quot;a valid numeric type&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;EllipsoidalSet attribute &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;scale&#39; must be a non-negative real &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(provided value </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        int : Dimension `N` of the ellipsoidal set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Geometry of the ellipsoidal set.</span>
<span class="sd">        See the `Geometry` class documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">CONVEX_NONLINEAR</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameter_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bounds in each dimension of the ellipsoidal set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : list of tuples</span>
<span class="sd">            List, length `N`, of 2-tuples. Each tuple</span>
<span class="sd">            specifies the bounds in its corresponding</span>
<span class="sd">            dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
        <span class="n">nom_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span>
        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_matrix</span>
        <span class="n">parameter_bounds</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="n">nom_value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
                <span class="n">nom_value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">parameter_bounds</span>

    <span class="k">def</span> <span class="nf">set_as_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uncertain_params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a list of ellipsoidal constraints on a given sequence</span>
<span class="sd">        of uncertain parameter objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uncertain_params : {IndexedParam, IndexedVar, list of Param/Var}</span>
<span class="sd">            Uncertain parameter objects upon which the constraints</span>
<span class="sd">            are imposed. Indexed parameters are accepted, and</span>
<span class="sd">            are unpacked for constraint generation.</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Additional arguments. These arguments are currently</span>
<span class="sd">            ignored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        conlist : ConstraintList</span>
<span class="sd">            The constraints on the uncertain parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inv_covar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape_matrix</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;Center of ellipsoid must be same dimensions as vector of uncertain parameters.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Calculate row vector of differences</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># === Assume VarList uncertain_param_vars</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">uncertain_params</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">is_indexed</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">uncertain_params</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                    <span class="n">diff</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">diff</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>

        <span class="c1"># Calculate inner product of difference vector and covar matrix</span>
        <span class="n">product1</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">sum</span><span class="p">([</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">column</span><span class="p">(</span><span class="n">inv_covar</span><span class="p">,</span> <span class="n">i</span><span class="p">))])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inv_covar</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="n">constraint</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">product1</span><span class="p">,</span> <span class="n">diff</span><span class="p">)])</span>

        <span class="n">conlist</span> <span class="o">=</span> <span class="n">ConstraintList</span><span class="p">()</span>
        <span class="n">conlist</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>
        <span class="n">conlist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">constraint</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">conlist</span></div>


<div class="viewcode-block" id="DiscreteScenarioSet"><a class="viewcode-back" href="../../../../contributed_packages/pyros.html#pyomo.contrib.pyros.uncertainty_sets.DiscreteScenarioSet">[docs]</a><span class="k">class</span> <span class="nc">DiscreteScenarioSet</span><span class="p">(</span><span class="n">UncertaintySet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A discrete set of finitely many uncertain parameter realizations</span>
<span class="sd">    (or scenarios).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    scenarios : (M, N) array_like</span>
<span class="sd">        A sequence of `M` distinct uncertain parameter realizations.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    2D set with three scenarios:</span>

<span class="sd">    &gt;&gt;&gt; from pyomo.contrib.pyros import DiscreteScenarioSet</span>
<span class="sd">    &gt;&gt;&gt; discrete_set = DiscreteScenarioSet(</span>
<span class="sd">    ...     scenarios=[[1, 1], [2, 1], [1, 2]],</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; discrete_set.scenarios</span>
<span class="sd">    [(1, 1), (2, 1), (1, 2)]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenarios</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize self (see class docstring).&quot;&quot;&quot;</span>
        <span class="c1"># Standardize to list of tuples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scenarios</span> <span class="o">=</span> <span class="n">scenarios</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        str : Brief description of the type of the uncertainty set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;discrete&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scenarios</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        list of tuples : Uncertain parameter realizations comprising the</span>
<span class="sd">        set.  Each tuple is an uncertain parameter realization.</span>

<span class="sd">        Note that the `scenarios` attribute may be modified, but</span>
<span class="sd">        only such that the dimension of the set remains unchanged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scenarios</span>

    <span class="nd">@scenarios</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">scenarios</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">validate_array</span><span class="p">(</span>
            <span class="n">arr</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
            <span class="n">arr_name</span><span class="o">=</span><span class="s2">&quot;scenarios&quot;</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">valid_types</span><span class="o">=</span><span class="n">valid_num_types</span><span class="p">,</span>
            <span class="n">valid_type_desc</span><span class="o">=</span><span class="s2">&quot;a valid numeric type&quot;</span><span class="p">,</span>
            <span class="n">required_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">scenario_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_scenarios&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">scenario_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;DiscreteScenarioSet attribute &#39;scenarios&#39; must have &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2"> columns to match set dimension &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(provided array-like with </span><span class="si">{</span><span class="n">scenario_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="s2">&quot;columns)&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_scenarios</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">val</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        int : Dimension `N` of the discrete scenario set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scenarios</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Geometry of the discrete scenario set.</span>
<span class="sd">        See the `Geometry` class documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">DISCRETE_SCENARIOS</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameter_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bounds in each dimension of the discrete scenario set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : list of tuples</span>
<span class="sd">            List, length `N`, of 2-tuples. Each tuple</span>
<span class="sd">            specifies the bounds in its corresponding</span>
<span class="sd">            dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parameter_bounds</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenarios</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenarios</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">parameter_bounds</span>

    <span class="k">def</span> <span class="nf">is_bounded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the uncertainty set is bounded, and False</span>
<span class="sd">        otherwise.</span>

<span class="sd">        By default, the discrete scenario set is bounded,</span>
<span class="sd">        as the entries of all uncertain parameter scenarios</span>
<span class="sd">        are finite.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">set_as_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uncertain_params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a list of constraints on a given sequence</span>
<span class="sd">        of uncertain parameter objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uncertain_params : list of Param or list of Var</span>
<span class="sd">            Uncertain parameter objects upon which the constraints</span>
<span class="sd">            are imposed.</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Additional arguments. These arguments are currently</span>
<span class="sd">            ignored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        conlist : ConstraintList</span>
<span class="sd">            The constraints on the uncertain parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># === Ensure point is of correct dimensionality as the uncertain parameters</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dim</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenarios</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;All scenarios must have same dimensions as uncertain parameters.&quot;</span>
            <span class="p">)</span>

        <span class="n">conlist</span> <span class="o">=</span> <span class="n">ConstraintList</span><span class="p">()</span>
        <span class="n">conlist</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scenarios</span><span class="p">))):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">))):</span>
                <span class="n">conlist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">uncertain_params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenarios</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>

        <span class="n">conlist</span><span class="o">.</span><span class="n">deactivate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">conlist</span>

<div class="viewcode-block" id="DiscreteScenarioSet.point_in_set"><a class="viewcode-back" href="../../../../contributed_packages/pyros.html#pyomo.contrib.pyros.uncertainty_sets.DiscreteScenarioSet.point_in_set">[docs]</a>    <span class="k">def</span> <span class="nf">point_in_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether a given point lies in the discrete</span>
<span class="sd">        scenario set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point : (N,) array-like</span>
<span class="sd">            Point (parameter value) of interest.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : bool</span>
<span class="sd">            True if the point lies in the set, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Round all double precision to a tolerance</span>
        <span class="n">num_decimals</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="n">rounded_scenarios</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">num_decimals</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenarios</span>
        <span class="p">)</span>
        <span class="n">rounded_point</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">num_decimals</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">point</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">rounded_point</span> <span class="o">==</span> <span class="n">rounded_d</span> <span class="k">for</span> <span class="n">rounded_d</span> <span class="ow">in</span> <span class="n">rounded_scenarios</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="IntersectionSet"><a class="viewcode-back" href="../../../../contributed_packages/pyros.html#pyomo.contrib.pyros.uncertainty_sets.IntersectionSet">[docs]</a><span class="k">class</span> <span class="nc">IntersectionSet</span><span class="p">(</span><span class="n">UncertaintySet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An intersection of a sequence of uncertainty sets, each of which</span>
<span class="sd">    is represented by an `UncertaintySet` object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    **unc_sets : dict</span>
<span class="sd">        PyROS `UncertaintySet` objects of which to construct</span>
<span class="sd">        an intersection. At least two uncertainty sets must</span>
<span class="sd">        be provided. All sets must be of the same dimension.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Intersection of origin-centered 2D box (square) and 2D</span>
<span class="sd">    hypersphere (circle):</span>

<span class="sd">    &gt;&gt;&gt; from pyomo.contrib.pyros import (</span>
<span class="sd">    ...     BoxSet, AxisAlignedEllipsoidalSet, IntersectionSet,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; square = BoxSet(bounds=[[-1.5, 1.5], [-1.5, 1.5]])</span>
<span class="sd">    &gt;&gt;&gt; circle = AxisAlignedEllipsoidalSet(</span>
<span class="sd">    ...     center=[0, 0],</span>
<span class="sd">    ...     half_lengths=[2, 2],</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; # to construct intersection, pass sets as keyword arguments</span>
<span class="sd">    &gt;&gt;&gt; intersection = IntersectionSet(set1=square, set2=circle)</span>
<span class="sd">    &gt;&gt;&gt; intersection.all_sets</span>
<span class="sd">    UncertaintySetList([...])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">unc_sets</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize self (see class docstring).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_sets</span> <span class="o">=</span> <span class="n">unc_sets</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        str : Brief description of the type of the uncertainty set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;intersection&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">all_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        UncertaintySetList : List of the uncertainty sets of which to</span>
<span class="sd">        take the intersection. Must be of minimum length 2.</span>

<span class="sd">        This attribute may be set through any iterable of</span>
<span class="sd">        `UncertaintySet` objects, and exhibits similar behavior</span>
<span class="sd">        to a `list`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_sets</span>

    <span class="nd">@all_sets</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">all_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">the_sets</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">the_sets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># type validation, ensure all entries have same dimension</span>
        <span class="n">all_sets</span> <span class="o">=</span> <span class="n">UncertaintySetList</span><span class="p">(</span><span class="n">the_sets</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;all_sets&quot;</span><span class="p">,</span> <span class="n">min_length</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># set dimension is immutable</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_all_sets&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">all_sets</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Attempting to set attribute &#39;all_sets&#39; of an &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;IntersectionSet of dimension </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2"> to a sequence &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;of sets of dimension </span><span class="si">{</span><span class="n">all_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_all_sets</span> <span class="o">=</span> <span class="n">all_sets</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        int : Dimension of the intersection set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Geometry of the intersection set.</span>
<span class="sd">        See the `Geometry` class documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_sets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_sets</span><span class="p">)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameter_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uncertain parameter value bounds for the intersection</span>
<span class="sd">        set.</span>

<span class="sd">        Currently, an empty list, as the bounds cannot, in general,</span>
<span class="sd">        be computed without access to an optimization solver.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span>

<div class="viewcode-block" id="IntersectionSet.point_in_set"><a class="viewcode-back" href="../../../../contributed_packages/pyros.html#pyomo.contrib.pyros.uncertainty_sets.IntersectionSet.point_in_set">[docs]</a>    <span class="k">def</span> <span class="nf">point_in_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether a given point lies in the intersection set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point : (N,) array-like</span>
<span class="sd">            Point (parameter value) of interest.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : bool</span>
<span class="sd">            True if the point lies in the set, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">a_set</span><span class="o">.</span><span class="n">point_in_set</span><span class="p">(</span><span class="n">point</span><span class="o">=</span><span class="n">point</span><span class="p">)</span> <span class="k">for</span> <span class="n">a_set</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_sets</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="nf">is_empty_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uncertain_params</span><span class="p">,</span> <span class="n">nlp_solver</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if intersection is empty.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        uncertain_params : list of Param or list of Var</span>
<span class="sd">            List of uncertain parameter objects.</span>
<span class="sd">        nlp_solver : Pyomo SolverFactory object</span>
<span class="sd">            NLP solver.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_empty_intersection : bool</span>
<span class="sd">            True if the intersection is certified to be empty,</span>
<span class="sd">            and False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># === Non-emptiness check for the set intersection</span>
        <span class="n">is_empty_intersection</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">a_set</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;discrete&quot;</span> <span class="k">for</span> <span class="n">a_set</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_sets</span><span class="p">):</span>
            <span class="n">disc_sets</span> <span class="o">=</span> <span class="p">(</span><span class="n">a_set</span> <span class="k">for</span> <span class="n">a_set</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_sets</span> <span class="k">if</span> <span class="n">a_set</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;discrete&quot;</span><span class="p">)</span>
            <span class="n">disc_set</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">disc_sets</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">scenarios</span><span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># minimum set of scenarios</span>
            <span class="c1"># === Ensure there is at least one scenario from this discrete set which is a member of all other sets</span>
            <span class="k">for</span> <span class="n">scenario</span> <span class="ow">in</span> <span class="n">disc_set</span><span class="o">.</span><span class="n">scenarios</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">a_set</span><span class="o">.</span><span class="n">point_in_set</span><span class="p">(</span><span class="n">point</span><span class="o">=</span><span class="n">scenario</span><span class="p">)</span> <span class="k">for</span> <span class="n">a_set</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_sets</span><span class="p">):</span>
                    <span class="n">is_empty_intersection</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># === Compile constraints and solve NLP</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">ConcreteModel</span><span class="p">()</span>
            <span class="n">m</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">Objective</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># dummy objective required if using baron</span>
            <span class="n">m</span><span class="o">.</span><span class="n">param_vars</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">uncertain_params</span><span class="o">.</span><span class="n">index_set</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">a_set</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_sets</span><span class="p">:</span>
                <span class="n">m</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span>
                    <span class="n">a_set</span><span class="o">.</span><span class="n">type</span> <span class="o">+</span> <span class="s2">&quot;_constraints&quot;</span><span class="p">,</span>
                    <span class="n">a_set</span><span class="o">.</span><span class="n">set_as_constraint</span><span class="p">(</span><span class="n">uncertain_params</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">param_vars</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">nlp_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Solver terminated with an error while checking set intersection non-emptiness.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">check_optimal_termination</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
                <span class="n">is_empty_intersection</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">is_empty_intersection</span>

    <span class="c1"># === Define pairwise intersection function</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">Q1</span><span class="p">,</span> <span class="n">Q2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Obtain the intersection of two uncertainty sets.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Q1, Q2 : UncertaintySet</span>
<span class="sd">            Operand uncertainty sets.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : DiscreteScenarioSet or IntersectionSet</span>
<span class="sd">            Intersection of the sets. A `DiscreteScenarioSet` is</span>
<span class="sd">            returned if both operand sets are `DiscreteScenarioSet`</span>
<span class="sd">            instances; otherwise, an `IntersectionSet` is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="n">ConstraintList</span><span class="p">()</span>
        <span class="n">constraints</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>

        <span class="k">for</span> <span class="nb">set</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Q1</span><span class="p">,</span> <span class="n">Q2</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Q1</span> <span class="k">if</span> <span class="nb">set</span> <span class="ow">is</span> <span class="n">Q2</span> <span class="k">else</span> <span class="n">Q2</span>
            <span class="k">if</span> <span class="nb">set</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;discrete&quot;</span><span class="p">:</span>
                <span class="n">intersected_scenarios</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">set</span><span class="o">.</span><span class="n">scenarios</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">point_in_set</span><span class="p">(</span><span class="n">point</span><span class="o">=</span><span class="n">point</span><span class="p">):</span>
                        <span class="n">intersected_scenarios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">DiscreteScenarioSet</span><span class="p">(</span><span class="n">scenarios</span><span class="o">=</span><span class="n">intersected_scenarios</span><span class="p">)</span>

        <span class="c1"># === This case is if both sets are continuous</span>
        <span class="k">return</span> <span class="n">IntersectionSet</span><span class="p">(</span><span class="n">set1</span><span class="o">=</span><span class="n">Q1</span><span class="p">,</span> <span class="n">set2</span><span class="o">=</span><span class="n">Q2</span><span class="p">)</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">set_as_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uncertain_params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a list of constraints on a given sequence</span>
<span class="sd">        of uncertain parameter objects. In advance of constructing</span>
<span class="sd">        the constraints, a check is performed to determine whether</span>
<span class="sd">        the set is empty.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uncertain_params : list of Param or list of Var</span>
<span class="sd">            Uncertain parameter objects upon which the constraints</span>
<span class="sd">            are imposed.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional arguments. Must contain a `config` entry,</span>
<span class="sd">            which maps to a `ConfigDict` containing an entry</span>
<span class="sd">            entitled `global_solver`. The `global_solver`</span>
<span class="sd">            key maps to an NLP solver, purportedly with global</span>
<span class="sd">            optimization capabilities.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        conlist : ConstraintList</span>
<span class="sd">            The constraints on the uncertain parameters.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AttributeError</span>
<span class="sd">            If the intersection set is found to be empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">nlp_solver</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;config&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">global_solver</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;set_as_constraint for SetIntersection requires access to an NLP solver via&quot;</span>
                <span class="s2">&quot;the PyROS Solver config.&quot;</span>
            <span class="p">)</span>
        <span class="n">is_empty_intersection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty_intersection</span><span class="p">(</span>
            <span class="n">uncertain_params</span><span class="o">=</span><span class="n">uncertain_params</span><span class="p">,</span> <span class="n">nlp_solver</span><span class="o">=</span><span class="n">nlp_solver</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">_intersect</span><span class="p">(</span><span class="n">Q1</span><span class="p">,</span> <span class="n">Q2</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">Q1</span><span class="p">,</span> <span class="n">Q2</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_empty_intersection</span><span class="p">:</span>
            <span class="n">Qint</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">_intersect</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_sets</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">Qint</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;discrete&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Qint</span><span class="o">.</span><span class="n">set_as_constraint</span><span class="p">(</span><span class="n">uncertain_params</span><span class="o">=</span><span class="n">uncertain_params</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">conlist</span> <span class="o">=</span> <span class="n">ConstraintList</span><span class="p">()</span>
                <span class="n">conlist</span><span class="o">.</span><span class="n">construct</span><span class="p">()</span>
                <span class="k">for</span> <span class="nb">set</span> <span class="ow">in</span> <span class="n">Qint</span><span class="o">.</span><span class="n">all_sets</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">con</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span>
                        <span class="nb">set</span><span class="o">.</span><span class="n">set_as_constraint</span><span class="p">(</span>
                            <span class="n">uncertain_params</span><span class="o">=</span><span class="n">uncertain_params</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                    <span class="p">):</span>
                        <span class="n">conlist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">con</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">conlist</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;Set intersection is empty, cannot proceed with PyROS robust optimization.&quot;</span>
            <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">add_bounds_on_uncertain_parameters</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Specify the numerical bounds for each of a sequence of uncertain</span>
<span class="sd">        parameters, represented by Pyomo `Var` objects, in a modeling</span>
<span class="sd">        object. The numerical bounds are specified through the `.lb()`</span>
<span class="sd">        and `.ub()` attributes of the `Var` objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : ConcreteModel</span>
<span class="sd">            Model of interest (parent model of the uncertain parameter</span>
<span class="sd">            objects for which to specify bounds).</span>
<span class="sd">        config : ConfigDict</span>
<span class="sd">            PyROS solver config.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is invoked in advance of a PyROS separation</span>
<span class="sd">        subproblem.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">add_bounds_for_uncertain_parameters</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)</span>
        <span class="k">return</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2008-2023, Sandia National Laboratories.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>