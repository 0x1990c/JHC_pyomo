

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>pyomo.contrib.community_detection.detection &mdash; Pyomo 6.5.1.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/theme_overrides.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/clipboard.min.js"></script>
        <script src="../../../../_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> Pyomo
          

          
          </a>

          
            
            
              <div class="version">
                6.5.1.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../citing_pyomo.html">Citing Pyomo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pyomo_overview/index.html">Pyomo Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pyomo_modeling_components/index.html">Pyomo Modeling Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../solving_pyomo_models.html">Solving Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_models.html">Working with Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_abstractmodels/index.html">Working with Abstract Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_transformations/index.html">Model Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modeling_extensions/index.html">Modeling Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial_examples.html">Pyomo Tutorial Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_debugging/index.html">Debugging Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../advanced_topics/index.html">Advanced Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../errors.html">Common Warnings/Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_reference/index.html">Developer Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../library_reference/index.html">Library Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contribution_guide.html">Contributing to Pyomo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributed_packages/index.html">Third-Party Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../related_packages.html">Related Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../bibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Pyomo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>pyomo.contrib.community_detection.detection</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyomo.contrib.community_detection.detection</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Main module for community detection integration with Pyomo models.</span>

<span class="sd">This module separates model components (variables, constraints, and objectives) into different communities</span>
<span class="sd">distinguished by the degree of connectivity between community members.</span>

<span class="sd">Original implementation developed by Rahul Joglekar in the Grossmann research group.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="kn">import</span> <span class="n">getLogger</span>

<span class="kn">from</span> <span class="nn">pyomo.common.dependencies</span> <span class="kn">import</span> <span class="n">attempt_import</span>
<span class="kn">from</span> <span class="nn">pyomo.core</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ConcreteModel</span><span class="p">,</span>
    <span class="n">ComponentMap</span><span class="p">,</span>
    <span class="n">Block</span><span class="p">,</span>
    <span class="n">Var</span><span class="p">,</span>
    <span class="n">Constraint</span><span class="p">,</span>
    <span class="n">Objective</span><span class="p">,</span>
    <span class="n">ConstraintList</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyomo.core.base.objective</span> <span class="kn">import</span> <span class="n">_GeneralObjectiveData</span>
<span class="kn">from</span> <span class="nn">pyomo.core.expr.current</span> <span class="kn">import</span> <span class="n">identify_variables</span>
<span class="kn">from</span> <span class="nn">pyomo.core.expr.visitor</span> <span class="kn">import</span> <span class="n">replace_expressions</span>
<span class="kn">from</span> <span class="nn">pyomo.contrib.community_detection.community_graph</span> <span class="kn">import</span> <span class="n">generate_model_graph</span>
<span class="kn">from</span> <span class="nn">pyomo.common.dependencies</span> <span class="kn">import</span> <span class="n">networkx</span> <span class="k">as</span> <span class="n">nx</span>
<span class="kn">from</span> <span class="nn">pyomo.common.dependencies.matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>

<span class="kn">import</span> <span class="nn">copy</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;pyomo.contrib.community_detection&#39;</span><span class="p">)</span>

<span class="c1"># Attempt import of louvain community detection package</span>
<span class="n">community_louvain</span><span class="p">,</span> <span class="n">community_louvain_available</span> <span class="o">=</span> <span class="n">attempt_import</span><span class="p">(</span>
    <span class="s1">&#39;community&#39;</span><span class="p">,</span>
    <span class="n">error_message</span><span class="o">=</span><span class="s2">&quot;Could not import the &#39;community&#39; library, available via &#39;python-louvain&#39; on PyPI.&quot;</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="detect_communities"><a class="viewcode-back" href="../../../../contributed_packages/community.html#pyomo.contrib.community_detection.detection.detect_communities">[docs]</a><span class="k">def</span> <span class="nf">detect_communities</span><span class="p">(</span>
    <span class="n">model</span><span class="p">,</span>
    <span class="n">type_of_community_map</span><span class="o">=</span><span class="s1">&#39;constraint&#39;</span><span class="p">,</span>
    <span class="n">with_objective</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">weighted_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">use_only_active_components</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detects communities in a Pyomo optimization model</span>

<span class="sd">    This function takes in a Pyomo optimization model and organizes the variables and constraints into a graph of nodes</span>
<span class="sd">    and edges. Then, by using Louvain community detection on the graph, a dictionary (community_map) is created, which</span>
<span class="sd">    maps (arbitrary) community keys to the detected communities within the model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model: Block</span>
<span class="sd">        a Pyomo model or block to be used for community detection</span>
<span class="sd">    type_of_community_map: str, optional</span>
<span class="sd">        a string that specifies the type of community map to be returned, the default is &#39;constraint&#39;.</span>
<span class="sd">        &#39;constraint&#39; returns a dictionary (community_map) with communities based on constraint nodes,</span>
<span class="sd">        &#39;variable&#39; returns a dictionary (community_map) with communities based on variable nodes,</span>
<span class="sd">        &#39;bipartite&#39; returns a dictionary (community_map) with communities based on a bipartite graph (both constraint</span>
<span class="sd">        and variable nodes)</span>
<span class="sd">    with_objective: bool, optional</span>
<span class="sd">        a Boolean argument that specifies whether or not the objective function is</span>
<span class="sd">        included in the model graph (and thus in &#39;community_map&#39;); the default is True</span>
<span class="sd">    weighted_graph: bool, optional</span>
<span class="sd">        a Boolean argument that specifies whether community_map is created based on a weighted model graph or an</span>
<span class="sd">        unweighted model graph; the default is True (type_of_community_map=&#39;bipartite&#39; creates an unweighted</span>
<span class="sd">        model graph regardless of this parameter)</span>
<span class="sd">    random_seed: int, optional</span>
<span class="sd">        an integer that is used as the random seed for the (heuristic) Louvain community detection</span>
<span class="sd">    use_only_active_components: bool, optional</span>
<span class="sd">        a Boolean argument that specifies whether inactive constraints/objectives are included in the community map</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    CommunityMap object (dict-like object)</span>
<span class="sd">        The CommunityMap object acts as a Python dictionary, mapping integer keys to tuples containing two lists</span>
<span class="sd">        (which contain the components in the given community) - a constraint list and variable list. Furthermore,</span>
<span class="sd">        the CommunityMap object stores relevant information about the given community map (dict), such as the model</span>
<span class="sd">        used to create it, its networkX representation, etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check that all arguments are of the correct type</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">ConcreteModel</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid model: &#39;model=</span><span class="si">%s</span><span class="s2">&#39; - model must be an instance of ConcreteModel&quot;</span>
            <span class="o">%</span> <span class="n">model</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">type_of_community_map</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;bipartite&#39;</span><span class="p">,</span> <span class="s1">&#39;constraint&#39;</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid value for type_of_community_map: &#39;type_of_community_map=</span><span class="si">%s</span><span class="s2">&#39; - &quot;</span>
            <span class="s2">&quot;Valid values: &#39;bipartite&#39;, &#39;constraint&#39;, &#39;variable&#39;&quot;</span>
            <span class="o">%</span> <span class="n">type_of_community_map</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">with_objective</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid value for with_objective: &#39;with_objective=</span><span class="si">%s</span><span class="s2">&#39; - with_objective must be a Boolean&quot;</span>
            <span class="o">%</span> <span class="n">with_objective</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">weighted_graph</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid value for weighted_graph: &#39;weighted_graph=</span><span class="si">%s</span><span class="s2">&#39; - weighted_graph must be a Boolean&quot;</span>
            <span class="o">%</span> <span class="n">weighted_graph</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">random_seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid value for random_seed: &#39;random_seed=</span><span class="si">%s</span><span class="s2">&#39; - &quot;</span>
                <span class="s2">&quot;random_seed must be a non-negative integer&quot;</span> <span class="o">%</span> <span class="n">random_seed</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">random_seed</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid value for random_seed: &#39;random_seed=</span><span class="si">%s</span><span class="s2">&#39; - &quot;</span>
                <span class="s2">&quot;random_seed must be a non-negative integer&quot;</span> <span class="o">%</span> <span class="n">random_seed</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="n">use_only_active_components</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span>
        <span class="ow">and</span> <span class="n">use_only_active_components</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid value for use_only_active_components: &#39;use_only_active_components=</span><span class="si">%s</span><span class="s2">&#39; - &quot;</span>
            <span class="s2">&quot;use_only_active_components must be True or None&quot;</span>
            <span class="o">%</span> <span class="n">use_only_active_components</span>
        <span class="p">)</span>

    <span class="c1"># Generate model_graph (a NetworkX graph based on the given Pyomo optimization model),</span>
    <span class="c1"># number_component_map (a dictionary to convert the communities into lists of Pyomo components</span>
    <span class="c1"># instead of number values), and constraint_variable_map (a dictionary that maps a constraint to the variables</span>
    <span class="c1"># it contains)</span>
    <span class="n">model_graph</span><span class="p">,</span> <span class="n">number_component_map</span><span class="p">,</span> <span class="n">constraint_variable_map</span> <span class="o">=</span> <span class="n">generate_model_graph</span><span class="p">(</span>
        <span class="n">model</span><span class="p">,</span>
        <span class="n">type_of_graph</span><span class="o">=</span><span class="n">type_of_community_map</span><span class="p">,</span>
        <span class="n">with_objective</span><span class="o">=</span><span class="n">with_objective</span><span class="p">,</span>
        <span class="n">weighted_graph</span><span class="o">=</span><span class="n">weighted_graph</span><span class="p">,</span>
        <span class="n">use_only_active_components</span><span class="o">=</span><span class="n">use_only_active_components</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># # TODO - Add option for other community detection package</span>
    <span class="c1"># # Maybe something like this:</span>
    <span class="c1"># if community_detection_package is not None:</span>
    <span class="c1">#     partition_of_graph = community_detection_package(model_graph)</span>

    <span class="c1"># Use Louvain community detection to find the communities - this returns a dictionary mapping</span>
    <span class="c1"># individual nodes to their communities</span>
    <span class="n">partition_of_graph</span> <span class="o">=</span> <span class="n">community_louvain</span><span class="o">.</span><span class="n">best_partition</span><span class="p">(</span>
        <span class="n">model_graph</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_seed</span>
    <span class="p">)</span>

    <span class="c1"># Now, use partition_of_graph to create a dictionary (community_map) that maps community keys to the nodes</span>
    <span class="c1"># in each community</span>
    <span class="n">number_of_communities</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">partition_of_graph</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="n">community_map</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">nth_community</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">nth_community</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_communities</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">partition_of_graph</span><span class="p">:</span>
        <span class="n">nth_community</span> <span class="o">=</span> <span class="n">partition_of_graph</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
        <span class="n">community_map</span><span class="p">[</span><span class="n">nth_community</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="c1"># At this point, we have community_map, which maps an integer (the community number) to a list of the nodes in</span>
    <span class="c1"># each community - these nodes are currently just numbers (which are mapped to Pyomo modeling components</span>
    <span class="c1"># with number_component_map)</span>

    <span class="c1"># Now, we want to include another list for each community - the new list will be specific to the</span>
    <span class="c1"># type_of_community_map specified by the user, and is described within the conditionals below</span>

    <span class="c1"># Also, as this second list is constructed, the node values will be converted back to the Pyomo components</span>
    <span class="c1"># through the use of number_component_map, resulting in a dictionary where the values are two-list tuples that</span>
    <span class="c1"># contain Pyomo modeling components</span>

    <span class="k">if</span> <span class="n">type_of_community_map</span> <span class="o">==</span> <span class="s1">&#39;bipartite&#39;</span><span class="p">:</span>
        <span class="c1"># If the community map was created for a bipartite graph, then for a given community, we simply want to</span>
        <span class="c1"># separate the nodes into their two groups; thus, we create a list of constraints and a list of variables</span>

        <span class="k">for</span> <span class="n">community_key</span> <span class="ow">in</span> <span class="n">community_map</span><span class="p">:</span>
            <span class="n">constraint_node_list</span><span class="p">,</span> <span class="n">variable_node_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="n">node_community_list</span> <span class="o">=</span> <span class="n">community_map</span><span class="p">[</span><span class="n">community_key</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">numbered_node</span> <span class="ow">in</span> <span class="n">node_community_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">numbered_node</span> <span class="ow">in</span> <span class="n">constraint_variable_map</span><span class="p">:</span>
                    <span class="n">constraint_node_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">number_component_map</span><span class="p">[</span><span class="n">numbered_node</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">variable_node_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">number_component_map</span><span class="p">[</span><span class="n">numbered_node</span><span class="p">])</span>
            <span class="n">community_map</span><span class="p">[</span><span class="n">community_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">constraint_node_list</span><span class="p">,</span> <span class="n">variable_node_list</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">type_of_community_map</span> <span class="o">==</span> <span class="s1">&#39;constraint&#39;</span><span class="p">:</span>
        <span class="c1"># If the community map was created for a constraint node graph, then for a given community, we want to create a</span>
        <span class="c1"># new list that contains all of the variables contained in the constraint equations of that community</span>

        <span class="k">for</span> <span class="n">community_key</span> <span class="ow">in</span> <span class="n">community_map</span><span class="p">:</span>
            <span class="n">constraint_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">community_map</span><span class="p">[</span><span class="n">community_key</span><span class="p">])</span>
            <span class="n">variable_list</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">constraint_variable_map</span><span class="p">[</span><span class="n">numbered_constraint</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">numbered_constraint</span> <span class="ow">in</span> <span class="n">constraint_list</span>
            <span class="p">]</span>
            <span class="n">variable_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">node</span>
                        <span class="k">for</span> <span class="n">variable_sublist</span> <span class="ow">in</span> <span class="n">variable_list</span>
                        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">variable_sublist</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">variable_list</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">number_component_map</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variable_list</span>
            <span class="p">]</span>
            <span class="n">constraint_list</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">number_component_map</span><span class="p">[</span><span class="n">constraint</span><span class="p">]</span> <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">constraint_list</span>
            <span class="p">]</span>
            <span class="n">community_map</span><span class="p">[</span><span class="n">community_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">constraint_list</span><span class="p">,</span> <span class="n">variable_list</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">type_of_community_map</span> <span class="o">==</span> <span class="s1">&#39;variable&#39;</span><span class="p">:</span>
        <span class="c1"># If the community map was created for a variable node graph, then for a given community, we want to create a</span>
        <span class="c1"># new list that contains all of the constraints that the variables of that community appear in</span>

        <span class="k">for</span> <span class="n">community_key</span> <span class="ow">in</span> <span class="n">community_map</span><span class="p">:</span>
            <span class="n">variable_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">community_map</span><span class="p">[</span><span class="n">community_key</span><span class="p">])</span>
            <span class="n">constraint_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">numbered_variable</span> <span class="ow">in</span> <span class="n">variable_list</span><span class="p">:</span>
                <span class="n">constraint_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">constraint_key</span>
                        <span class="k">for</span> <span class="n">constraint_key</span> <span class="ow">in</span> <span class="n">constraint_variable_map</span>
                        <span class="k">if</span> <span class="n">numbered_variable</span> <span class="ow">in</span> <span class="n">constraint_variable_map</span><span class="p">[</span><span class="n">constraint_key</span><span class="p">]</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="n">constraint_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">constraint_list</span><span class="p">))</span>
            <span class="n">constraint_list</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">number_component_map</span><span class="p">[</span><span class="n">constraint</span><span class="p">]</span> <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">constraint_list</span>
            <span class="p">]</span>
            <span class="n">variable_list</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">number_component_map</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variable_list</span>
            <span class="p">]</span>
            <span class="n">community_map</span><span class="p">[</span><span class="n">community_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">constraint_list</span><span class="p">,</span> <span class="n">variable_list</span><span class="p">)</span>

    <span class="c1"># Thus, each key in community_map now maps to a tuple of two lists, a constraint list and a variable list (in that</span>
    <span class="c1"># order)</span>

    <span class="c1"># Log information about the number of communities found from the model</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> communities were found in the model&quot;</span> <span class="o">%</span> <span class="n">number_of_communities</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">number_of_communities</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;in detect_communities: Empty community map was returned&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">number_of_communities</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;Community detection found that with the given parameters, the model could not be decomposed - &quot;</span>
            <span class="s2">&quot;only one community was found&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Return an instance of CommunityMap class which contains the community_map along with other relevant information</span>
    <span class="c1"># for the community_map</span>
    <span class="k">return</span> <span class="n">CommunityMap</span><span class="p">(</span>
        <span class="n">community_map</span><span class="p">,</span>
        <span class="n">type_of_community_map</span><span class="p">,</span>
        <span class="n">with_objective</span><span class="p">,</span>
        <span class="n">weighted_graph</span><span class="p">,</span>
        <span class="n">random_seed</span><span class="p">,</span>
        <span class="n">use_only_active_components</span><span class="p">,</span>
        <span class="n">model</span><span class="p">,</span>
        <span class="n">model_graph</span><span class="p">,</span>
        <span class="n">number_component_map</span><span class="p">,</span>
        <span class="n">constraint_variable_map</span><span class="p">,</span>
        <span class="n">partition_of_graph</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="CommunityMap"><a class="viewcode-back" href="../../../../contributed_packages/community.html#pyomo.contrib.community_detection.detection.CommunityMap">[docs]</a><span class="k">class</span> <span class="nc">CommunityMap</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is used to create CommunityMap objects which are returned by the detect_communities function. Instances</span>
<span class="sd">    of this class allow dict-like usage and store relevant information about the given community map, such as the</span>
<span class="sd">    model used to create them, their networkX representation, etc.</span>

<span class="sd">    The CommunityMap object acts as a Python dictionary, mapping integer keys to tuples containing two lists</span>
<span class="sd">    (which contain the components in the given community) - a constraint list and variable list.</span>

<span class="sd">    Methods:</span>
<span class="sd">    generate_structured_model</span>
<span class="sd">    visualize_model_graph</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">community_map</span><span class="p">,</span>
        <span class="n">type_of_community_map</span><span class="p">,</span>
        <span class="n">with_objective</span><span class="p">,</span>
        <span class="n">weighted_graph</span><span class="p">,</span>
        <span class="n">random_seed</span><span class="p">,</span>
        <span class="n">use_only_active_components</span><span class="p">,</span>
        <span class="n">model</span><span class="p">,</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">graph_node_mapping</span><span class="p">,</span>
        <span class="n">constraint_variable_map</span><span class="p">,</span>
        <span class="n">graph_partition</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method for the CommunityMap class</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        community_map: dict</span>
<span class="sd">            a Python dictionary that maps arbitrary keys (in this case, integers from zero to the number of</span>
<span class="sd">            communities minus one) to two-list tuples containing Pyomo components in the given community</span>
<span class="sd">        type_of_community_map: str</span>
<span class="sd">            a string that specifies the type of community map to be returned, the default is &#39;constraint&#39;.</span>
<span class="sd">            &#39;constraint&#39; returns a dictionary (community_map) with communities based on constraint nodes,</span>
<span class="sd">            &#39;variable&#39; returns a dictionary (community_map) with communities based on variable nodes,</span>
<span class="sd">            &#39;bipartite&#39; returns a dictionary (community_map) with communities based on a bipartite graph (both constraint</span>
<span class="sd">            and variable nodes)</span>
<span class="sd">        with_objective: bool</span>
<span class="sd">            a Boolean argument that specifies whether or not the objective function is</span>
<span class="sd">            included in the model graph (and thus in &#39;community_map&#39;); the default is True</span>
<span class="sd">        weighted_graph: bool</span>
<span class="sd">            a Boolean argument that specifies whether community_map is created based on a weighted model graph or an</span>
<span class="sd">            unweighted model graph; the default is True (type_of_community_map=&#39;bipartite&#39; creates an unweighted</span>
<span class="sd">            model graph regardless of this parameter)</span>
<span class="sd">        random_seed: int or None</span>
<span class="sd">            an integer that is used as the random seed for the (heuristic) Louvain community detection</span>
<span class="sd">        use_only_active_components: bool, optional</span>
<span class="sd">            a Boolean argument that specifies whether inactive constraints/objectives are included in the community map</span>
<span class="sd">        model: Block</span>
<span class="sd">            a Pyomo model or block to be used for community detection</span>
<span class="sd">        graph: nx.Graph</span>
<span class="sd">            a NetworkX graph with nodes and edges based on the Pyomo optimization model</span>
<span class="sd">        graph_node_mapping: dict</span>
<span class="sd">            a dictionary that maps a number (which corresponds to a node in the networkX graph representation of the</span>
<span class="sd">            model) to a component in the model</span>
<span class="sd">        constraint_variable_map: dict</span>
<span class="sd">            a dictionary that maps a numbered constraint to a list of (numbered) variables that appear in the constraint</span>
<span class="sd">        graph_partition: dict</span>
<span class="sd">            the partition of the networkX model graph based on the Louvain community detection</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">community_map</span> <span class="o">=</span> <span class="n">community_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_of_community_map</span> <span class="o">=</span> <span class="n">type_of_community_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">with_objective</span> <span class="o">=</span> <span class="n">with_objective</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weighted_graph</span> <span class="o">=</span> <span class="n">weighted_graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span> <span class="o">=</span> <span class="n">random_seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_only_active_components</span> <span class="o">=</span> <span class="n">use_only_active_components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_node_mapping</span> <span class="o">=</span> <span class="n">graph_node_mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraint_variable_map</span> <span class="o">=</span> <span class="n">constraint_variable_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_partition</span> <span class="o">=</span> <span class="n">graph_partition</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        repr method changed to return the community_map with the memory locations of the Pyomo components - use str</span>
<span class="sd">        method if the strings of the components are desired</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">community_map</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        str method changed to return the community_map with the strings of the Pyomo components (user-friendly output)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create str_community_map and give it values that are the strings of the components in community_map</span>
        <span class="n">str_community_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">community_map</span><span class="p">:</span>
            <span class="n">str_community_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">community_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span>
                <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">community_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span>
            <span class="p">)</span>

        <span class="c1"># Return str_community_map, which is identical to community_map except it has the strings of all of the Pyomo</span>
        <span class="c1"># components instead of the actual components</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">str_community_map</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">community_map</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">CommunityMap</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">community_map</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">community_map</span>
            <span class="c1"># Should you check anything else for equality between instances?</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">community_map</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">key</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">community_map</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">community_map</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">community_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">community_map</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">community_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

<div class="viewcode-block" id="CommunityMap.visualize_model_graph"><a class="viewcode-back" href="../../../../contributed_packages/community.html#pyomo.contrib.community_detection.detection.CommunityMap.visualize_model_graph">[docs]</a>    <span class="k">def</span> <span class="nf">visualize_model_graph</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">type_of_graph</span><span class="o">=</span><span class="s1">&#39;constraint&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function draws a graph of the communities for a Pyomo model.</span>

<span class="sd">        The type_of_graph parameter is used to create either a variable-node graph, constraint-node graph, or</span>
<span class="sd">        bipartite graph of the Pyomo model. Then, the nodes are colored based on the communities they are in - which</span>
<span class="sd">        is based on the community map (self.community_map). A filename can be provided to save the figure, otherwise</span>
<span class="sd">        the figure is illustrated with matplotlib.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        type_of_graph: str, optional</span>
<span class="sd">            a string that specifies the types of nodes drawn on the model graph, the default is &#39;constraint&#39;.</span>
<span class="sd">            &#39;constraint&#39; draws a graph with constraint nodes,</span>
<span class="sd">            &#39;variable&#39; draws a graph with variable nodes,</span>
<span class="sd">            &#39;bipartite&#39; draws a bipartite graph (with both constraint and variable nodes)</span>
<span class="sd">        filename: str, optional</span>
<span class="sd">            a string that specifies a path for the model graph illustration to be saved</span>
<span class="sd">        pos: dict, optional</span>
<span class="sd">            a dictionary that maps node keys to their positions on the illustration</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig: matplotlib figure</span>
<span class="sd">            the figure for the model graph drawing</span>
<span class="sd">        pos: dict</span>
<span class="sd">            a dictionary that maps node keys to their positions on the illustration - can be used to create consistent</span>
<span class="sd">            layouts for graphs of a given model</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check that all arguments are of the correct type</span>

        <span class="k">assert</span> <span class="n">type_of_graph</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;bipartite&#39;</span><span class="p">,</span> <span class="s1">&#39;constraint&#39;</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">),</span> <span class="p">(</span>
            <span class="s2">&quot;Invalid graph type specified: &#39;type_of_graph=</span><span class="si">%s</span><span class="s2">&#39; - Valid values: &quot;</span>
            <span class="s2">&quot;&#39;bipartite&#39;, &#39;constraint&#39;, &#39;variable&#39;&quot;</span> <span class="o">%</span> <span class="n">type_of_graph</span>
        <span class="p">)</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">str</span><span class="p">)),</span> <span class="p">(</span>
            <span class="s2">&quot;Invalid value for filename: &#39;filename=</span><span class="si">%s</span><span class="s2">&#39; - filename &quot;</span>
            <span class="s2">&quot;must be a string&quot;</span> <span class="o">%</span> <span class="n">filename</span>
        <span class="p">)</span>

        <span class="c1"># No assert statement for pos; the NetworkX function can handle issues with the pos argument</span>

        <span class="c1"># There is a possibility that the desired networkX graph of the model is already stored in the</span>
        <span class="c1"># CommunityMap object (because the networkX graph is required to create the CommunityMap object)</span>
        <span class="k">if</span> <span class="n">type_of_graph</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_of_community_map</span><span class="p">:</span>
            <span class="c1"># Use the generate_model_graph function to create a NetworkX graph of the given model (along with</span>
            <span class="c1"># number_component_map and constraint_variable_map, which will be used to help with drawing the graph)</span>
            <span class="p">(</span>
                <span class="n">model_graph</span><span class="p">,</span>
                <span class="n">number_component_map</span><span class="p">,</span>
                <span class="n">constraint_variable_map</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">generate_model_graph</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                <span class="n">type_of_graph</span><span class="o">=</span><span class="n">type_of_graph</span><span class="p">,</span>
                <span class="n">with_objective</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">with_objective</span><span class="p">,</span>
                <span class="n">weighted_graph</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weighted_graph</span><span class="p">,</span>
                <span class="n">use_only_active_components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_only_active_components</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This is the case where, as mentioned above, we can use the networkX graph that was made to create</span>
            <span class="c1"># the CommunityMap object</span>
            <span class="n">model_graph</span><span class="p">,</span> <span class="n">number_component_map</span><span class="p">,</span> <span class="n">constraint_variable_map</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph_node_mapping</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">constraint_variable_map</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># This line creates the &quot;reverse&quot; of the number_component_map above, since mapping the Pyomo</span>
        <span class="c1"># components to their nodes in the networkX graph is more convenient in this function</span>
        <span class="n">component_number_map</span> <span class="o">=</span> <span class="n">ComponentMap</span><span class="p">(</span>
            <span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">number</span><span class="p">)</span> <span class="k">for</span> <span class="n">number</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">number_component_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="c1"># Create a deep copy of the community_map attribute to avoid destructively modifying it</span>
        <span class="n">numbered_community_map</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">community_map</span><span class="p">)</span>

        <span class="c1"># Now we will use the component_number_map to change the Pyomo modeling components in community_map into the</span>
        <span class="c1"># numbers that correspond to their nodes/edges in the NetworkX graph, model_graph</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">community_map</span><span class="p">:</span>
            <span class="n">numbered_community_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">component_number_map</span><span class="p">[</span><span class="n">component</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">community_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">],</span>
                <span class="p">[</span>
                    <span class="n">component_number_map</span><span class="p">[</span><span class="n">component</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">community_map</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">],</span>
            <span class="p">)</span>

        <span class="c1"># Based on type_of_graph, which specifies what Pyomo modeling components are to be drawn as nodes in the graph</span>
        <span class="c1"># illustration, we will now get the node list and the color list, which describes how to color nodes</span>
        <span class="c1"># according to their communities (which is based on community_map)</span>
        <span class="k">if</span> <span class="n">type_of_graph</span> <span class="o">==</span> <span class="s1">&#39;bipartite&#39;</span><span class="p">:</span>
            <span class="n">list_of_node_lists</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">list_of_nodes</span>
                <span class="k">for</span> <span class="n">list_tuple</span> <span class="ow">in</span> <span class="n">numbered_community_map</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">list_of_nodes</span> <span class="ow">in</span> <span class="n">list_tuple</span>
            <span class="p">]</span>

            <span class="c1"># list_of_node_lists is (as it implies) a list of lists, so we will use the list comprehension</span>
            <span class="c1"># below to flatten the list and get our one-dimensional node list</span>
            <span class="n">node_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">list_of_node_lists</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>

            <span class="n">color_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Now, we will find the first community that a node appears in and color the node based on that community</span>
            <span class="c1"># In community_map, certain nodes may appear in multiple communities, and we have chosen to give preference</span>
            <span class="c1"># to the first community a node appears in</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_list</span><span class="p">:</span>
                <span class="n">not_found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">community_key</span> <span class="ow">in</span> <span class="n">numbered_community_map</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">not_found</span> <span class="ow">and</span> <span class="n">node</span> <span class="ow">in</span> <span class="p">(</span>
                        <span class="n">numbered_community_map</span><span class="p">[</span><span class="n">community_key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="o">+</span> <span class="n">numbered_community_map</span><span class="p">[</span><span class="n">community_key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="p">):</span>
                        <span class="n">color_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">community_key</span><span class="p">)</span>
                        <span class="n">not_found</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Find top_nodes (one of the two &quot;groups&quot; of nodes in a bipartite graph), which will be used to</span>
            <span class="c1"># determine the graph layout</span>
            <span class="k">if</span> <span class="n">model_graph</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">model_graph</span><span class="p">):</span>
                <span class="c1"># An index of 1 used because this tends to place constraint nodes on the left, which is</span>
                <span class="c1"># consistent with the else case</span>
                <span class="n">top_nodes</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">bipartite</span><span class="o">.</span><span class="n">sets</span><span class="p">(</span><span class="n">model_graph</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">top_nodes</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">node</span>
                    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">model_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">constraint_variable_map</span>
                <span class="p">}</span>

            <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># The case where the user has not provided their own layout</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">bipartite_layout</span><span class="p">(</span><span class="n">model_graph</span><span class="p">,</span> <span class="n">top_nodes</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># This covers the case that type_of_community_map is &#39;constraint&#39; or &#39;variable&#39;</span>
            <span class="c1"># Constraints are in the first list of the tuples in community map and variables are in the second list</span>
            <span class="n">position</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">type_of_graph</span> <span class="o">==</span> <span class="s1">&#39;constraint&#39;</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="n">list_of_node_lists</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">i</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numbered_community_map</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="p">)</span>

            <span class="c1"># list_of_node_lists is (as it implies) a list of lists, so we will use the list comprehension</span>
            <span class="c1"># below to flatten the list and get our one-dimensional node list</span>
            <span class="n">node_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">list_of_node_lists</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>

            <span class="c1"># Now, we will find the first community that a node appears in and color the node based on</span>
            <span class="c1"># that community (in numbered_community_map, certain nodes may appear in multiple communities,</span>
            <span class="c1"># and we have chosen to give preference to the first community a node appears in)</span>
            <span class="n">color_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_list</span><span class="p">:</span>
                <span class="n">not_found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">community_key</span> <span class="ow">in</span> <span class="n">numbered_community_map</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">not_found</span>
                        <span class="ow">and</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">numbered_community_map</span><span class="p">[</span><span class="n">community_key</span><span class="p">][</span><span class="n">position</span><span class="p">]</span>
                    <span class="p">):</span>
                        <span class="n">color_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">community_key</span><span class="p">)</span>
                        <span class="n">not_found</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Note - there is no strong reason to choose spring layout; it just creates relatively clean graphs</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># The case where the user has not provided their own layout</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">model_graph</span><span class="p">)</span>

        <span class="c1"># Define color_map</span>
        <span class="n">color_map</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">numbered_community_map</span><span class="p">))</span>

        <span class="c1"># Create the figure and draw the graph</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span>
            <span class="n">model_graph</span><span class="p">,</span>
            <span class="n">pos</span><span class="p">,</span>
            <span class="n">nodelist</span><span class="o">=</span><span class="n">node_list</span><span class="p">,</span>
            <span class="n">node_size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
            <span class="n">cmap</span><span class="o">=</span><span class="n">color_map</span><span class="p">,</span>
            <span class="n">node_color</span><span class="o">=</span><span class="n">color_list</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="n">model_graph</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="c1"># Make the main title</span>
        <span class="n">graph_type</span> <span class="o">=</span> <span class="n">type_of_graph</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
        <span class="n">community_map_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_of_community_map</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
        <span class="n">main_graph_title</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> graph - colored using </span><span class="si">%s</span><span class="s2"> community map&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">graph_type</span><span class="p">,</span>
            <span class="n">community_map_type</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">main_font_size</span> <span class="o">=</span> <span class="mi">14</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">main_graph_title</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">main_font_size</span><span class="p">)</span>

        <span class="c1"># Define a dict that will be used for the graph subtitle</span>
        <span class="n">subtitle_naming_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;bipartite&#39;</span><span class="p">:</span> <span class="s1">&#39;Nodes are variables and constraints &amp; Edges are variables in a constraint&#39;</span><span class="p">,</span>
            <span class="s1">&#39;constraint&#39;</span><span class="p">:</span> <span class="s1">&#39;Nodes are constraints &amp; Edges are common variables&#39;</span><span class="p">,</span>
            <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="s1">&#39;Nodes are variables &amp; Edges are shared constraints&#39;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Make the subtitle</span>
        <span class="n">subtitle_font_size</span> <span class="o">=</span> <span class="mi">11</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">subtitle_naming_dict</span><span class="p">[</span><span class="n">type_of_graph</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">subtitle_font_size</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># Return the figure and pos, the position dictionary used for the graph layout</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">pos</span></div>

<div class="viewcode-block" id="CommunityMap.generate_structured_model"><a class="viewcode-back" href="../../../../contributed_packages/community.html#pyomo.contrib.community_detection.detection.CommunityMap.generate_structured_model">[docs]</a>    <span class="k">def</span> <span class="nf">generate_structured_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Using the community map and the original model used to create this community map, we will create</span>
<span class="sd">        structured_model, which will be based on the original model but will place variables, constraints, and</span>
<span class="sd">        objectives into or outside of various blocks (communities) based on the community map.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        structured_model: Block</span>
<span class="sd">            a Pyomo model that reflects the nature of the community map</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Initialize a new model (structured_model) which will contain variables and constraints in blocks based on</span>
        <span class="c1"># their respective communities within the CommunityMap</span>
        <span class="n">structured_model</span> <span class="o">=</span> <span class="n">ConcreteModel</span><span class="p">()</span>

        <span class="c1"># Create N blocks (where N is the number of communities found within the model)</span>
        <span class="n">structured_model</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">Block</span><span class="p">(</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">community_map</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># values given for (start, stop, step)</span>

        <span class="c1"># Initialize a ComponentMap that will map a variable from the model (for example, old_model.x1) used to</span>
        <span class="c1"># create the CommunityMap to a list of variables in various blocks that were created based on this</span>
        <span class="c1"># variable (for example, [structured_model.b[0].x1, structured_model.b[3].x1])</span>
        <span class="n">blocked_variable_map</span> <span class="o">=</span> <span class="n">ComponentMap</span><span class="p">()</span>
        <span class="c1"># Example key-value pair -&gt; {original_model.x1 : [structured_model.b[0].x1, structured_model.b[3].x1]}</span>

        <span class="c1"># TODO - Consider changing structure of the next two for loops to be more efficient (maybe loop through</span>
        <span class="c1">#  constraints and add variables as you go) (but note that disconnected variables would be</span>
        <span class="c1">#  missed with this strategy)</span>

        <span class="c1"># First loop through community_map to add all the variables to structured_model before we add constraints</span>
        <span class="c1"># that use those variables</span>
        <span class="k">for</span> <span class="n">community_key</span><span class="p">,</span> <span class="n">community</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">community_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">variables_in_community</span> <span class="o">=</span> <span class="n">community</span>

            <span class="c1"># Loop through all of the variables (from the original model) in the given community</span>
            <span class="k">for</span> <span class="n">stored_variable</span> <span class="ow">in</span> <span class="n">variables_in_community</span><span class="p">:</span>
                <span class="c1"># Construct a new_variable whose attributes are determined by querying the variable from the</span>
                <span class="c1"># original model</span>
                <span class="n">new_variable</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span>
                    <span class="n">domain</span><span class="o">=</span><span class="n">stored_variable</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">stored_variable</span><span class="o">.</span><span class="n">bounds</span>
                <span class="p">)</span>

                <span class="c1"># Add this new_variable to its block/community and name it using the string of the variable from the</span>
                <span class="c1"># original model</span>
                <span class="n">structured_model</span><span class="o">.</span><span class="n">b</span><span class="p">[</span><span class="n">community_key</span><span class="p">]</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">stored_variable</span><span class="p">),</span> <span class="n">new_variable</span>
                <span class="p">)</span>

                <span class="c1"># Since there could be multiple variables &#39;x1&#39; (such as</span>
                <span class="c1"># structured_model.b[0].x1, structured_model.b[3].x1, etc), we need to create equality constraints</span>
                <span class="c1"># for all of the variables &#39;x1&#39; within structured_model (this is the purpose of blocked_variable_map)</span>

                <span class="c1"># Here we update blocked_variable_map to keep track of what equality constraints need to be made</span>
                <span class="n">variable_in_new_model</span> <span class="o">=</span> <span class="n">structured_model</span><span class="o">.</span><span class="n">find_component</span><span class="p">(</span><span class="n">new_variable</span><span class="p">)</span>
                <span class="n">blocked_variable_map</span><span class="p">[</span><span class="n">stored_variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">blocked_variable_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="n">stored_variable</span><span class="p">,</span> <span class="p">[]</span>
                <span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">variable_in_new_model</span><span class="p">]</span>

        <span class="c1"># Now that we have all of our variables within the model, we will initialize a dictionary that used to</span>
        <span class="c1"># replace variables within constraints to other variables (in our case, this will convert variables from the</span>
        <span class="c1"># original model into variables from the new model (structured_model))</span>
        <span class="n">replace_variables_in_expression_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Loop through community_map again, this time to add constraints (with replaced variables)</span>
        <span class="k">for</span> <span class="n">community_key</span><span class="p">,</span> <span class="n">community</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">community_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">constraints_in_community</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">community</span>

            <span class="c1"># Loop through all of the constraints (from the original model) in the given community</span>
            <span class="k">for</span> <span class="n">stored_constraint</span> <span class="ow">in</span> <span class="n">constraints_in_community</span><span class="p">:</span>
                <span class="c1"># Now, loop through all of the variables within the given constraint expression</span>
                <span class="k">for</span> <span class="n">variable_in_stored_constraint</span> <span class="ow">in</span> <span class="n">identify_variables</span><span class="p">(</span>
                    <span class="n">stored_constraint</span><span class="o">.</span><span class="n">expr</span>
                <span class="p">):</span>
                    <span class="c1"># Loop through each of the &quot;blocked&quot; variables that a variable is mapped to and update</span>
                    <span class="c1"># replace_variables_in_expression_map if a variable has a &quot;blocked&quot; form in the given community</span>

                    <span class="c1"># What this means is that if we are looping through constraints in community 0, then it would be</span>
                    <span class="c1"># best to change a variable x1 into b[0].x1 as opposed to b[2].x1 or b[5].x1 (assuming all of these</span>
                    <span class="c1"># blocked versions of the variable x1 exist (which depends on the community map))</span>

                    <span class="n">variable_in_current_block</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">blocked_variable</span> <span class="ow">in</span> <span class="n">blocked_variable_map</span><span class="p">[</span>
                        <span class="n">variable_in_stored_constraint</span>
                    <span class="p">]:</span>
                        <span class="k">if</span> <span class="s1">&#39;b[</span><span class="si">%d</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="n">community_key</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">blocked_variable</span><span class="p">):</span>
                            <span class="c1"># Update replace_variables_in_expression_map accordingly</span>
                            <span class="n">replace_variables_in_expression_map</span><span class="p">[</span>
                                <span class="nb">id</span><span class="p">(</span><span class="n">variable_in_stored_constraint</span><span class="p">)</span>
                            <span class="p">]</span> <span class="o">=</span> <span class="n">blocked_variable</span>
                            <span class="n">variable_in_current_block</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">variable_in_current_block</span><span class="p">:</span>
                        <span class="c1"># Create a version of the given variable outside of blocks then add it to</span>
                        <span class="c1"># replace_variables_in_expression_map</span>

                        <span class="n">new_variable</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span>
                            <span class="n">domain</span><span class="o">=</span><span class="n">variable_in_stored_constraint</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                            <span class="n">bounds</span><span class="o">=</span><span class="n">variable_in_stored_constraint</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span>
                        <span class="p">)</span>

                        <span class="c1"># Add the new variable just as we did above (but now it is not in any blocks)</span>
                        <span class="n">structured_model</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span>
                            <span class="nb">str</span><span class="p">(</span><span class="n">variable_in_stored_constraint</span><span class="p">),</span> <span class="n">new_variable</span>
                        <span class="p">)</span>

                        <span class="c1"># Update blocked_variable_map to keep track of what equality constraints need to be made</span>
                        <span class="n">variable_in_new_model</span> <span class="o">=</span> <span class="n">structured_model</span><span class="o">.</span><span class="n">find_component</span><span class="p">(</span>
                            <span class="n">new_variable</span>
                        <span class="p">)</span>
                        <span class="n">blocked_variable_map</span><span class="p">[</span>
                            <span class="n">variable_in_stored_constraint</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">blocked_variable_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                            <span class="n">variable_in_stored_constraint</span><span class="p">,</span> <span class="p">[]</span>
                        <span class="p">)</span> <span class="o">+</span> <span class="p">[</span>
                            <span class="n">variable_in_new_model</span>
                        <span class="p">]</span>

                        <span class="c1"># Update replace_variables_in_expression_map accordingly</span>
                        <span class="n">replace_variables_in_expression_map</span><span class="p">[</span>
                            <span class="nb">id</span><span class="p">(</span><span class="n">variable_in_stored_constraint</span><span class="p">)</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">variable_in_new_model</span>

                <span class="c1"># TODO - Is there a better way to check whether something is actually an objective? (as done below)</span>
                <span class="c1"># Check to see whether &#39;stored_constraint&#39; is actually an objective (since constraints and objectives</span>
                <span class="c1"># grouped together)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_objective</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">stored_constraint</span><span class="p">,</span> <span class="p">(</span><span class="n">_GeneralObjectiveData</span><span class="p">,</span> <span class="n">Objective</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="c1"># If the constraint is actually an objective, we add it to the block as an objective</span>
                    <span class="n">new_objective</span> <span class="o">=</span> <span class="n">Objective</span><span class="p">(</span>
                        <span class="n">expr</span><span class="o">=</span><span class="n">replace_expressions</span><span class="p">(</span>
                            <span class="n">stored_constraint</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">replace_variables_in_expression_map</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">structured_model</span><span class="o">.</span><span class="n">b</span><span class="p">[</span><span class="n">community_key</span><span class="p">]</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">stored_constraint</span><span class="p">),</span> <span class="n">new_objective</span>
                    <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Construct a constraint based on the expression within stored_constraint and the dict we have</span>
                    <span class="c1"># created for the purpose of replacing the variables within the constraint expression</span>
                    <span class="n">new_constraint</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span>
                        <span class="n">expr</span><span class="o">=</span><span class="n">replace_expressions</span><span class="p">(</span>
                            <span class="n">stored_constraint</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">replace_variables_in_expression_map</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

                    <span class="c1"># Add this new constraint to the corresponding community/block with its name as the string of the</span>
                    <span class="c1"># constraint from the original model</span>
                    <span class="n">structured_model</span><span class="o">.</span><span class="n">b</span><span class="p">[</span><span class="n">community_key</span><span class="p">]</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">stored_constraint</span><span class="p">),</span> <span class="n">new_constraint</span>
                    <span class="p">)</span>

        <span class="c1"># If with_objective was set to False, that means we might have missed an objective function within the</span>
        <span class="c1"># original model</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_objective</span><span class="p">:</span>
            <span class="c1"># Construct a new dictionary for replacing the variables (replace_variables_in_objective_map) which will</span>
            <span class="c1"># be specific to the variables in the objective function, since there is the possibility that the</span>
            <span class="c1"># objective contains variables we have not yet seen (and thus not yet added to our new model)</span>
            <span class="k">for</span> <span class="n">objective_function</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">component_data_objects</span><span class="p">(</span>
                <span class="n">ctype</span><span class="o">=</span><span class="n">Objective</span><span class="p">,</span>
                <span class="n">active</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_only_active_components</span><span class="p">,</span>
                <span class="n">descend_into</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">for</span> <span class="n">variable_in_objective</span> <span class="ow">in</span> <span class="n">identify_variables</span><span class="p">(</span><span class="n">objective_function</span><span class="p">):</span>
                    <span class="c1"># Add all of the variables in the objective function (not within any blocks)</span>

                    <span class="c1"># Check to make sure a form of the variable has not already been made outside of the blocks</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">structured_model</span><span class="o">.</span><span class="n">find_component</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">variable_in_objective</span><span class="p">))</span>
                        <span class="ow">is</span> <span class="kc">None</span>
                    <span class="p">):</span>
                        <span class="n">new_variable</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span>
                            <span class="n">domain</span><span class="o">=</span><span class="n">variable_in_objective</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                            <span class="n">bounds</span><span class="o">=</span><span class="n">variable_in_objective</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">structured_model</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span>
                            <span class="nb">str</span><span class="p">(</span><span class="n">variable_in_objective</span><span class="p">),</span> <span class="n">new_variable</span>
                        <span class="p">)</span>

                        <span class="c1"># Again we update blocked_variable_map to keep track of what</span>
                        <span class="c1"># equality constraints need to be made</span>
                        <span class="n">variable_in_new_model</span> <span class="o">=</span> <span class="n">structured_model</span><span class="o">.</span><span class="n">find_component</span><span class="p">(</span>
                            <span class="n">new_variable</span>
                        <span class="p">)</span>
                        <span class="n">blocked_variable_map</span><span class="p">[</span>
                            <span class="n">variable_in_objective</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">blocked_variable_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">variable_in_objective</span><span class="p">,</span> <span class="p">[])</span> <span class="o">+</span> <span class="p">[</span>
                            <span class="n">variable_in_new_model</span>
                        <span class="p">]</span>

                        <span class="c1"># Update the dictionary that we will use to replace the variables</span>
                        <span class="n">replace_variables_in_expression_map</span><span class="p">[</span>
                            <span class="nb">id</span><span class="p">(</span><span class="n">variable_in_objective</span><span class="p">)</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">variable_in_new_model</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">version_of_variable</span> <span class="ow">in</span> <span class="n">blocked_variable_map</span><span class="p">[</span>
                            <span class="n">variable_in_objective</span>
                        <span class="p">]:</span>
                            <span class="k">if</span> <span class="s1">&#39;b[&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">version_of_variable</span><span class="p">):</span>
                                <span class="n">replace_variables_in_expression_map</span><span class="p">[</span>
                                    <span class="nb">id</span><span class="p">(</span><span class="n">variable_in_objective</span><span class="p">)</span>
                                <span class="p">]</span> <span class="o">=</span> <span class="n">version_of_variable</span>

                <span class="c1"># Now we will construct a new objective function based on the one from the original model and then</span>
                <span class="c1"># add it to the new model just as we have done before</span>
                <span class="n">new_objective</span> <span class="o">=</span> <span class="n">Objective</span><span class="p">(</span>
                    <span class="n">expr</span><span class="o">=</span><span class="n">replace_expressions</span><span class="p">(</span>
                        <span class="n">objective_function</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">replace_variables_in_expression_map</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">structured_model</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">objective_function</span><span class="p">),</span> <span class="n">new_objective</span><span class="p">)</span>

        <span class="c1"># Now, we need to create equality constraints for all of the different &quot;versions&quot; of a variable (such</span>
        <span class="c1"># as x1, b[0].x1, b[2].x2, etc.)</span>

        <span class="c1"># Create a constraint list for the equality constraints</span>
        <span class="n">structured_model</span><span class="o">.</span><span class="n">equality_constraint_list</span> <span class="o">=</span> <span class="n">ConstraintList</span><span class="p">(</span>
            <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Equality Constraints for the different forms of a given variable&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Loop through blocked_variable_map and create constraints accordingly</span>
        <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">duplicate_variables</span> <span class="ow">in</span> <span class="n">blocked_variable_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># variable -&gt; variable from the original model</span>
            <span class="c1"># duplicate_variables -&gt; list of variables in the new model</span>

            <span class="c1"># Create a list of all the possible equality constraints that need to be made</span>
            <span class="n">equalities_to_make</span> <span class="o">=</span> <span class="n">combinations</span><span class="p">(</span><span class="n">duplicate_variables</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

            <span class="c1"># Loop through the list of two-variable tuples and create an equality constraint for those two variables</span>
            <span class="k">for</span> <span class="n">variable_1</span><span class="p">,</span> <span class="n">variable_2</span> <span class="ow">in</span> <span class="n">equalities_to_make</span><span class="p">:</span>
                <span class="n">structured_model</span><span class="o">.</span><span class="n">equality_constraint_list</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                    <span class="n">expr</span><span class="o">=</span><span class="n">variable_1</span> <span class="o">==</span> <span class="n">variable_2</span>
                <span class="p">)</span>

        <span class="c1"># Return &#39;structured_model&#39;, which is essentially identical to the original model but now has all of the</span>
        <span class="c1"># variables, constraints, and objectives placed into blocks based on the nature of the CommunityMap</span>

        <span class="k">return</span> <span class="n">structured_model</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2008-2023, Sandia National Laboratories.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>