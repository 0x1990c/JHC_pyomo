

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>pyomo.network.foqus_graph &mdash; Pyomo 6.5.1.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> Pyomo
          

          
          </a>

          
            
            
              <div class="version">
                6.5.1.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../citing_pyomo.html">Citing Pyomo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../pyomo_overview/index.html">Pyomo Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../pyomo_modeling_components/index.html">Pyomo Modeling Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../solving_pyomo_models.html">Solving Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_models.html">Working with Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_abstractmodels/index.html">Working with Abstract Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../model_transformations/index.html">Model Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modeling_extensions/index.html">Modeling Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial_examples.html">Pyomo Tutorial Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../model_debugging/index.html">Debugging Pyomo Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../advanced_topics/index.html">Advanced Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../errors.html">Common Warnings/Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_reference/index.html">Developer Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../library_reference/index.html">Library Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribution_guide.html">Contributing to Pyomo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributed_packages/index.html">Third-Party Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../related_packages.html">Related Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Pyomo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pyomo.network.foqus_graph</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyomo.network.foqus_graph</h1><div class="highlight"><pre>
<span></span><span class="c1">#  ___________________________________________________________________________</span>
<span class="c1">#</span>
<span class="c1">#  Pyomo: Python Optimization Modeling Objects</span>
<span class="c1">#  Copyright (c) 2008-2022</span>
<span class="c1">#  National Technology and Engineering Solutions of Sandia, LLC</span>
<span class="c1">#  Under the terms of Contract DE-NA0003525 with National Technology and</span>
<span class="c1">#  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain</span>
<span class="c1">#  rights in this software.</span>
<span class="c1">#  This software is distributed under the 3-clause BSD License.</span>
<span class="c1">#  ___________________________________________________________________________</span>

<span class="c1">##############################################################################</span>
<span class="c1"># The methods in this module (file) were derived from the</span>
<span class="c1"># `foqus_lib/framework/graph/graph.py` module in the FOQUS package</span>
<span class="c1"># (https://github.com/CCSI-Toolset/FOQUS),</span>
<span class="c1"># commit hash b28f9cf086b1cfa3d771ffbba014c4bfc15c27b8.</span>
<span class="c1">#</span>
<span class="c1"># FOQUS License Agreement</span>
<span class="c1">#</span>
<span class="c1"># Foqus Copyright (c) 2012 - 2018, by the software owners: Oak Ridge Institute</span>
<span class="c1"># for Science and Education (ORISE), Los Alamos National Security, LLC.,</span>
<span class="c1"># Lawrence Livermore National Security, LLC., The Regents of the University of</span>
<span class="c1"># California, through Lawrence Berkeley National Laboratory, Battelle Memorial</span>
<span class="c1"># Institute, Pacific Northwest Division through Pacific Northwest National</span>
<span class="c1"># Laboratory, Carnegie Mellon University, West Virginia University, Boston</span>
<span class="c1"># University, the Trustees of Princeton University, The University of Texas at</span>
<span class="c1"># Austin, URS Energy &amp; Construction, Inc., et al. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are met:</span>
<span class="c1">#</span>
<span class="c1">#     1. Redistributions of source code must retain the above copyright</span>
<span class="c1">#           notice, this list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1">#     2. Redistributions in binary form must reproduce the above copyright</span>
<span class="c1">#           notice, this list of conditions and the following disclaimer in</span>
<span class="c1">#           the documentation and/or other materials provided with the</span>
<span class="c1">#           distribution.</span>
<span class="c1">#</span>
<span class="c1">#     3. Neither the name of the Carbon Capture Simulation Initiative, U.S.</span>
<span class="c1">#           Dept. of Energy, the National Energy Technology Laboratory, Oak</span>
<span class="c1">#           Ridge Institute for Science and Education (ORISE), Los Alamos</span>
<span class="c1">#           National Security, LLC., Lawrence Livermore National Security,</span>
<span class="c1">#           LLC., the University of California, Lawrence Berkeley National</span>
<span class="c1">#           Laboratory, Battelle Memorial Institute, Pacific Northwest</span>
<span class="c1">#           National Laboratory, Carnegie Mellon University, West Virginia</span>
<span class="c1">#           University, Boston University, the Trustees of Princeton</span>
<span class="c1">#           University, the University of Texas at Austin, URS Energy &amp;</span>
<span class="c1">#           Construction, Inc., nor the names of its contributors may be used</span>
<span class="c1">#           to endorse or promote products derived from this software without</span>
<span class="c1">#           specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="c1"># AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="c1"># IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="c1"># ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span>
<span class="c1"># LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="c1"># CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="c1"># SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="c1"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="c1"># CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="c1"># ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="c1"># POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1">#</span>
<span class="c1"># You are under no obligation whatsoever to provide any bug fixes, patches, or</span>
<span class="c1"># upgrades to the features, functionality or performance of the source code</span>
<span class="c1"># (&quot;Enhancements&quot;) to anyone; however, if you choose to make your Enhancements</span>
<span class="c1"># available either publicly, or directly to Lawrence Berkeley National</span>
<span class="c1"># Laboratory, without imposing a separate written license agreement for such</span>
<span class="c1"># Enhancements, then you hereby grant the following license: a non-exclusive,</span>
<span class="c1"># royalty-free perpetual license to install, use, modify, prepare derivative</span>
<span class="c1"># works, incorporate into other computer software, distribute, and sublicense</span>
<span class="c1"># such enhancements or derivative works thereof, in binary and source code</span>
<span class="c1"># form.</span>
<span class="c1">##############################################################################</span>

<span class="kn">import</span> <span class="nn">copy</span><span class="o">,</span> <span class="nn">logging</span>

<span class="kn">from</span> <span class="nn">pyomo.common.dependencies</span> <span class="kn">import</span> <span class="n">numpy</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;pyomo.network&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">FOQUSGraph</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">solve_tear_direct</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">tears</span><span class="p">,</span> <span class="n">outEdges</span><span class="p">,</span> <span class="n">iterLim</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">tol_type</span><span class="p">,</span> <span class="n">report_diffs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use direct substitution to solve tears. If multiple tears are</span>
<span class="sd">        given they are solved simultaneously.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">            order</span>
<span class="sd">                List of lists of order in which to calculate nodes</span>
<span class="sd">            tears</span>
<span class="sd">                List of tear edge indexes</span>
<span class="sd">            iterLim</span>
<span class="sd">                Limit on the number of iterations to run</span>
<span class="sd">            tol</span>
<span class="sd">                Tolerance at which iteration can be stopped</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            list</span>
<span class="sd">                List of lists of diff history, differences between input and</span>
<span class="sd">                output values at each iteration</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># diff at each iteration in every variable</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">tears</span><span class="p">):</span>
            <span class="c1"># no need to iterate just run the calculations</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_order</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">tears</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">hist</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting Direct tear convergence&quot;</span><span class="p">)</span>

        <span class="n">ignore</span> <span class="o">=</span> <span class="n">tears</span> <span class="o">+</span> <span class="n">outEdges</span>
        <span class="n">itercount</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">svals</span><span class="p">,</span> <span class="n">dvals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tear_diff_direct</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tears</span><span class="p">)</span>
            <span class="n">err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_err</span><span class="p">(</span><span class="n">svals</span><span class="p">,</span> <span class="n">dvals</span><span class="p">,</span> <span class="n">tol_type</span><span class="p">)</span>
            <span class="n">hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">report_diffs</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Diff matrix:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">err</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">itercount</span> <span class="o">&gt;=</span> <span class="n">iterLim</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Direct failed to converge in </span><span class="si">%s</span><span class="s2"> iterations&quot;</span> <span class="o">%</span> <span class="n">iterLim</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">hist</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">pass_tear_direct</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tears</span><span class="p">)</span>

            <span class="n">itercount</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Running Direct iteration </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">itercount</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_order</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">ignore</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pass_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">outEdges</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Direct converged in </span><span class="si">%s</span><span class="s2"> iterations&quot;</span> <span class="o">%</span> <span class="n">itercount</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">hist</span>

    <span class="k">def</span> <span class="nf">solve_tear_wegstein</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">G</span><span class="p">,</span>
        <span class="n">order</span><span class="p">,</span>
        <span class="n">function</span><span class="p">,</span>
        <span class="n">tears</span><span class="p">,</span>
        <span class="n">outEdges</span><span class="p">,</span>
        <span class="n">iterLim</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">,</span>
        <span class="n">tol_type</span><span class="p">,</span>
        <span class="n">report_diffs</span><span class="p">,</span>
        <span class="n">accel_min</span><span class="p">,</span>
        <span class="n">accel_max</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use Wegstein to solve tears. If multiple tears are given</span>
<span class="sd">        they are solved simultaneously.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">            order</span>
<span class="sd">                List of lists of order in which to calculate nodes</span>
<span class="sd">            tears</span>
<span class="sd">                List of tear edge indexes</span>
<span class="sd">            iterLim</span>
<span class="sd">                Limit on the number of iterations to run</span>
<span class="sd">            tol</span>
<span class="sd">                Tolerance at which iteration can be stopped</span>
<span class="sd">            accel_min</span>
<span class="sd">                Minimum value for Wegstein acceleration factor</span>
<span class="sd">            accel_max</span>
<span class="sd">                Maximum value for Wegstein acceleration factor</span>
<span class="sd">            tol_type</span>
<span class="sd">                Type of tolerance value, either &quot;abs&quot; (absolute) or</span>
<span class="sd">                &quot;rel&quot; (relative to current value)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            list</span>
<span class="sd">                List of lists of diff history, differences between input and</span>
<span class="sd">                output values at each iteration</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># diff at each iteration in every variable</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">tears</span><span class="p">):</span>
            <span class="c1"># no need to iterate just run the calculations</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_order</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">tears</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">hist</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting Wegstein tear convergence&quot;</span><span class="p">)</span>

        <span class="n">itercount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ignore</span> <span class="o">=</span> <span class="n">tears</span> <span class="o">+</span> <span class="n">outEdges</span>

        <span class="n">gofx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_gofx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tears</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_first_x</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tears</span><span class="p">)</span>

        <span class="n">err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_err</span><span class="p">(</span><span class="n">gofx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">tol_type</span><span class="p">)</span>
        <span class="n">hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">report_diffs</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Diff matrix:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">err</span><span class="p">)</span>

        <span class="c1"># check if it&#39;s already solved</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Wegstein converged in </span><span class="si">%s</span><span class="s2"> iterations&quot;</span> <span class="o">%</span> <span class="n">itercount</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">hist</span>

        <span class="c1"># if not solved yet do one direct step</span>
        <span class="n">x_prev</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">gofx_prev</span> <span class="o">=</span> <span class="n">gofx</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">gofx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pass_tear_wegstein</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tears</span><span class="p">,</span> <span class="n">gofx</span><span class="p">)</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">itercount</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Running Wegstein iteration </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">itercount</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_order</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">ignore</span><span class="p">)</span>

            <span class="n">gofx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_gofx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tears</span><span class="p">)</span>

            <span class="n">err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_err</span><span class="p">(</span><span class="n">gofx</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">tol_type</span><span class="p">)</span>
            <span class="n">hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">report_diffs</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Diff matrix:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">err</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">itercount</span> <span class="o">&gt;</span> <span class="n">iterLim</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Wegstein failed to converge in </span><span class="si">%s</span><span class="s2"> iterations&quot;</span> <span class="o">%</span> <span class="n">iterLim</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">hist</span>

            <span class="n">denom</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x_prev</span>
            <span class="c1"># this will divide by 0 at some points but we handle that below,</span>
            <span class="c1"># so ignore division warnings</span>
            <span class="n">old_settings</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
            <span class="n">slope</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">divide</span><span class="p">((</span><span class="n">gofx</span> <span class="o">-</span> <span class="n">gofx_prev</span><span class="p">),</span> <span class="n">denom</span><span class="p">)</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="n">old_settings</span><span class="p">)</span>
            <span class="c1"># if isnan or isinf then x and x_prev were the same,</span>
            <span class="c1"># so just do direct sub for those elements</span>
            <span class="n">slope</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">slope</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">slope</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">slope</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">accel</span> <span class="o">=</span> <span class="n">slope</span> <span class="o">/</span> <span class="p">(</span><span class="n">slope</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">accel</span><span class="p">[</span><span class="n">accel</span> <span class="o">&lt;</span> <span class="n">accel_min</span><span class="p">]</span> <span class="o">=</span> <span class="n">accel_min</span>
            <span class="n">accel</span><span class="p">[</span><span class="n">accel</span> <span class="o">&gt;</span> <span class="n">accel_max</span><span class="p">]</span> <span class="o">=</span> <span class="n">accel_max</span>
            <span class="n">x_prev</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">gofx_prev</span> <span class="o">=</span> <span class="n">gofx</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">accel</span> <span class="o">*</span> <span class="n">x_prev</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">accel</span><span class="p">)</span> <span class="o">*</span> <span class="n">gofx_prev</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pass_tear_wegstein</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tears</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pass_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">outEdges</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Wegstein converged in </span><span class="si">%s</span><span class="s2"> iterations&quot;</span> <span class="o">%</span> <span class="n">itercount</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">hist</span>

    <span class="k">def</span> <span class="nf">scc_collect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">excludeEdges</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is an algorithm for finding strongly connected components (SCCs)</span>
<span class="sd">        in a graph. It is based on Tarjan. 1972 Depth-First Search and Linear</span>
<span class="sd">        Graph Algorithms, SIAM J. Comput. v1 no. 2 1972</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            sccNodes</span>
<span class="sd">                List of lists of nodes in each SCC</span>
<span class="sd">            sccEdges</span>
<span class="sd">                List of lists of edge indexes in each SCC</span>
<span class="sd">            sccOrder</span>
<span class="sd">                List of lists for order in which to calculate SCCs</span>
<span class="sd">            outEdges</span>
<span class="sd">                List of lists of edge indexes leaving the SCC</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">sc</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">stk</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">stringComps</span><span class="p">):</span>
            <span class="c1"># recursive sub-function for backtracking</span>
            <span class="n">ndepth</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span>
            <span class="n">back</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span>
            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">stk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">ndepth</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sc</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">stk</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">stringComps</span><span class="p">)</span>
                    <span class="n">back</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">back</span><span class="p">[</span><span class="n">w</span><span class="p">],</span> <span class="n">back</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">stk</span><span class="p">:</span>
                    <span class="n">back</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">back</span><span class="p">[</span><span class="n">w</span><span class="p">],</span> <span class="n">back</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">back</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">ndepth</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="n">scomp</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">stk</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">scomp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i2n</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="n">stringComps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scomp</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">depth</span>

        <span class="n">i2n</span><span class="p">,</span> <span class="n">adj</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adj_lists</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">excludeEdges</span><span class="o">=</span><span class="n">excludeEdges</span><span class="p">)</span>

        <span class="n">stk</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># node stack</span>
        <span class="n">stringComps</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of SCCs</span>
        <span class="n">ndepth</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">i2n</span><span class="p">)</span>
        <span class="n">back</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">i2n</span><span class="p">)</span>

        <span class="c1"># find the SCCs</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i2n</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">ndepth</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sc</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">stk</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stringComps</span><span class="p">)</span>

        <span class="c1"># Find the rest of the information about SCCs given the node partition</span>
        <span class="n">sccNodes</span> <span class="o">=</span> <span class="n">stringComps</span>
        <span class="n">sccEdges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">outEdges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">inEdges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">nset</span> <span class="ow">in</span> <span class="n">stringComps</span><span class="p">:</span>
            <span class="n">e</span><span class="p">,</span> <span class="n">ie</span><span class="p">,</span> <span class="n">oe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_graph_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nset</span><span class="p">)</span>
            <span class="n">sccEdges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">inEdges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ie</span><span class="p">)</span>
            <span class="n">outEdges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oe</span><span class="p">)</span>
        <span class="n">sccOrder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scc_calculation_order</span><span class="p">(</span><span class="n">sccNodes</span><span class="p">,</span> <span class="n">inEdges</span><span class="p">,</span> <span class="n">outEdges</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sccNodes</span><span class="p">,</span> <span class="n">sccEdges</span><span class="p">,</span> <span class="n">sccOrder</span><span class="p">,</span> <span class="n">outEdges</span>

    <span class="k">def</span> <span class="nf">scc_calculation_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sccNodes</span><span class="p">,</span> <span class="n">ie</span><span class="p">,</span> <span class="n">oe</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This determines the order in which to do calculations for strongly</span>
<span class="sd">        connected components. It is used to help determine the most efficient</span>
<span class="sd">        order to solve tear streams to prevent extra iterations. This just</span>
<span class="sd">        makes an adjacency list with the SCCs as nodes and calls the tree</span>
<span class="sd">        order function.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">            sccNodes</span>
<span class="sd">                List of lists of nodes in each SCC</span>
<span class="sd">            ie</span>
<span class="sd">                List of lists of in edge indexes to SCCs</span>
<span class="sd">            oe</span>
<span class="sd">                List of lists of out edge indexes to SCCs</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># SCC adjacency list</span>
        <span class="n">adjR</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># SCC reverse adjacency list</span>
        <span class="c1"># populate with empty lists before running the loop below</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sccNodes</span><span class="p">)):</span>
            <span class="n">adj</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="n">adjR</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

        <span class="c1"># build adjacency lists</span>
        <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sccNodes</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sccNodes</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">ine</span> <span class="ow">in</span> <span class="n">ie</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">oute</span> <span class="ow">in</span> <span class="n">oe</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">ine</span> <span class="o">==</span> <span class="n">oute</span><span class="p">:</span>
                            <span class="n">adj</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                            <span class="n">adjR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                            <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">done</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">done</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_order</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">adjR</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">calculation_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">roots</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rely on tree_order to return a calculation order of nodes</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">            roots</span>
<span class="sd">                List of nodes to consider as tree roots,</span>
<span class="sd">                if None then the actual roots are used</span>
<span class="sd">            nodes</span>
<span class="sd">                Subset of nodes to consider in the tree,</span>
<span class="sd">                if None then all nodes are used</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tear_set</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">i2n</span><span class="p">,</span> <span class="n">adj</span><span class="p">,</span> <span class="n">adjR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adj_lists</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">excludeEdges</span><span class="o">=</span><span class="n">tset</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">)</span>

        <span class="n">order</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">roots</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_idx</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
            <span class="n">rootsIndex</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
                <span class="n">rootsIndex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_map</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rootsIndex</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">orderIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_order</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">adjR</span><span class="p">,</span> <span class="n">rootsIndex</span><span class="p">)</span>

        <span class="c1"># convert indexes to actual nodes</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orderIndex</span><span class="p">)):</span>
            <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orderIndex</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i2n</span><span class="p">[</span><span class="n">orderIndex</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">order</span>

    <span class="k">def</span> <span class="nf">tree_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adj</span><span class="p">,</span> <span class="n">adjR</span><span class="p">,</span> <span class="n">roots</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function determines the ordering of nodes in a directed</span>
<span class="sd">        tree. This is a generic function that can operate on any</span>
<span class="sd">        given tree represented by the adjaceny and reverse</span>
<span class="sd">        adjacency lists. If the adjacency list does not represent</span>
<span class="sd">        a tree the results are not valid.</span>

<span class="sd">        In the returned order, it is sometimes possible for more</span>
<span class="sd">        than one node to be calculated at once. So a list of lists</span>
<span class="sd">        is returned by this function. These represent a bredth</span>
<span class="sd">        first search order of the tree. Following the order, all</span>
<span class="sd">        nodes that lead to a particular node will be visited</span>
<span class="sd">        before it.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">            adj</span>
<span class="sd">                An adjeceny list for a directed tree. This uses</span>
<span class="sd">                generic integer node indexes, not node names from the</span>
<span class="sd">                graph itself. This allows this to be used on sub-graphs</span>
<span class="sd">                and graps of components more easily.</span>
<span class="sd">            adjR</span>
<span class="sd">                The reverse adjacency list coresponing to adj</span>
<span class="sd">            roots</span>
<span class="sd">                List of node indexes to start from. These do not</span>
<span class="sd">                need to be the root nodes of the tree, in some cases</span>
<span class="sd">                like when a node changes the changes may only affect</span>
<span class="sd">                nodes reachable in the tree from the changed node, in</span>
<span class="sd">                the case that roots are supplied not all the nodes in</span>
<span class="sd">                the tree may appear in the ordering. If no roots are</span>
<span class="sd">                supplied, the roots of the tree are used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adjR</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">adjR</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">adjR</span><span class="p">):</span>
            <span class="n">adjR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">roots</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">roots</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">mark</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>  <span class="c1"># mark all nodes if no roots specified</span>
            <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
            <span class="c1"># no root specified so find roots of tree by marking every</span>
            <span class="c1"># successor of every node, since roots have no predecessors</span>
            <span class="k">for</span> <span class="n">sucs</span> <span class="ow">in</span> <span class="n">adj</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sucs</span><span class="p">:</span>
                    <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># make list of roots</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if roots are specified mark descendants</span>
            <span class="n">mark</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="n">roots</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lst2</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                    <span class="n">mark</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">lst2</span> <span class="o">+=</span> <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">lst</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">lst2</span><span class="p">)</span>  <span class="c1"># remove dupes</span>

        <span class="c1"># Now we have list of roots, and roots and their desendants are marked</span>
        <span class="n">ndepth</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">checknodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># list of candidate nodes for next depth</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>  <span class="c1"># nodes adjacent to roots are candidates</span>
            <span class="n">checknodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># nodes to add to the next depth in order</span>
            <span class="n">delSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># nodes to delete from checknodes</span>
            <span class="n">checkUpdate</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># nodes to add to checknodes</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">checknodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ndepth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># This means there is a cycle in the graph</span>
                    <span class="c1"># this will lead to nonsense so throw exception</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Function tree_order does not work with cycles&quot;</span><span class="p">)</span>
                <span class="n">remSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># to remove from a nodes rev adj list</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">adjR</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">order</span><span class="p">[</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="c1"># ancestor already placed</span>
                        <span class="n">remSet</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">mark</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="c1"># ancestor doesn&#39;t descend from root</span>
                        <span class="n">remSet</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="c1"># delete parents from rev adj list if they were found</span>
                <span class="c1"># to be already placed or not in subgraph</span>
                <span class="n">adjR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">remSet</span><span class="p">)</span>
                <span class="c1"># if rev adj list is empty, all ancestors</span>
                <span class="c1"># have been placed so add node</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">adjR</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ndepth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span>
                    <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">delSet</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">checkUpdate</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="c1"># Delete the nodes that were added from the check set</span>
            <span class="n">checknodes</span> <span class="o">=</span> <span class="n">checknodes</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">delSet</span><span class="p">)</span>
            <span class="n">checknodes</span> <span class="o">=</span> <span class="n">checknodes</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">checkUpdate</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">order</span>

    <span class="k">def</span> <span class="nf">check_tear_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">tset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether the specified tear streams are sufficient.</span>
<span class="sd">        If the graph minus the tear edges is not a tree then the</span>
<span class="sd">        tear set is not sufficient to solve the graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sccNodes</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scc_collect</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">excludeEdges</span><span class="o">=</span><span class="n">tset</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">sccNodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">select_tear_heuristic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This finds optimal sets of tear edges based on two criteria.</span>
<span class="sd">        The primary objective is to minimize the maximum number of</span>
<span class="sd">        times any cycle is broken. The secondary criteria is to</span>
<span class="sd">        minimize the number of tears.</span>

<span class="sd">        This function uses a branch and bound type approach.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            tsets</span>
<span class="sd">                List of lists of tear sets. All the tear sets returned</span>
<span class="sd">                are equally good. There are often a very large number</span>
<span class="sd">                of equally good tear sets.</span>
<span class="sd">            upperbound_loop</span>
<span class="sd">                The max number of times any single loop is torn</span>
<span class="sd">            upperbound_total</span>
<span class="sd">                The total number of loops</span>

<span class="sd">        Improvements for the future</span>

<span class="sd">        I think I can improve the efficiency of this, but it is good</span>
<span class="sd">        enough for now. Here are some ideas for improvement:</span>

<span class="sd">            1. Reduce the number of redundant solutions. It is possible</span>
<span class="sd">            to find tears sets [1,2] and [2,1]. I eliminate</span>
<span class="sd">            redundant solutions from the results, but they can</span>
<span class="sd">            occur and it reduces efficiency.</span>

<span class="sd">            2. Look at strongly connected components instead of whole</span>
<span class="sd">            graph. This would cut back on the size of graph we are</span>
<span class="sd">            looking at. The flowsheets are rarely one strongly</span>
<span class="sd">            conneted component.</span>

<span class="sd">            3. When you add an edge to a tear set you could reduce the</span>
<span class="sd">            size of the problem in the branch by only looking at</span>
<span class="sd">            strongly connected components with that edge removed.</span>

<span class="sd">            4. This returns all equally good optimal tear sets. That</span>
<span class="sd">            may not really be necessary. For very large flowsheets,</span>
<span class="sd">            there could be an extremely large number of optimial tear</span>
<span class="sd">            edge sets.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">sear</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">prevY</span><span class="p">):</span>
            <span class="c1"># This is a recursive function for generating tear sets.</span>
            <span class="c1"># It selects one edge from a cycle, then calls itself</span>
            <span class="c1"># to select an edge from the next cycle.  It is a branch</span>
            <span class="c1"># and bound search tree to find best tear sets.</span>

            <span class="c1"># The function returns when all cycles are torn, which</span>
            <span class="c1"># may be before an edge was selected from each cycle if</span>
            <span class="c1"># cycles contain common edges.</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cycleEdges</span><span class="p">[</span><span class="n">depth</span><span class="p">])):</span>
                <span class="c1"># Loop through all the edges in cycle with index depth</span>
                <span class="n">y</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">prevY</span><span class="p">)</span>  <span class="c1"># get list of already selected tear stream</span>
                <span class="n">y</span><span class="p">[</span><span class="n">cycleEdges</span><span class="p">[</span><span class="n">depth</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1"># calculate number of times each cycle is torn</span>
                <span class="n">Ay</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="n">maxAy</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Ay</span><span class="p">)</span>
                <span class="n">sumY</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">maxAy</span> <span class="o">&gt;</span> <span class="n">upperBound</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="c1"># breaking a cycle too many times, branch is no good</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">maxAy</span> <span class="o">==</span> <span class="n">upperBound</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">sumY</span> <span class="o">&gt;</span> <span class="n">upperBound</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="c1"># too many tears, branch is no good</span>
                    <span class="k">continue</span>
                <span class="c1"># Call self at next depth where a cycle is not broken</span>
                <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">Ay</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">maxAy</span> <span class="o">&lt;</span> <span class="n">upperBound</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">upperBound</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxAy</span>  <span class="c1"># most important factor</span>
                        <span class="n">upperBound</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sumY</span>  <span class="c1"># second most important</span>
                    <span class="k">elif</span> <span class="n">sumY</span> <span class="o">&lt;</span> <span class="n">upperBound</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">upperBound</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sumY</span>
                    <span class="c1"># record solution</span>
                    <span class="n">ySet</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">maxAy</span><span class="p">,</span> <span class="n">sumY</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nr</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">Ay</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">sear</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="c1"># Get a quick and I think pretty good tear set for upper bound</span>
        <span class="n">tearUB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tear_upper_bound</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

        <span class="c1"># Find all the cycles in a graph and make cycle-edge matrix A</span>
        <span class="c1"># Rows of A are cycles and columns of A are edges</span>
        <span class="c1"># 1 if an edge is in a cycle, 0 otherwise</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">cycleEdges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cycle_edge_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">nr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># no cycles so we are done</span>
            <span class="k">return</span> <span class="p">[[[]],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Else there are cycles, so find edges to tear</span>
        <span class="n">y_init</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span>  <span class="c1"># whether edge j is in tear set</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">tearUB</span><span class="p">:</span>
            <span class="c1"># y for initial u.b. solution</span>
            <span class="n">y_init</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">Ay_init</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y_init</span><span class="p">)</span>  <span class="c1"># number of times each loop torn</span>

        <span class="c1"># Set two upper bounds. The fist upper bound is on number of times</span>
        <span class="c1"># a loop is broken. Second upper bound is on number of tears.</span>
        <span class="n">upperBound</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">Ay_init</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">y_init</span><span class="p">)]</span>

        <span class="n">y_init</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span>  <span class="c1"># clear y vector to start search</span>
        <span class="n">ySet</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># a list of tear sets</span>
        <span class="c1"># Three elements are stored in each tear set:</span>
        <span class="c1"># 0 = y vector (tear set), 1 = max(Ay), 2 = sum(y)</span>

        <span class="c1"># Call recursive function to find tear sets</span>
        <span class="n">sear</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y_init</span><span class="p">)</span>

        <span class="c1"># Screen tear sets found</span>
        <span class="c1"># A set can be recorded before upper bound is updated so we can</span>
        <span class="c1"># just throw out sets with objectives higher than u.b.</span>
        <span class="n">deleteSet</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># vector of tear set indexes to delete</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ySet</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">ySet</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">upperBound</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">deleteSet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ySet</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">upperBound</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ySet</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">upperBound</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">deleteSet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">deleteSet</span><span class="p">):</span>
            <span class="k">del</span> <span class="n">ySet</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Check for duplicates and delete them</span>
        <span class="n">deleteSet</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ySet</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">deleteSet</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ySet</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">deleteSet</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_init</span><span class="p">)):</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">ySet</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ySet</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">k</span><span class="p">]:</span>
                        <span class="n">eq</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">eq</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">deleteSet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">deleteSet</span><span class="p">)):</span>
            <span class="k">del</span> <span class="n">ySet</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Turn the binary y vectors into lists of edge indexes</span>
        <span class="n">es</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">ySet</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">es</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">es</span><span class="p">,</span> <span class="n">upperBound</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">upperBound</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">tear_upper_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function quickly finds a sub-optimal set of tear</span>
<span class="sd">        edges. This serves as an initial upperbound when looking</span>
<span class="sd">        for an optimal tear set. Having an initial upper bound</span>
<span class="sd">        improves efficiency.</span>

<span class="sd">        This works by constructing a search tree and just makes a</span>
<span class="sd">        tear set out of all the back edges.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">cyc</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
            <span class="c1"># this is a recursive function</span>
            <span class="n">depths</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span>
            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">out_edges</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">suc</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">depths</span><span class="p">[</span><span class="n">suc</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">parents</span><span class="p">[</span><span class="n">suc</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
                    <span class="n">cyc</span><span class="p">(</span><span class="n">suc</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">depths</span><span class="p">[</span><span class="n">suc</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">depths</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                    <span class="c1"># found a back edge, add to tear set</span>
                    <span class="n">tearSet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_list</span><span class="o">.</span><span class="n">index</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">suc</span><span class="p">,</span> <span class="n">key</span><span class="p">)))</span>

        <span class="n">tearSet</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of back/tear edges</span>
        <span class="n">edge_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_to_edge</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">depths</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">depths</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">parents</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">depths</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cyc</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tearSet</span>

    <span class="k">def</span> <span class="nf">sub_graph_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns a list of edge indexes that are</span>
<span class="sd">        included in a subgraph given by a list of nodes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            edges</span>
<span class="sd">                List of edge indexes in the subgraph</span>
<span class="sd">            inEdges</span>
<span class="sd">                List of edge indexes starting outside the subgraph</span>
<span class="sd">                and ending inside</span>
<span class="sd">            outEdges</span>
<span class="sd">                List of edge indexes starting inside the subgraph</span>
<span class="sd">                and ending outside</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">e</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># edges that connect two nodes in the subgraph</span>
        <span class="n">ie</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># in edges</span>
        <span class="n">oe</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># out edges</span>
        <span class="n">edge_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_to_edge</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()):</span>
            <span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">edge_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dest</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                    <span class="c1"># it&#39;s in the sub graph</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># it&#39;s an out edge of the subgraph</span>
                    <span class="n">oe</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dest</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="c1"># its a in edge of the subgraph</span>
                <span class="n">ie</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">e</span><span class="p">,</span> <span class="n">ie</span><span class="p">,</span> <span class="n">oe</span>

    <span class="k">def</span> <span class="nf">cycle_edge_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a cycle-edge incidence matrix, a list of list of nodes in</span>
<span class="sd">        each cycle, and a list of list of edge indexes in each cycle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cycleNodes</span><span class="p">,</span> <span class="n">cycleEdges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_cycles</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>  <span class="c1"># call cycle finding algorithm</span>

        <span class="c1"># Create empty incidence matrix and then fill it out</span>
        <span class="n">ceMat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cycleEdges</span><span class="p">),</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cycleEdges</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">cycleEdges</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">ceMat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">ceMat</span><span class="p">,</span> <span class="n">cycleNodes</span><span class="p">,</span> <span class="n">cycleEdges</span>

    <span class="k">def</span> <span class="nf">all_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function finds all the cycles in a directed graph.</span>
<span class="sd">        The algorithm is based on Tarjan 1973 Enumeration of the</span>
<span class="sd">        elementary circuits of a directed graph, SIAM J. Comput. v3 n2 1973.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            cycleNodes</span>
<span class="sd">                List of lists of nodes in each cycle</span>
<span class="sd">            cycleEdges</span>
<span class="sd">                List of lists of edge indexes in each cycle</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">pre_key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="c1"># sub-function recursive part</span>
            <span class="n">f</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">pointStack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">pre_key</span><span class="p">))</span>
            <span class="n">mark</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">markStack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">sucs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sucs</span><span class="p">:</span>
                <span class="c1"># iterate over successor indexes and keys</span>
                <span class="k">if</span> <span class="n">si</span> <span class="o">&lt;</span> <span class="n">ni</span><span class="p">:</span>
                    <span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">si</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">si</span> <span class="o">==</span> <span class="n">ni</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">cyc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pointStack</span><span class="p">)</span>  <span class="c1"># copy</span>
                    <span class="c1"># append the original point again so we get the last edge</span>
                    <span class="n">cyc</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">si</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
                    <span class="n">cycles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cyc</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">mark</span><span class="p">[</span><span class="n">si</span><span class="p">]:</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="ow">or</span> <span class="n">g</span>

            <span class="k">if</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">markStack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">v</span><span class="p">:</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">markStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">mark</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">markStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">mark</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="n">pointStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">f</span>

        <span class="n">i2n</span><span class="p">,</span> <span class="n">adj</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adj_lists</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">multi</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pointStack</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># stack of (node, key) tuples</span>
        <span class="n">markStack</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># nodes that have been marked</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of cycles found</span>
        <span class="n">mark</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">i2n</span><span class="p">)</span>  <span class="c1"># if a node is marked</span>

        <span class="k">for</span> <span class="n">ni</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i2n</span><span class="p">)):</span>
            <span class="c1"># iterate over node indexes</span>
            <span class="n">backtrack</span><span class="p">(</span><span class="n">ni</span><span class="p">)</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">markStack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">markStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">mark</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Turn node indexes back into nodes</span>
        <span class="n">cycleNodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">cycles</span><span class="p">:</span>
            <span class="n">cycleNodes</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cycle</span><span class="p">)):</span>
                <span class="n">ni</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="n">cycle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="c1"># change the node index in cycles to a node as well</span>
                <span class="n">cycle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i2n</span><span class="p">[</span><span class="n">ni</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span>
                <span class="n">cycleNodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i2n</span><span class="p">[</span><span class="n">ni</span><span class="p">])</span>
            <span class="c1"># pop the last node since it is the same as the first</span>
            <span class="n">cycleNodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="c1"># Now find list of edges in the cycle</span>
        <span class="n">edge_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_to_idx</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">cycleEdges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cyc</span> <span class="ow">in</span> <span class="n">cycles</span><span class="p">:</span>
            <span class="n">ecyc</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cyc</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">pre</span><span class="p">,</span> <span class="n">suc</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="n">cyc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">cyc</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">cyc</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">ecyc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_map</span><span class="p">[(</span><span class="n">pre</span><span class="p">,</span> <span class="n">suc</span><span class="p">,</span> <span class="n">key</span><span class="p">)])</span>
            <span class="n">cycleEdges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ecyc</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cycleNodes</span><span class="p">,</span> <span class="n">cycleEdges</span>

    <span class="k">def</span> <span class="nf">adj_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">excludeEdges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multi</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an adjacency list and a reverse adjacency list</span>
<span class="sd">        of node indexes for a MultiDiGraph.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">            G</span>
<span class="sd">                A networkx MultiDiGraph</span>
<span class="sd">            excludeEdges</span>
<span class="sd">                List of edge indexes to ignore when considering neighbors</span>
<span class="sd">            nodes</span>
<span class="sd">                List of nodes to form the adjacencies from</span>
<span class="sd">            multi</span>
<span class="sd">                If True, adjacency lists will contains tuples of</span>
<span class="sd">                (node, key) for every edge between two nodes</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            i2n</span>
<span class="sd">                Map from index to node for all nodes included in nodes</span>
<span class="sd">            adj</span>
<span class="sd">                Adjacency list of successor indexes</span>
<span class="sd">            adjR</span>
<span class="sd">                Reverse adjacency list of predecessor indexes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">adjR</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">exclude</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">excludeEdges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_to_edge</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="n">excludeEdges</span><span class="p">:</span>
                <span class="n">exclude</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge_list</span><span class="p">[</span><span class="n">ei</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_to_node</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

        <span class="c1"># we might not be including every node in these lists, so we need</span>
        <span class="c1"># custom maps to get between indexes and nodes</span>
        <span class="n">i2n</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">n2i</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">n2i</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">i2n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>

        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">adj</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="n">adjR</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

            <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">out_edges</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">suc</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">multi</span> <span class="ow">and</span> <span class="n">suc</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="c1"># we only need to add the neighbor once</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">suc</span> <span class="ow">in</span> <span class="n">nodes</span> <span class="ow">and</span> <span class="n">edge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">:</span>
                    <span class="c1"># only add neighbor to seen if the edge is not excluded</span>
                    <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">suc</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">multi</span><span class="p">:</span>
                        <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n2i</span><span class="p">[</span><span class="n">suc</span><span class="p">],</span> <span class="n">key</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n2i</span><span class="p">[</span><span class="n">suc</span><span class="p">])</span>

            <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">in_edges</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">pre</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">multi</span> <span class="ow">and</span> <span class="n">pre</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">pre</span> <span class="ow">in</span> <span class="n">nodes</span> <span class="ow">and</span> <span class="n">edge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">:</span>
                    <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pre</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">multi</span><span class="p">:</span>
                        <span class="n">adjR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n2i</span><span class="p">[</span><span class="n">pre</span><span class="p">],</span> <span class="n">key</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">adjR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n2i</span><span class="p">[</span><span class="n">pre</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">i2n</span><span class="p">,</span> <span class="n">adj</span><span class="p">,</span> <span class="n">adjR</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2008-2023, Sandia National Laboratories.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>