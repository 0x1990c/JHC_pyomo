# Rooney Biegler model, data, and callback

import re
import pandas as pd
import numpy as np
import pyomo.environ as pyo

data = pd.DataFrame(data=[[1,8.3],[2,10.3],[3,19.0],[4,16.0],[5,15.6],[6,19.8]],
                    columns=['hour', 'y'])

def generate_model(data):
    
    h = int(data['hour'])
    y = float(data['y'])
    
    model = pyo.ConcreteModel()
    model.asymptote = pyo.Var(initialize=15)
    model.rate_constant = pyo.Var(initialize=0.5)

    def response_rule(m):
        expr = m.asymptote * (1 - pyo.exp(-m.rate_constant * h))
        return expr

    model.response_function = pyo.Expression(rule=response_rule)

    def SSE_rule(m):
        return (y - m.response_function) ** 2

    def ComputeFirstStageCost_rule(m):
        return 0

    model.FirstStageCost = pyo.Expression(rule=ComputeFirstStageCost_rule)
    model.SecondStageCost = pyo.Expression(rule=SSE_rule)

    def total_cost_rule(model):
        return model.FirstStageCost + model.SecondStageCost

    # This objective is not needed by parmest
    model.Total_Cost_Objective = pyo.Objective(rule=total_cost_rule, 
                                               sense=pyo.minimize)
    
    return model

def pysp_instance_creation_callback(scenario_tree_model,
                                    scenario_name,
                                    node_names):
    
    if isinstance(scenario_name, str): # if scenario is a str, get the trailing integer
        index = int(re.compile(r'(\d+)$').search(scenario_name).group(1))
    elif isinstance(scenario_name, int):
        index = scenario_name
    else:
        return
    
    model = generate_model(data.loc[index,:])
    
    return model


if __name__ == '__main__':

    model = pysp_instance_creation_callback(None, 'foo2', None)
    solver = pyo.SolverFactory('ipopt')
    solver.solve(model)
    model.display()
    model.pprint()
    print('asymptote = ', model.asymptote())
    print('rate constant = ', model.rate_constant())
